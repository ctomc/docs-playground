WildFly Elytron Security
========================

[[about]]
= About

The WildFly Elytron project is a new security framework brought to
WildFly to provide a single unified security framework across the whole
of the application server. As a single framework it will be usable both
for configuring management access to the server and for applications
deployed to the server, it will also be usable across all process types
so there will be no need to learn a different security framework for
host controllers in a domain compared to configuring a standalone
server.

The project covers these main areas: -

* Authentication
* Authorization
* SSL / TLS
* Secure Credential Storage

[[authentication]]
== Authentication

One of the fundamental objectives of the project was to ensure that we
can use stronger authentication mechanisms for both HTTP and SASL based
authentication, in both cases the new framework also makes it possible
to bring in new implementations opening up various integration
opportunities with external solutions.

[[authorization]]
== Authorization

The architecture of the project makes a very clear distinction between
the raw representation of the identity as returned by a SecurityRealm
from the repository of identities and the final representation as a
SecurityIdentity after roles have been decoded and mapped and
permissions have been mapped.

Custom implementations of the components to perform role decoding and
mapping, and permission mapping can be provided allowing for further
flexibility beyond the default set of components provided by the
project.

[[ssl-tls]]
== SSL / TLS

The project becomes the centralised point within the application server
for configuring SSL related resources meaning they can be configured in
a central location and referenced by resources across the application
server. The centralised configuration also covers advanced options such
as configuration of enabled cipher suites and protocols without this
information needing to be distributed across the management model.

The SSL / TLS implementation also includes an optimisation where it can
be closely tied to authentication allowing for permissions checks to be
performed on establishment of a connection before the first request is
received and the eager construction of a SecurityIdentity eliminating
the need for it to be constructed on a per-request basis.

[[secure-credential-storage]]
== Secure Credential Storage

The previous vault used for plain text String encryption is replaced
with a newly designed credential store. in addition to the protection it
offers for the credentials stored within it, the store currently
supports storage of clear text credentials.

[[general-elytron-architecture]]
= General Elytron Architecture

The overall architecture for WildFly Elytron is building up a full
security policy from assembling smaller components together, by default
we include various implementations of the components - in addition to
this, custom implementations of many components can be provided in order
to provide more specialised implementations.

Within WildFly the different Elytron components are handled as
capabilities meaning that different implementations can be mixed and
matched, however the different implementations are modelled using
distinct resources. This section contains a number of diagrams to show
the general relationships between different components to provide a high
level view, however the different resource definitions may use different
dependencies depending on their purpose.

[[security-domains]]
== Security Domains

Within WildFly Elytron a SecurityDomain can be considered as a security
policy backed by one or more SecurityRealm instances. Resources that
make authorization decisions will be associated with a SecurityDomain,
from the SecurityDomain a SecurityIdentity can be obtained which is a
representation of the current identity, from this the identities roles
and permissions can be checked to make the authorization decision for
the resource.

The SecurityDomain is the general wrapper around the policy describing a
resulting SecurityIdentity and makes use of the following components to
define this policy.

* NameRewriter

NameRewriters are used in multiple places within the Elytron
configuration, as their name implies, their purpose is to take a name
and map it to another representation of the name or perform some
normalisation or clean up of the name.

* RealmMapper

As a SecurityDomain is able to reference multiple SecurityRealms the
RealmMapper is responsible for identifying which SecurityRealm to use
based on the supplied name for authentication.

* SecurityRealm

One more more named SecurityRealms are associated with a SecurityDomain,
the SecurityRealms are the access to the underlying repository of
identities and are used for obtaining credentials to allow
authentication mechanisms to perform verification, for validation of
Evidence and for obtaining the raw AuthorizationIdentity performing the
authentication.

Some SecurityRealm implementations are also modifiable so expose an API
that allows for updates to be made to the repository containing the
identities.

* RoleDecoder

Along with the SecurityRealm association is also a reference to a
RoleDecoder, the RoleDecoder takes the raw AuthorizationIdentity
returned from the SecurityRealm and converts it's attributes into roles.

* RoleMapper

After the roles have been decoded for an identity further mapping can be
applied, this could be as simple at normalising the format of the names
through to adding or removing specific role names. If a RoleMapper is
referenced by the SecurityRealm association that RoleMapper is applied
first before applying the RoleMapper associated with the SecurityDomain.

* PrincipalDecoder

A PrincipalDecoder converts from a Principal to a String representation
of a name, one example for this is we have an X500PrincipalDecoder which
is able to extract an attribute from a distinguished name.

* PermissionMapper

In addition to having roles a SecurityIdentity can also have a set of
permissions, the PermissionMapper assigns those permissions to the
identity.

Different secured resources can be associated with different
SecurityDomains for their authorization decisions, within WildFly
Elytron we have the ability to configure inflow between different
SecurityDomains. The inflow process means that a SecurityIdentity
inflowed into a second SecurityDomain has the mappings of the new
SecurityDomain applied to it so although a common identity may be
calling different resources each of those resources could have a very
different view.

[[sasl-authentication]]
== SASL Authentication

The SaslAuthenticationFactory is an authentication policy for
authentication using SASL authentication mechanisms, in addition to
being a policy it is also a factory for configured authentication
mechanisms backed by a SecurityDomain.

The SaslAuthenticationFactory references the following: -

* SecurityDomain

This is the security domain that any mechanism authentication will be
performed against.

* SaslServerFactory

This is the general factory for server side SASL authentication
mechanisms.

* MechanismConfigurationSelector

Additional configuration can be supplied for the authentication
mechanisms, the configuration will be described in more detail later but
the purpose of the MechanismConfigurationSelector is to obtain
configuration specific to the mechanism selected. This can include
information about realm names a mechanism should present to a remote
client plus additional NameRewriters and RealmMappers to use during the
authentication process.

The reason some of the components referenced by the SecurityDomain are
duplicated is so that mechanism specific mappings can be applied.

[[http-authentication]]
== HTTP Authentication

The HttpAuthenticationFactory is an authentication policy for
authentication using HTTP authentication mechanisms, in addition to
being a policy it is also a factory for configured authentication
mechanisms backed by a SecurityDomain.

The HttpAuthenticationFactory references the following: -

* SecurityDomain

This is the security domain that any mechanism authentication will be
performed against.

* HttpServerAuthenticationMechanismFactory

This is the general factory for server side HTTP authentication
mechanisms.

* MechanismConfigurationSelector

Additional configuration can be supplied for the authentication
mechanisms, the configuration will be described in more detail later but
the purpose of the MechanismConfigurationSelector is to obtain
configuration specific to the mechanism selected. This can include
information about realm names a mechanism should present to a remote
client plus additional NameRewriters and RealmMappers to use during the
authentication process.

The reason some of the components referenced by the SecurityDomain are
duplicated is so that mechanism specific mappings can be applied.

[[ssl-tls-1]]
== SSL / TLS

The SSLContext defined within Elytron is a javax.net.ssl.SSLContext
meaning it can be used by anything that uses an SSLContext directly.

In addition to the usual configuration for an SSLContext it is possible
to configure additional items such as cipher suites and protocols and
the SSLContext returned will wrap any engines created to set these
values.

The SSLContext within Elytron can also reference the following: -

* KeyManagers

An array of KeyManager instances to be used by the SSLContext, this in
turn can reference a KeyStore to load the keys.

* TrustManagers

An array of TrustManager instances to be used by the SSLContext, this in
turn can also reference a KeyStore to load the certificates.

* SecurityDomain

This is optional, however if an SSLContext is configured to reference a
SecurityDomain then verification of a clients certificate can be
performed as an authentication ensuring the appropriate permissions to
Logon are assigned before even allowing the connection to be fully
opened, additionally the SecurityIdentity can be established at the time
the connection is opened and used for any invocations over the
connection.

[[elytron-subsystem]]
= Elytron Subsystem

WildFly Elytron is a security framework used to unify security across
the entire application server. The _elytron_ subsystem enables a single
point of configuration for securing both applications and the management
interfaces. WildFly Elytron also provides a set of APIs and SPIs for
providing custom implementations of functionality and integrating with
the _elytron_ subsystem.

In addition, there are several other important features of the WildFly
Elytron:

* Stronger authentication mechanisms for HTTP and SASL authentication.
* Improved architecture that allows for _SecurityIdentities_ to be
propagated across security domains and transparently transformed ready
to be used for authorization. This transformation takes place using
configurable role decoders, role mappers, and permission mappers.
* Centralized point for SSL/TLS configuration including cipher suites
and protocols.
* SSL/TLS optimizations such as eager _SecureIdentity_ construction and
closely tying authorization to establishing an SSL/TLS connection. Eager
_SecureIdentity_ construction eliminates the need for a _SecureIdentity_
to be constructed on a per-request basis. Closely tying authentication
to establishing an SSL/TLS connection enables permission checks to
happen _BEFORE_ the first request is received.
* A secure credential store that replaces the previous vault
implementation to store clear text credentials.

The new _elytron_ subsystem exists in parallel to the legacy _security_
subsystem and legacy core management authentication. Both the legacy and
Elytron methods may be used for securing the management interfaces as
well as providing security for applications.

[[get-started-using-the-elytron-subsystem]]
== Get Started using the Elytron Subsystem

To get started using Elytron, refer to these topics:

* Use the default Elytron components for
link:#src-557133_WildFlyElytronSecurity-use-default-elytron-app-auth[application]
and
link:#src-557133_WildFlyElytronSecurity-use-default-elytron-mgmt-auth[management]
authentication
* Secure an application with a new identity store stored in a
link:Using_the_Elytron_Subsystem.html#src-557140_UsingtheElytronSubsystem-ConfigureAuthenticationwithaFilesystem-BasedIdentityStore[filesystem]
or
link:Using_the_Elytron_Subsystem.html#src-557140_UsingtheElytronSubsystem-ConfigureAuthenticationwithaDatabaseIdentityStore[database].
* Set up one-way SSL/TLS for
link:Using_the_Elytron_Subsystem.html#src-557140_UsingtheElytronSubsystem-one-way-apps[applications]
or the
link:Using_the_Elytron_Subsystem.html#src-557140_UsingtheElytronSubsystem-one-way-mgmt[management
interfaces].
* Set up two-way SSL/TLS for
link:Using_the_Elytron_Subsystem.html#src-557140_UsingtheElytronSubsystem-two-way-apps[applications]
or the
link:Using_the_Elytron_Subsystem.html#src-557140_UsingtheElytronSubsystem-two-way-mgmt[management
interfaces].
* link:Using_the_Elytron_Subsystem.html#src-557140_UsingtheElytronSubsystem-CreateandUseaCredentialStore[Create
a credential store and use it with your SSL/TLS configuration].
* link:Using_the_Elytron_Subsystem.html#src-557140_UsingtheElytronSubsystem-ConfigureAuthenticationwithCertificates[Use
certificate-based authentication with applications].
* link:Using_the_Elytron_Subsystem.html#src-557140_safe-id-VXNpbmd0aGVFbHl0cm9uU3Vic3lzdGVtLU92ZXJyaWRlYW5BcHBsaWNhdGlvbidzQXV0aGVudGljYXRpb25Db25maWd1cmF0aW9u[Override
an application's authentication configuration] with Elytron
authentication.
* link:Using_the_Elytron_Subsystem.html#src-557140_UsingtheElytronSubsystem-ConfigureAuthenticationwithaKerberos-BasedIdentityStore[Configure
Kerberos authentication for applications].
* Secure
link:Using_the_Elytron_Subsystem.html#src-557140_UsingtheElytronSubsystem-ConfigureAuthenticationwithanLDAP-BasedIdentityStore[applications]
and the
link:Using_the_Elytron_Subsystem.html#src-557140_UsingtheElytronSubsystem-SecuretheManagementInterfaceswithaNewIdentityStore[management
interfaces] with an LDAP-based identity store.

[[provided-components]]
== Provided components

Wildfly Elytron provides a default set of implementations in the
_elytron_ subsystem.

[[factories]]
=== Factories

[cols=",",]
|=======================================================================
|Component |Description

|aggregate-http-server-mechanism-factory |An HTTP server factory
definition where the HTTP server factory is an aggregation of other HTTP
server factories.

|aggregate-sasl-server-factory |A SASL server factory definition where
the SASL server factory is an aggregation of other SASL server
factories.

|configurable-http-server-mechanism-factory |A SASL server factory
definition where the SASL server factory is an aggregation of other SASL
server factories.

|configurable-sasl-server-factory |A SASL server factory definition
where the SASL server factory is an aggregation of other SASL server
factories.

|custom-credential-security-factory |A custom credential SecurityFactory
definition.

|http-authentication-factory |Resource containing the association of a
security domain with a HttpServerAuthenticationMechanismFactory.

|kerberos-security-factory |A security factory for obtaining a
GSSCredential for use during authentication.

|mechanism-provider-filtering-sasl-server-factory |A SASL server factory
definition that enables filtering by provider where the factory was
loaded using a provider.

|provider-http-server-mechanism-factory |An HTTP server factory
definition where the HTTP server factory is an aggregation of factories
from the provider list.

|provider-sasl-server-factory |A SASL server factory definition where
the SASL server factory is an aggregation of factories from the provider
list.

|sasl-authentication-factory |Resource containing the association of a
security domain with a SaslServerFactory.

|service-loader-http-server-mechanism-factory |An HTTP server factory
definition where the HTTP server factory is an aggregation of factories
identified using a ServiceLoader

|service-loader-sasl-server-factory |A SASL server factory definition
where the SASL server factory is an aggregation of factories identified
using a ServiceLoader
|=======================================================================

[[principal-transformers]]
=== Principal Transformers

[cols=",",]
|=======================================================================
|Component |Description

|aggregate-principal-transformer |A principal transformer definition
where the principal transformer is an aggregation of other principal
transformers.

|chained-principal-transformer |A principal transformer definition where
the principal transformer is a chaining of other principal transformers.

|constant-principal-transformer |A principal transformer definition
where the principal transformer always returns the same constant.

|custom-principal-transformer |A custom principal transformer
definition.

|regex-principal-transformer |A regular expression based principal
transformer

|regex-validating-principal-transformer |A regular expression based
principal transformer which uses the regular expression to validate the
name.
|=======================================================================

[[principal-decoders]]
=== Principal Decoders

[cols=",",]
|=======================================================================
|Component |Description

|aggregate-principal-decoder |A principal decoder definition where the
principal decoder is an aggregation of other principal decoders.

|concatenating-principal-decoder |A principal decoder definition where
the principal decoder is a concatenation of other principal decoders.

|constant-principal-decoder |Definition of a principal decoder that
always returns the same constant.

|custom-principal-decoder |Definition of a custom principal decoder.

|x500-attribute-principal-decoder |Definition of a X500 attribute based
principal decoder.
|=======================================================================

[[realm-mappers]]
=== Realm Mappers

[cols=",",]
|=======================================================================
|Component |Description

|constant-realm-mapper |Definition of a constant realm mapper that
always returns the same value.

|custom-realm-mapper |Definition of a custom realm mapper

|mapped-regex-realm-mapper |Definition of a realm mapper implementation
that first uses a regular expression to extract the realm name, this is
then converted using the configured mapping of realm names.

|simple-regex-realm-mapper |Definition of a simple realm mapper that
attempts to extract the realm name using the capture group from the
regular expression, if that does not provide a match then the delegate
realm mapper is used instead.
|=======================================================================

[[realms]]
=== Realms

[cols=",",]
|=======================================================================
|Component |Description

|aggregate-realm |A realm definition that is an aggregation of two
realms, one for the authentication steps and one for loading the
identity for the authorization steps.

|caching-realm |A realm definition that enables caching to another
security realm. Caching strategy is Least Recently Used where least
accessed entries are discarded when maximum number of entries is
reached.

|custom-modifiable-realm |Custom realm configured as being modifiable
will be expected to implement the ModifiableSecurityRealm interface. By
configuring a realm as being modifiable management operations will be
made available to manipulate the realm.

|custom-realm |A custom realm definitions can implement either the s
SecurityRealm interface or the ModifiableSecurityRealm interface.
Regardless of which interface is implemented management operations will
not be exposed to manage the realm. However other services that depend
on the realm will still be able to perform a type check and cast to gain
access to the modification API.

|filesystem-realm |A simple security realm definition backed by the
filesystem.

|identity-realm |A security realm definition where identities are
represented in the management model.

|jdbc-realm |A security realm definition backed by database using JDBC.

|key-store-realm |A security realm definition backed by a keystore.

|ldap-realm |A security realm definition backed by LDAP.

|properties-realm |A security realm definition backed by properties
files.

|token-realm |A security realm definition capable of validating and
extracting identities from security tokens.

|trust-managers |A trust manager definition for creating the
TrustManager list as used to create an SSL context.
|=======================================================================

[[permission-mappers]]
=== Permission Mappers

[cols=",",]
|=======================================================================
|Component |Description

|custom-permission-mapper |Definition of a custom permission mapper.

|logical-permission-mapper |Definition of a logical permission mapper.

|simple-permission-mapper |Definition of a simple configured permission
mapper.

|constant-permission-mapper |Definition of a permission mapper that
always returns the same constant.
|=======================================================================

[[role-decoders]]
=== Role Decoders

[cols=",",]
|=======================================================================
|Component |Description

|custom-role-decoder |Definition of a custom RoleDecoder

|simple-role-decoder |Definition of a simple RoleDecoder that takes a
single attribute and maps it directly to roles.
|=======================================================================

[[role-mappers]]
=== Role Mappers

[cols=",",]
|=======================================================================
|Component |Description

|add-prefix-role-mapper |A role mapper definition for a role mapper that
adds a prefix to each provided.

|add-suffix-role-mapper |A role mapper definition for a role mapper that
adds a suffix to each provided.

|constant-role-mapper |A role mapper definition where a constant set of
roles is always returned.

|aggregate-role-mapper |A role mapper definition where the role mapper
is an aggregation of other role mappers.

|logical-role-mapper |A role mapper definition for a role mapper that
performs a logical operation using two referenced role mappers.

|custom-role-mapper |Definition of a custom role mapper
|=======================================================================

[[ssl-components]]
=== SSL Components

[cols=",",]
|=======================================================================
|Component |Description

|client-ssl-context |An SSLContext for use on the client side of a
connection.

|filtering-key-store |A filtering keystore definition, which provides a
keystore by filtering a key-store.

|key-managers |A key manager definition for creating the key manager
list as used to create an SSL context.

|key-store |A keystore definition.

|ldap-key-store |An LDAP keystore definition, which loads a keystore
from an LDAP server.

|server-ssl-context |An SSL context for use on the server side of a
connection.
|=======================================================================

[[other]]
=== Other

[cols=",",]
|=======================================================================
|Component |Description

|aggregate-providers |An aggregation of two or more Provider[]
resources.

|authentication-configuration |An individual authentication
configuration definition, which is used by clients deployed to Wildfly
and other resources for authenticating when making a remote connection.

|authentication-context |An individual authentication context
definition, which is used to supply an ssl-context and
authentication-configuration when clients deployed to Wildfly and other
resources make a remoting connection.

|credential-store |Credential store to keep alias for sensitive
information such as passwords for external services.

|dir-context |The configuration to connect to a directory (LDAP) server.

|provider-loader |A definition for a provider loader.

|security-domain |A security domain definition.

|security-property |A definition of a security property to be set.
|=======================================================================

[[out-of-the-box-configuration]]
== Out of the Box Configuration

WildFly provides a set of components configured by default. While these
components are ready to use, the legacy _security_ subsystem and legacy
core management authentication is still used by default. To configure
WildFly to use the these configured components as well as create new
ones, see the link:Using_the_Elytron_Subsystem.html[Using the Elytron
Subsystem] section.

[cols=",",]
|=======================================================================
|Default Component |Description

|ApplicationDomain |The ApplicationDomain security domain uses
ApplicationRealm and groups-to-roles for authentication. It also uses
default-permission-mapper to assign the login permission.

|ManagementDomain |The ManagementDomain security domain uses two
security realms for authentication: ManagementRealm with groups-to-roles
and local with super-user-mapper. It also uses default-permission-mapper
to assign the login permission.

|local (security realm) |The local security realm does no authentication
and sets the identity of principals to $local

|ApplicationRealm |The ApplicationRealm security realm is a properties
realm that authenticates principals using application-users.properties
and assigns roles using application-roles.properties. These files are
located under jboss.server.config.dir, which by default, maps to
EAP_HOME/standalone/configuration. They are also the same files used by
the legacy security default configuration.

|ManagementRealm |The ManagementRealm security realm is a properties
realm that authenticates principals using mgmt-users.properties and
assigns roles using mgmt-groups.properties. These files are located
under jboss.server.config.dir, which by default, maps to
EAP_HOME/standalone/configuration. They are also the same files used by
the legacy security default configuration.

|default-permission-mapper |The default-permission-mapper mapper is a
constant permission mapper that uses
org.wildfly.security.auth.permission.LoginPermission to assign the login
permission and
org.wildfly.extension.batch.jberet.deployment.BatchPermission to assign
permission for batch jobs. The batch permissions are start, stop,
restart, abandon, and read which aligns with
javax.batch.operations.JobOperator.

|local (mapper) |The local mapper is a constant role mapper that maps to
the local security realm. This is used to map authentication to the
local security realm.

|groups-to-roles |The groups-to-roles mapper is a simple-role-decoder
that will decode the groups information of a principal and use it for
the role information.

|super-user-mapper |The super-user-mapper mapper is a constant role
mapper that maps the SuperUser role to a principal.

|management-http-authentication |The management-http-authentication
http-authentication-factory can be used for doing authentication over
http. It uses the global provider-http-server-mechanism-factory to
filter authentication mechanism and uses ManagementDomain for
authenticating principals. It accepts the DIGEST authentication
mechanisms and exposes it as ManagementRealm to applications.

|application-http-authentication |The application-http-authentication
http-authentication-factory can be used for doing authentication over
http. It uses the global provider-http-server-mechanism-factory to
filter authentication mechanism and uses ApplicationDomain for
authenticating principals. It accepts BASIC and FORM authentication
mechanisms and exposes BASIC as Application Realm to applications.

|global (provider-http-server-mechanism-factory) |This is the HTTP
server factory mechanism definition used to list the provided
authentication mechanisms when creating an http authentication factory.

|management-sasl-authentication |The management-sasl-authentication
sasl-authentication-factory can be used for authentication using SASL.
It uses the configured sasl-server-factory to filter authentication
mechanisms, which also uses the global provider-sasl-server-factory to
filter by provider names. management-sasl-authentication uses the
ManagementDomain security domain for authentication of principals. It
also maps authentication using JBOSS-LOCAL-USER mechanisms using the
local realm mapper and authentication using DIGEST-MD5 to
ManagementRealm.

|application-sasl-authentication |The application-sasl-authentication
sasl-authentication-factory can be used for authentication using SASL.
It uses the configured sasl-server-factory to filter authentication
mechanisms, which also uses the global provider-sasl-server-factory to
filter by provider names. application-sasl-authentication uses the
ApplicationDomain security domain for authentication of principals.

|global (provider-sasl-server-factory) |This is the SASL server factory
definition used to create SASL authentication factories.

|elytron (mechanism-provider-filtering-sasl-server-factor) |This is used
to filter which sasl-authentication-factory is used based on the
provider. In this case, elytron will match on the WildFlyElytron
provider name.

|configured (configurable-sasl-server-factory) |This is used to filter
sasl-authentication-factory is used based on the mechanism name. In this
case, configured will match on JBOSS-LOCAL-USER and DIGEST-MD5. It also
sets the wildfly.sasl.local-user.default-user to $local.

|combined-providers |Is an aggregate provider that aggreates the elytron
and openssl provider loaders.

|elytron |A provider loader

|openssl |A provider loader
|=======================================================================

*Default WildFly Configuration*

[source, java]
----
/subsystem=elytron:read-resource(recursive=true)
{
    "outcome" => "success",
    "result" => {
        "default-authentication-context" => undefined,
        "final-providers" => undefined,
        "initial-providers" => "combined-providers",
        "add-prefix-role-mapper" => undefined,
        "add-suffix-role-mapper" => undefined,
        "aggregate-http-server-mechanism-factory" => undefined,
        "aggregate-principal-decoder" => undefined,
        "aggregate-principal-transformer" => undefined,
        "aggregate-providers" => {"combined-providers" => {"providers" => [
            "elytron",
            "openssl"
        ]}},
        "aggregate-realm" => undefined,
        "aggregate-role-mapper" => undefined,
        "aggregate-sasl-server-factory" => undefined,
        "authentication-configuration" => undefined,
        "authentication-context" => undefined,
        "caching-realm" => undefined,
        "chained-principal-transformer" => undefined,
        "client-ssl-context" => undefined,
        "concatenating-principal-decoder" => undefined,
        "configurable-http-server-mechanism-factory" => undefined,
        "configurable-sasl-server-factory" => {"configured" => {
            "filters" => [
                {"pattern-filter" => "JBOSS-LOCAL-USER"},
                {"pattern-filter" => "DIGEST-MD5"}
            ],
            "properties" => {"wildfly.sasl.local-user.default-user" => "$local"},
            "protocol" => undefined,
            "sasl-server-factory" => "elytron",
            "server-name" => undefined
        }},
        "constant-permission-mapper" => {"default-permission-mapper" => {"permissions" => [
            {"class-name" => "org.wildfly.security.auth.permission.LoginPermission"},
            {
                "class-name" => "org.wildfly.extension.batch.jberet.deployment.BatchPermission",
                "module" => "org.wildfly.extension.batch.jberet",
                "target-name" => "*"
            }
        ]}},
        "constant-principal-decoder" => undefined,
        "constant-principal-transformer" => undefined,
        "constant-realm-mapper" => {"local" => {"realm-name" => "local"}},
        "constant-role-mapper" => {"super-user-mapper" => {"roles" => ["SuperUser"]}},
        "credential-store" => undefined,
        "custom-credential-security-factory" => undefined,
        "custom-modifiable-realm" => undefined,
        "custom-permission-mapper" => undefined,
        "custom-principal-decoder" => undefined,
        "custom-principal-transformer" => undefined,
        "custom-realm" => undefined,
        "custom-realm-mapper" => undefined,
        "custom-role-decoder" => undefined,
        "custom-role-mapper" => undefined,
        "dir-context" => undefined,
        "filesystem-realm" => undefined,
        "filtering-key-store" => undefined,
        "http-authentication-factory" => {
            "management-http-authentication" => {
                "http-server-mechanism-factory" => "global",
                "mechanism-configurations" => [{
                    "mechanism-name" => "DIGEST",
                    "mechanism-realm-configurations" => [{"realm-name" => "ManagementRealm"}]
                }],
                "security-domain" => "ManagementDomain"
            },
            "application-http-authentication" => {
                "http-server-mechanism-factory" => "global",
                "mechanism-configurations" => [
                    {
                        "mechanism-name" => "BASIC",
                        "mechanism-realm-configurations" => [{"realm-name" => "Application Realm"}]
                    },
                    {"mechanism-name" => "FORM"}
                ],
                "security-domain" => "ApplicationDomain"
            }
        },
        "identity-realm" => {"local" => {
            "attribute-name" => undefined,
            "attribute-values" => undefined,
            "identity" => "$local"
        }},
        "jdbc-realm" => undefined,
        "kerberos-security-factory" => undefined,
        "key-managers" => undefined,
        "key-store" => undefined,
        "key-store-realm" => undefined,
        "ldap-key-store" => undefined,
        "ldap-realm" => undefined,
        "logical-permission-mapper" => undefined,
        "logical-role-mapper" => undefined,
        "mapped-regex-realm-mapper" => undefined,
        "mechanism-provider-filtering-sasl-server-factory" => {"elytron" => {
            "enabling" => true,
            "filters" => [{"provider-name" => "WildFlyElytron"}],
            "sasl-server-factory" => "global"
        }},
        "properties-realm" => {
            "ApplicationRealm" => {
                "groups-attribute" => "groups",
                "groups-properties" => {
                    "path" => "application-roles.properties",
                    "relative-to" => "jboss.server.config.dir"
                },
                "users-properties" => {
                    "path" => "application-users.properties",
                    "relative-to" => "jboss.server.config.dir",
                    "digest-realm-name" => "ApplicationRealm"
                }
            },
            "ManagementRealm" => {
                "groups-attribute" => "groups",
                "groups-properties" => {
                    "path" => "mgmt-groups.properties",
                    "relative-to" => "jboss.server.config.dir"
                },
                "users-properties" => {
                    "path" => "mgmt-users.properties",
                    "relative-to" => "jboss.server.config.dir",
                    "digest-realm-name" => "ManagementRealm"
                }
            }
        },
        "provider-http-server-mechanism-factory" => {"global" => {"providers" => undefined}},
        "provider-loader" => {
            "elytron" => {
                "class-names" => undefined,
                "configuration" => undefined,
                "module" => "org.wildfly.security.elytron",
                "path" => undefined,
                "relative-to" => undefined
            },
            "openssl" => {
                "class-names" => undefined,
                "configuration" => undefined,
                "module" => "org.wildfly.openssl",
                "path" => undefined,
                "relative-to" => undefined
            }
        },
        "provider-sasl-server-factory" => {"global" => {"providers" => undefined}},
        "regex-principal-transformer" => undefined,
        "regex-validating-principal-transformer" => undefined,
        "sasl-authentication-factory" => {
            "management-sasl-authentication" => {
                "mechanism-configurations" => [
                    {
                        "mechanism-name" => "JBOSS-LOCAL-USER",
                        "realm-mapper" => "local"
                    },
                    {
                        "mechanism-name" => "DIGEST-MD5",
                        "mechanism-realm-configurations" => [{"realm-name" => "ManagementRealm"}]
                    }
                ],
                "sasl-server-factory" => "configured",
                "security-domain" => "ManagementDomain"
            },
            "application-sasl-authentication" => {
                "mechanism-configurations" => undefined,
                "sasl-server-factory" => "configured",
                "security-domain" => "ApplicationDomain"
            }
        },
        "security-domain" => {
            "ApplicationDomain" => {
                "default-realm" => "ApplicationRealm",
                "permission-mapper" => "default-permission-mapper",
                "post-realm-principal-transformer" => undefined,
                "pre-realm-principal-transformer" => undefined,
                "principal-decoder" => undefined,
                "realm-mapper" => undefined,
                "realms" => [{
                    "realm" => "ApplicationRealm",
                    "role-decoder" => "groups-to-roles"
                }],
                "role-mapper" => undefined,
                "trusted-security-domains" => undefined
            },
            "ManagementDomain" => {
                "default-realm" => "ManagementRealm",
                "permission-mapper" => "default-permission-mapper",
                "post-realm-principal-transformer" => undefined,
                "pre-realm-principal-transformer" => undefined,
                "principal-decoder" => undefined,
                "realm-mapper" => undefined,
                "realms" => [
                    {
                        "realm" => "ManagementRealm",
                        "role-decoder" => "groups-to-roles"
                    },
                    {
                        "realm" => "local",
                        "role-mapper" => "super-user-mapper"
                    }
                ],
                "role-mapper" => undefined,
                "trusted-security-domains" => undefined
            }
        },
        "security-property" => undefined,
        "server-ssl-context" => undefined,
        "service-loader-http-server-mechanism-factory" => undefined,
        "service-loader-sasl-server-factory" => undefined,
        "simple-permission-mapper" => undefined,
        "simple-regex-realm-mapper" => undefined,
        "simple-role-decoder" => {"groups-to-roles" => {"attribute" => "groups"}},
        "token-realm" => undefined,
        "trust-managers" => undefined,
        "x500-attribute-principal-decoder" => undefined
    }
}
----

[[default-application-authentication-configuration]]
== Default Application Authentication Configuration

By default, applications are secured using legacy security domains.
Applications must specify a security domain in their _web.xml_ as well
as the authentication method. If no security domain is specified by the
application, WildFly will use the provided _other_ legacy security
domain.

[[update-wildfly-to-use-the-default-elytron-components-for-application-authentication]]
=== Update WildFly to Use the Default Elytron Components for Application
Authentication

[source, java]
----
/subsystem=undertow/application-security-domain=exampleApplicationDomain:add(http-authentication-factory=application-http-authentication)
----

[[default-elytron-application-http-authentication-configuration]]
=== Default Elytron Application HTTP Authentication Configuration

By default, the _application-http-authentication_
http-authentication-factory is provided for application http
authentication.

[source, java]
----
/subsystem=elytron/http-authentication-factory=application-http-authentication:read-resource()
{
    "outcome" => "success",
    "result" => {
        "http-server-mechanism-factory" => "global",
        "mechanism-configurations" => [
            {
                "mechanism-name" => "BASIC",
                "mechanism-realm-configurations" => [{"realm-name" => "Application Realm"}]
            },
            {"mechanism-name" => "FORM"}
        ],
        "security-domain" => "ApplicationDomain"
    }
}
----

The _application-http-authentication_ http-authentication-factory is
configured to use the _ApplicationDomain_ security domain.

[source, java]
----
/subsystem=elytron/security-domain=ApplicationDomain:read-resource()
{
    "outcome" => "success",
    "result" => {
        "default-realm" => "ApplicationRealm",
        "permission-mapper" => "default-permission-mapper",
        "post-realm-principal-transformer" => undefined,
        "pre-realm-principal-transformer" => undefined,
        "principal-decoder" => undefined,
        "realm-mapper" => undefined,
        "realms" => [{
            "realm" => "ApplicationRealm",
            "role-decoder" => "groups-to-roles"
        }],
        "role-mapper" => undefined,
        "trusted-security-domains" => undefined
    }
}
----

The _ApplicationDomain_ security domain is backed by the
_ApplicationRealm_ Elytron security realm, which is a properties-based
realm.

[source, java]
----
/subsystem=elytron/properties-realm=ApplicationRealm:read-resource()
{
    "outcome" => "success",
    "result" => {
        "groups-attribute" => "groups",
        "groups-properties" => {
            "path" => "application-roles.properties",
            "relative-to" => "jboss.server.config.dir"
        },
        "users-properties" => {
            "path" => "application-users.properties",
            "relative-to" => "jboss.server.config.dir",
            "digest-realm-name" => "ApplicationRealm"
        }
    }
}
----

[[default-management-authentication-configuration]]
== Default Management Authentication Configuration

By default, the WildFly management interfaces are secured by the legacy
core management authentication.

*Default Configuration*

[source, java]
----
/core-service=management/management-interface=http-interface:read-resource()
{
    "outcome" => "success",
    "result" => {
        "allowed-origins" => undefined,
        "console-enabled" => true,
        "http-authentication-factory" => undefined,
        "http-upgrade" => {"enabled" => true},
        "http-upgrade-enabled" => true,
        "sasl-protocol" => "remote",
        "secure-socket-binding" => undefined,
        "security-realm" => "ManagementRealm",
        "server-name" => undefined,
        "socket-binding" => "management-http",
        "ssl-context" => undefined
    }
----

WildFly does provide _management-http-authentication_ and
_management-sasl-authentication_ in the _elytron_ subsystem for securing
the management interfaces as well.

[[update-wildfly-to-use-the-default-elytron-components-for-management-authentication]]
=== Update WildFly to Use the Default Elytron Components for Management
Authentication

[[set-http-authentication-factory-to-use-management-http-authentication]]
==== Set http-authentication-factory to use
management-http-authentication

[source, java]
----
/core-service=management/management-interface=http-interface:write-attribute( \
  name=http-authentication-factory, \
  value=management-http-authentication \
)
----

[[set-sasl-authentication-factory-to-use-management-sasl-authentication]]
==== Set sasl-authentication-factory to use
management-sasl-authentication

[source, java]
----
/core-service=management/management-interface=http-interface:write-attribute( \
  name=http-upgrade.sasl-authentication-factory, \
  value=management-sasl-authentication \
)
----

[[undefine-security-realm]]
==== Undefine security-realm

[source, java]
----
/core-service=management/management-interface=http-interface:undefine-attribute(name=security-realm)
----

[[reload-wildfly-for-the-changes-to-take-affect.]]
==== Reload WildFly for the changes to take affect.

[source, java]
----
reload
----

The management interfaces are now secured using the default components
provided by the 'elytron' subsystem.

[[default-elytron-management-http-authentication-configuration]]
=== Default Elytron Management HTTP Authentication Configuration

When you access the management interface over HTTP, for example when
using the web-based management console, WildFly will use the
_management-http-authentication_ http-authentication-factory.

[source, java]
----
/subsystem=elytron/http-authentication-factory=management-http-authentication:read-resource()
{
    "outcome" => "success",
    "result" => {
        "http-server-mechanism-factory" => "global",
        "mechanism-configurations" => [{
            "mechanism-name" => "DIGEST",
            "mechanism-realm-configurations" => [{"realm-name" => "ManagementRealm"}]
        }],
        "security-domain" => "ManagementDomain"
    }
}
----

The _management-http-authentication_ http-authentication-factory, is
configured to use the _ManagementDomain_ security domain.

[source, java]
----
/subsystem=elytron/security-domain=ManagementDomain:read-resource()
{
    "outcome" => "success",
    "result" => {
        "default-realm" => "ManagementRealm",
        "permission-mapper" => "default-permission-mapper",
        "post-realm-principal-transformer" => undefined,
        "pre-realm-principal-transformer" => undefined,
        "principal-decoder" => undefined,
        "realm-mapper" => undefined,
        "realms" => [
            {
                "realm" => "ManagementRealm",
                "role-decoder" => "groups-to-roles"
            },
            {
                "realm" => "local",
                "role-mapper" => "super-user-mapper"
            }
        ],
        "role-mapper" => undefined,
        "trusted-security-domains" => undefined
    }
}
----

The _ManagementDomain_ security domain is backed by the
_ManagementRealm_ Elytron security realm, which is a properties-based
realm.

[source, java]
----
/subsystem=elytron/properties-realm=ManagementRealm:read-resource()
{
    "outcome" => "success",
    "result" => {
        "groups-attribute" => "groups",
        "groups-properties" => {
            "path" => "mgmt-groups.properties",
            "relative-to" => "jboss.server.config.dir"
        },
        "plain-text" => false,
        "users-properties" => {
            "path" => "mgmt-users.properties",
            "relative-to" => "jboss.server.config.dir"
        }
    }
}
----

[[default-elytron-management-cli-authentication]]
=== Default Elytron Management CLI Authentication

By default, the management CLI ( _jboss-cli.sh_) is configured to
connect over _remotehttp_.

*Default jboss-cli.xml*

[source, java]
----
<jboss-cli xmlns="urn:jboss:cli:3.1">
 
    <default-protocol use-legacy-override="true">remotehttp</default-protocol>
 
    <!-- The default controller to connect to when 'connect' command is executed w/o arguments -->
    <default-controller>
        <protocol>remotehttp</protocol>
        <host>localhost</host>
        <port>9990</port>
    </default-controller>
----

This will establish a connection over HTTP and use HTTP upgrade to
change the communication protocol to _native_. The HTTP upgrade
connection is secured in the _http-upgrade_ section of the
_http-interface_ using a _sasl-authentication-factory_.

*Example Configuration with Default Components*

[source, java]
----
/core-service=management/management-interface=http-interface:read-resource()
{
    "outcome" => "success",
    "result" => {
        "allowed-origins" => undefined,
        "console-enabled" => true,
        "http-authentication-factory" => "management-http-authentication",
        "http-upgrade" => {
            "enabled" => true,
            "sasl-authentication-factory" => "management-sasl-authentication"
        },
        "http-upgrade-enabled" => true,
        "sasl-protocol" => "remote",
        "secure-socket-binding" => undefined,
        "security-realm" => undefined,
        "server-name" => undefined,
        "socket-binding" => "management-http",
        "ssl-context" => undefined
    }
}
----

The default sasl-authentication-factory is
_management-sasl-authentication_.

[source, java]
----
/subsystem=elytron/sasl-authentication-factory=management-sasl-authentication:read-resource()
{
    "outcome" => "success",
    "result" => {
        "mechanism-configurations" => [
            {
                "mechanism-name" => "JBOSS-LOCAL-USER",
                "realm-mapper" => "local"
            },
            {
                "mechanism-name" => "DIGEST-MD5",
                "mechanism-realm-configurations" => [{"realm-name" => "ManagementRealm"}]
            }
        ],
        "sasl-server-factory" => "configured",
        "security-domain" => "ManagementDomain"
    }
}
----

The _management-sasl-authentication_ sasl-authentication-factory
specifies _JBOSS-LOCAL-USER_ and _DIGEST-MD5_ mechanisms.

*JBOSS-LOCAL-USER Realm*

[source, java]
----
/subsystem=elytron/identity-realm=local:read-resource()
{
    "outcome" => "success",
    "result" => {
        "attribute-name" => undefined,
        "attribute-values" => undefined,
        "identity" => "$local"
    }
}
----

The _local_ Elytron security realm is for handling silent authentication
for local users.

The _ManagementRealm_ Elytron security realm is the same realm used in
the _management-http-authentication_ http-authentication-factory.

[[comparing-legacy-approaches-to-elytron-approaches]]
== Comparing Legacy Approaches to Elytron Approaches

[cols=",",]
|=======================================================================
|Legacy Approach |Elytron Approach

|UsersRoles Login Module |Configure Authentication with a Properties
File-Based Identity Store

|Database Login Module |Configure Authentication with a Database
Identity Store

|Ldap, LdapExtended, AdvancedLdap, AdvancedADLdap Login Modules
|Configure Authentication with an LDAP-Based Identity Store

|Certificate, Certificate Roles Login Module |Configure Authentication
with Certificates

|Kerberos, SPNEGO Login Modules |Configure Authentication with a
Kerberos-Based Identity Store

|Kerberos, SPNEGO Login Modules with Fallback |Configure Authentication
with a Form as a Fallback for Kerberos

|Vault |Create and Use a Credential Store

|Legacy Security Realms |Secure the Management Interfaces with a New
Identity Store, Silent Authentication

|RBAC |Using RBAC with Elytron

|Legacy Security Realms for One-way and Two-way SSL/TLS for Applications
|Enable One-way SSL/TLS for Applications, Enable Two-way SSL/TLS in
WildFly for Applications

|Legacy Security Realms for One-way and Two-way SSL/TLS for Management
Interfaces |Enable One-way for the Management Interfaces Using the
Elytron Subsystem, Enable Two-way SSL/TLS for the Management Interfaces
using the Elytron Subsystem
|=======================================================================

[[using-the-elytron-subsystem]]
= Using the Elytron Subsystem

[[set-up-and-configure-authentication-for-applications]]
== Set Up and Configure Authentication for Applications

[[configure-authentication-with-a-properties-file-based-identity-store]]
=== Configure Authentication with a Properties File-Based Identity Store

[[create-properties-files]]
==== Create properties files:

You need to create two properties files: one that maps user to passwords
and another that maps users to roles. Usually these files are located in
the _jboss.server.config.dir_ directory and follow the naming convention
_*-users.properties_ and _*-roles.properties_, but other locations and
names may be used. The _*-users.properties_ file must also contain a
reference to the _properties-realm_, which you will create in the next
step: _#$REALM_NAME=YOUR_PROPERTIES_REALM_NAME$_

*Example user to password file: example-users.properties*

[source, java]
----
#$REALM_NAME=examplePropRealm$
user1=password123
user2=password123
----

*Example user to roles file: example-roles.properties*

[source, java]
----
user1=Admin
user2=Guest
----

[[configure-a-properties-realm-in-wildfly]]
==== Configure a properties-realm in WildFly:

[source, java]
----
/subsystem=elytron/properties-realm=examplePropRealm:add(groups-attribute=groups,groups-properties={path=example-roles.properties,relative-to=jboss.server.config.dir},users-properties={path=example-users.properties,relative-to=jboss.server.config.dir,plain-text=true})
----

The name of the _properties-realm_ is _examplePropRealm_, which is used
in the previous step in the _example-users.properties_ file. Also, if
your properties files are located outside of _jboss.server.config.dir_,
then you need to change the _path_ and _relative-to_ values
appropriately.

[[configure-a-security-domain]]
==== Configure a security-domain:

[source, java]
----
/subsystem=elytron/security-domain=exampleSD:add(realms=[{realm=examplePropRealm,role-decoder=groups-to-roles}],default-realm=examplePropRealm,permission-mapper=default-permission-mapper)
----

[[configure-an-http-authentication-factory]]
==== Configure an http-authentication-factory:

[source, java]
----
/subsystem=elytron/http-authentication-factory=example-http-auth:add(http-server-mechanism-factory=global,security-domain=exampleSD,mechanism-configurations=[{mechanism-name=BASIC,mechanism-realm-configurations=[{realm-name=exampleApplicationDomain}]}])
----

This example shows creating an _http-authentication-factory_ using
_BASIC_ authentication, but it could be updated to other mechanisms such
as _FORM_.

[[configure-an-application-security-domain-in-the-undertow-subsystem]]
==== Configure an application-security-domain in the Undertow subsystem:

[source, java]
----
/subsystem=undertow/application-security-domain=exampleApplicationDomain:add(http-authentication-factory=example-http-auth)
----

[[configure-your-applications-web.xml-and-jboss-web.xml.]]
==== Configure your application's web.xml and jboss-web.xml.

Your application's _web.xml_ and _jboss-web.xml_ must be updated to use
the _application-security-domain_ you configured in WildFly. An example
of this is available in the
link:#src-557133_WildFlyElytronSecurity-config-app-auth[Configure
Applications to Use Elytron or Legacy Security for Authentication]
section.

[[configure-authentication-with-a-filesystem-based-identity-store]]
=== Configure Authentication with a Filesystem-Based Identity Store

[[chose-a-directory-for-users]]
==== Chose a directory for users:

You need a directory where your users will be stored. In this example,
we are using a directory called _fs-realm-users_ located in
_jboss.server.config.dir_.

[[configure-a-filesystem-realm-in-wildfly]]
==== Configure a filesystem-realm in WildFly:

[source, java]
----
/subsystem=elytron/filesystem-realm=exampleFsRealm:add(path=fs-realm-users,relative-to=jboss.server.config.dir)
----

If your directory is located outside of _jboss.server.config.dir_, then
you need to change the _path_ and _relative-to_ values appropriately.

[[add-a-user]]
==== Add a user:

When using the _filesystem-realm_, you can add users using the
management CLI.

[source, java]
----
/subsystem=elytron/filesystem-realm=exampleFsRealm/identity=user1:add()
/subsystem=elytron/filesystem-realm=exampleFsRealm/identity=user1:set-password( clear={password="password123"})
/subsystem=elytron/filesystem-realm=exampleFsRealm/identity=user1:add-attribute(name=Roles, value=["Admin","Guest"])
----

[[add-a-simple-role-decoder]]
==== Add a simple-role-decoder:

[source, java]
----
/subsystem=elytron/simple-role-decoder=from-roles-attribute:add(attribute=Roles)
----

This _simple-role-decoder_ decodes a principal's roles from the _Roles_
attribute. You can change this value if your roles are in a different
attribute.

[[configure-a-security-domain-1]]
==== Configure a security-domain:

[source, java]
----
/subsystem=elytron/security-domain=exampleFsSD:add(realms=[{realm=exampleFsRealm,role-decoder=from-roles-attribute}],default-realm=exampleFsRealm,permission-mapper=default-permission-mapper)
----

[[configure-an-http-authentication-factory-1]]
==== Configure an http-authentication-factory:

[source, java]
----
/subsystem=elytron/http-authentication-factory=example-fs-http-auth:add(http-server-mechanism-factory=global,security-domain=exampleFsSD,mechanism-configurations=[{mechanism-name=BASIC,mechanism-realm-configurations=[{realm-name=exampleApplicationDomain}]}])
----

This example shows creating an _http-authentication-factory_ using
_BASIC_ authentication, but it could be updated to other mechanisms such
as _FORM_.

[[configure-an-application-security-domain-in-the-undertow-subsystem-1]]
==== Configure an application-security-domain in the Undertow subsystem:

[source, java]
----
/subsystem=undertow/application-security-domain=exampleApplicationDomain:add(http-authentication-factory=example-fs-http-auth)
----

[[configure-your-applications-web.xml-and-jboss-web.xml.-1]]
==== Configure your application's web.xml and jboss-web.xml.

Your application's _web.xml_ and _jboss-web.xml_ must be updated to use
the _application-security-domain_ you configured in WildFly. An example
of this is available in the
link:#src-557133_WildFlyElytronSecurity-config-app-auth[Configure
Applications to Use Elytron or Legacy Security for Authentication]
section.

Your application is now using a filesystem-based identity store for
authentication.

[[configure-authentication-with-a-database-identity-store]]
=== Configure Authentication with a Database Identity Store

[[determine-your-database-format-for-usernames-passwords-and-roles]]
==== Determine your database format for usernames, passwords, and roles:

To set up authentication using a database for an identity store, you
need to determine how your usernames, passwords, and roles are stored in
that database. In this example, we are using a single table with the
following sample data:

[cols=",,",]
|=========================
|username |password |roles
|user1 |password123 |Admin
|user2 |password123 |Guest
|=========================

[[configure-a-datasource]]
==== Configure a datasource:

To connect to a database from WildFly, you must have the appropriate
database driver deployed as well as a datasource configured. This
example shows deploying the driver for postgres and configuring a
datasource in WildFly:

[source, java]
----
deploy /path/to/postgresql-9.4.1210.jar
 
data-source add --name=examplePostgresDS --jndi-name=java:jboss/examplePostgresDS --driver-name=postgresql-9.4.1210.jar  --connection-url=jdbc:postgresql://localhost:5432/postgresdb --user-name=postgresAdmin --password=mysecretpassword
----

[[configure-a-jdbc-realm-in-wildfly]]
==== Configure a jdbc-realm in WildFly:

[source, java]
----
/subsystem=elytron/jdbc-realm=exampleDbRealm:add(principal-query=[{sql="SELECT password,roles FROM wildfly_users WHERE username=?",data-source=examplePostgresDS,clear-password-mapper={password-index=1},attribute-mapping=[{index=2,to=groups}]}])
----

*NOTE:* The above example shows how to obtain passwords and roles from a
single _principal-query_. You can also create additional
_principal-query_ with _attribute-mapping_ attributes if you require
multiple queries to obtain roles or additional authentication or
authorization information.

[[configure-a-security-domain-2]]
==== Configure a security-domain:

[source, java]
----
/subsystem=elytron/security-domain=exampleDbSD:add(realms=[{realm=exampleDbRealm,role-decoder=groups-to-roles}],default-realm=exampleDbRealm,permission-mapper=default-permission-mapper)
----

[[configure-an-http-authentication-factory-2]]
==== Configure an http-authentication-factory:

[source, java]
----
/subsystem=elytron/http-authentication-factory=example-db-http-auth:add(http-server-mechanism-factory=global,security-domain=exampleDbSD,mechanism-configurations=[{mechanism-name=BASIC,mechanism-realm-configurations=[{realm-name=exampleDbSD}]}])
----

This example shows creating an _http-authentication-factory_ using
_BASIC_ authentication, but it could be updated to other mechanisms such
as _FORM_.

[[configure-an-application-security-domain-in-the-undertow-subsystem-2]]
==== Configure an application-security-domain in the Undertow subsystem:

[source, java]
----
/subsystem=undertow/application-security-domain=exampleApplicationDomain:add(http-authentication-factory=example-db-http-auth)
----

[[configure-your-applications-web.xml-and-jboss-web.xml.-2]]
==== Configure your application's web.xml and jboss-web.xml.

Your application's _web.xml_ and _jboss-web.xml_ must be updated to use
the _application-security-domain_ you configured in WildFly. An example
of this is available in the
link:#src-557133_WildFlyElytronSecurity-config-app-auth[Configure
Applications to Use Elytron or Legacy Security for Authentication]
section.

[[configure-authentication-with-an-ldap-based-identity-store]]
=== Configure Authentication with an LDAP-Based Identity Store

[[determine-your-ldap-format-for-usernames-passwords-and-roles]]
==== Determine your LDAP format for usernames, passwords, and roles:

To set up authentication using an LDAP server for an identity store, you
need to determine how your usernames, passwords, and roles are stored.
In this example, we are using the following structure:

[source, java]
----
dn: dc=wildfly,dc=org
dc: wildfly
objectClass: top
objectClass: domain
 
dn: ou=Users,dc=wildfly,dc=org
objectClass: organizationalUnit
objectClass: top
ou: Users
 
dn: uid=jsmith,ou=Users,dc=wildfly,dc=org
objectClass: top
objectClass: person
objectClass: inetOrgPerson
cn: John Smith
sn: smith
uid: jsmith
userPassword: password123
 
dn: ou=Roles,dc=wildfly,dc=org
objectclass: top
objectclass: organizationalUnit
ou: Roles
 
dn: cn=Admin,ou=Roles,dc=wildfly,dc=org
objectClass: top
objectClass: groupOfNames
cn: Admin
member: uid=jsmith,ou=Users,dc=wildfly,dc=org
----

[[configure-a-dir-context]]
==== Configure a dir-context:

To connect to the LDAP server from WildFly, you need to configure a
_dir-context_ that provides the URL as well as the principal used to
connect to the server.

[source, java]
----
/subsystem=elytron/dir-context=exampleDC:add(url="ldap://127.0.0.1:10389",principal="uid=admin,ou=system",credential-reference={clear-text="secret"})
----

[[configure-an-ldap-realm-in-wildfly]]
==== Configure an ldap-realm in WildFly:

[source, java]
----
/subsystem=elytron/ldap-realm=exampleLR:add(dir-context=exampleDC,identity-mapping={search-base-dn="ou=Users,dc=wildfly,dc=org",rdn-identifier="uid",user-password-mapper={from="userPassword"},attribute-mapping=[{filter-base-dn="ou=Roles,dc=wildfly,dc=org",filter="(&(objectClass=groupOfNames)(member={1}))",from="cn",to="Roles"}]})
----

[[add-a-simple-role-decoder-1]]
==== Add a simple-role-decoder:

[source, java]
----
/subsystem=elytron/simple-role-decoder=from-roles-attribute:add(attribute=Roles)
----

[[configure-a-security-domain-3]]
==== Configure a security-domain:

[source, java]
----
/subsystem=elytron/security-domain=exampleLdapSD:add(realms=[{realm=exampleLR,role-decoder=from-roles-attribute}],default-realm=exampleLR,permission-mapper=default-permission-mapper)
----

[[configure-an-http-authentication-factory-3]]
==== Configure an http-authentication-factory:

[source, java]
----
/subsystem=elytron/http-authentication-factory=example-ldap-http-auth:add(http-server-mechanism-factory=global,security-domain=exampleLdapSD,mechanism-configurations=[{mechanism-name=BASIC,mechanism-realm-configurations=[{realm-name=exampleApplicationDomain}]}])
----

This example shows creating an _http-authentication-factory_ using
_BASIC_ authentication, but it could be updated to other mechanisms such
as _FORM_.

[[configure-an-application-security-domain-in-the-undertow-subsystem-3]]
==== Configure an application-security-domain in the Undertow subsystem:

[source, java]
----
/subsystem=undertow/application-security-domain=exampleApplicationDomain:add(http-authentication-factory=example-ldap-http-auth)
----

[[configure-your-applications-web.xml-and-jboss-web.xml.-3]]
==== Configure your application's web.xml and jboss-web.xml.

Your application's _web.xml_ and _jboss-web.xml_ must be updated to use
the _application-security-domain_ you configured in WildFly. An example
of this is available in the
link:#src-557133_WildFlyElytronSecurity-config-app-auth[Configure
Applications to Use Elytron or Legacy Security for Authentication]
section.

*IMPORTANT:* In cases where you configure an LDAP server in the
_elytron_ subsystem for authentication and that LDAP server then becomes
unreachable, WildFly will return a _500_, or internal server error,
error code when attempting authentication using that unreachable LDAP
server. This behavior differs from the legacy _security_ subsystem,
which will return a _401_, or unauthorized, error code under the same
conditions.

[[configure-authentication-with-certificates]]
=== Configure Authentication with Certificates

*IMPORTANT:* Before you can set up certificate-based authentication, you
must have two-way SSL configured.

[[configure-a-key-store-realm.]]
==== Configure a key-store-realm.

[source, java]
----
/subsystem=elytron/key-store-realm=ksRealm:add(key-store=twoWayTS)
----

You must configure this realm with a truststore that contains the
client's certificate. The authentication process uses the same
certificate presented by the client during the two-way SSL handshake.

[[create-a-decoder.]]
==== Create a Decoder.

You need to create a _x500-attribute-principal-decoder_ to decode the
principal you get from your certificate. The below example will decode
the principal based on the first _CN_ value.

[source, java]
----
/subsystem=elytron/x500-attribute-principal-decoder=CNDecoder:add(oid="2.5.4.3",maximum-segments=1)
----

For example, if the full _DN_ was
_CN=client,CN=client-certificate,DC=example,DC=jboss,DC=org_,
_CNDecoder_ would decode the principal as _client_. This decoded
principal is used as the _alias_ value to lookup a certificate in the
truststore configured in _ksRealm_.

*IMPORTANT:* The decoded principal * *MUST** must be the _alias_ value
you set in your server's truststore for the client's certificate.

[[add-a-constant-role-mapper-for-assigning-roles.]]
==== Add a constant-role-mapper for assigning roles.

This is example uses a _constant-role-mapper_ to assign roles to a
principal from _ksRealm_ but other approaches may also be used.

[source, java]
----
/subsystem=elytron/constant-role-mapper=constantClientCertRole:add(roles=[Admin,Guest])
----

[[configure-a-security-domain.]]
==== Configure a security-domain.

[source, java]
----
/subsystem=elytron/security-domain=exampleCertSD:add(realms=[{realm=ksRealm}],default-realm=ksRealm,permission-mapper=default-permission-mapper,principal-decoder=CNDecoder,role-mapper=constantClientCertRole)
----

[[configure-an-http-authentication-factory.]]
==== Configure an http-authentication-factory.

[source, java]
----
/subsystem=elytron/http-authentication-factory=exampleCertHttpAuth:add(http-server-mechanism-factory=global,security-domain=exampleCertSD,mechanism-configurations=[{mechanism-name=CLIENT_CERT,mechanism-realm-configurations=[{realm-name=exampleApplicationDomain}]}])
----

[[configure-an-application-security-domain-in-the-undertow-subsystem.]]
==== Configure an application-security-domain in the Undertow subsystem.

[source, java]
----
/subsystem=undertow/application-security-domain=exampleApplicationDomain:add(http-authentication-factory=exampleCertHttpAuth)
----

[[update-server-ssl-context.]]
==== Update server-ssl-context.

[source, java]
----
/subsystem=elytron/server-ssl-context=twoWaySSC:write-attribute(name=security-domain,value=exampleCertSD)
/subsystem=elytron/server-ssl-context=twoWaySSC:write-attribute(name=authentication-optional, value=true)
----

[[configure-your-applications-web.xml-and-jboss-web.xml.-4]]
==== Configure your application's web.xml and jboss-web.xml.

Your application's _web.xml_ and _jboss-web.xml_ must be updated to use
the _application-security-domain_ you configured in WildFly. An example
of this is available in the
link:#src-557133_WildFlyElytronSecurity-config-app-auth[Configure
Applications to Use Elytron or Legacy Security for Authentication]
section.

In addition, you need to update your _web.xml_ to use _CLIENT-CERT_ as
its authentication method.

[source, java]
----
<login-config>
  <auth-method>CLIENT-CERT</auth-method>
  <realm-name>exampleApplicationDomain</realm-name>
</login-config>
----

[[configure-authentication-with-a-kerberos-based-identity-store]]
=== Configure Authentication with a Kerberos-Based Identity Store

*IMPORTANT*: The following steps assume you have a working KDC and
Kerberos domain as well as your client browsers configured.

[[configure-a-kerberos-security-factory.]]
==== Configure a kerberos-security-factory.

[source, java]
----
/subsystem=elytron/kerberos-security-factory=krbSF:add(principal="HTTP/host@REALM",path="/path/to/http.keytab",mechanism-oids=[1.2.840.113554.1.2.2,1.3.6.1.5.5.2])
----

[[configure-the-system-properties-for-kerberos.]]
==== Configure the system properties for Kerberos.

Depending on how your environment is configured, you will need to set
some of the system properties below.

[cols=",",]
|======================================================================
|System Property |Description
|java.security.krb5.kdc |The host name of the KDC.
|java.security.krb5.realm |The name of the realm.
|java.security.krb5.conf |The path to the configuration krb5.conf file.
|sun.security.krb5.debug |If true, debugging mode will be enabled.
|======================================================================

To configure a system property in WildFly:

[source, java]
----
/system-property=java.security.krb5.conf:add(value="/path/to/krb5.conf")
----

[[configure-an-eltyron-security-realm-for-assigning-roles.]]
==== Configure an Eltyron security realm for assigning roles.

The the client's Kerberos token will provide the principal, but you need
a way to map that principal to a role for your application. There are
several ways to accomplish this, but this example creates a
_filesystem-realm_, adds a user to the realm that matches the principal
from the Kerberos token, and assigns roles to that user.

[source, java]
----
/subsystem=elytron/filesystem-realm=exampleFsRealm:add(path=fs-realm-users,relative-to=jboss.server.config.dir)
/subsystem=elytron/filesystem-realm=exampleFsRealm/identity=user1@REALM:add()
/subsystem=elytron/filesystem-realm=exampleFsRealm/identity=user1@REALM:add-attribute(name=Roles, value=["Admin","Guest"])
----

[[add-a-simple-role-decoder.]]
==== Add a simple-role-decoder.

[source, java]
----
/subsystem=elytron/simple-role-decoder=from-roles-attribute:add(attribute=Roles)
----

This _simple-role-decoder_ decodes a principal's roles from the _Roles_
attribute. You can change this value if your roles are in a different
attribute.

[[configure-a-security-domain.-1]]
==== Configure a security-domain.

[source, java]
----
/subsystem=elytron/security-domain=exampleFsSD:add(realms=[{realm=exampleFsRealm,role-decoder=from-roles-attribute}],default-realm=exampleFsRealm,permission-mapper=default-permission-mapper)
----

[[configure-an-http-authentication-factory-that-uses-the-kerberos-security-factory.]]
==== Configure an http-authentication-factory that uses the
kerberos-security-factory.

[source, java]
----
/subsystem=elytron/http-authentication-factory=example-krb-http-auth:add(http-server-mechanism-factory=global,security-domain=exampleFsSD,mechanism-configurations=[{mechanism-name=SPNEGO,mechanism-realm-configurations=[{realm-name=exampleFsSD}],credential-security-factory=krbSF}])
----

[[configure-an-application-security-domain-in-the-undertow-subsystem-4]]
==== Configure an application-security-domain in the Undertow subsystem:

[source, java]
----
/subsystem=undertow/application-security-domain=exampleApplicationDomain:add(http-authentication-factory=example-krb-http-auth)
----

[[configure-your-applications-web.xml-jboss-web.xml-and-jboss-deployment-structure.xml.]]
==== Configure your application's web.xml, jboss-web.xml and
jboss-deployment-structure.xml.

Your application's _web.xml_ and _jboss-web.xml_ must be updated to use
the _application-security-domain_ you configured in WildFly. An example
of this is available in the
link:#src-557133_WildFlyElytronSecurity-config-app-auth[Configure
Applications to Use Elytron or Legacy Security for Authentication]
section.

In addition, you need to update your _web.xml_ to use _SPNEGO_ as its
authentication method.

[source, java]
----
<login-config>
  <auth-method>SPNEGO</auth-method>
  <realm-name>exampleApplicationDomain</realm-name>
</login-config>
----

[[configure-authentication-with-a-form-as-a-fallback-for-kerberos]]
=== Configure Authentication with a Form as a Fallback for Kerberos

[[configure-kerberos-based-authentication.]]
==== Configure kerberos-based authentication.

Configuring kerberos-based authentication is covered in a previous
section.

[[add-a-mechanism-for-form-authentication-in-the-http-authentication-factory.]]
==== Add a mechanism for FORM authentication in the
http-authentication-factory.

You can use the existing _http-authentication-factory_ you configured
for kerberos-based authentication and and an additional mechanism for
_FORM_ authentication.

[source, java]
----
/subsystem=elytron/http-authentication-factory=example-krb-http-auth:list-add(name=mechanism-configurations, value={mechanism-name=FORM})
----

[[add-additional-fallback-principals.]]
==== Add additional fallback principals.

The existing configuration for kerberos-based authentication should
already have a security realm configured for mapping principals from
kerberos token to roles for the application. You can add additional
users for fallback authentication to that realm. For example if you used
a _filesystem-realm_, you can simply create a new user with the
appropriate roles:

[source, java]
----
/subsystem=elytron/filesystem-realm=exampleFsRealm/identity=fallbackUser1:add()
/subsystem=elytron/filesystem-realm=exampleFsRealm/identity=fallbackUser1:set-password(clear={password="password123"})
/subsystem=elytron/filesystem-realm=exampleFsRealm/identity=fallbackUser1:add-attribute(name=Roles, value=["Admin","Guest"])
----

[[update-the-web.xml-for-form-fallback.]]
==== Update the web.xml for FORM fallback.

You need to update the _web.xml_ to use the value _SPNEGO,FORM_ for the
_auth-method_, which will use _FORM_ as a fallback authentication method
if _SPNEGO_ fails. You also need to specify the location of your login
and error pages.

[source, java]
----
<login-config>
  <auth-method>SPNEGO,FORM</auth-method>
  <realm-name>exampleApplicationDomain</realm-name>
  <form-login-config>
    <form-login-page>/login.jsp</form-login-page>
    <form-error-page>/error.jsp</form-error-page>
  </form-login-config>
</login-config>
----

[[configure-applications-to-use-elytron-or-legacy-security-for-authentication]]
=== Configure Applications to Use Elytron or Legacy Security for
Authentication

After you have configured the _elytron_ or legacy _security_ subsystems
for authentication, you need to configure your application to use it.

[[configure-your-applications-web.xml.]]
==== Configure your application's web.xml.

Your application's _web.xml_ needs to be configured to use the
appropriate authentication method. When using _elytron_, this is defined
in the _http-authentication-factory_ you created. When using the legacy
_security_ subsystem, this depends on your login module and the type of
authentication you want to configure.

Example _web.xml_ with _BASIC_ Authentication

[source, java]
----
<web-app>
  <security-constraint>
    <web-resource-collection>
      <web-resource-name>secure</web-resource-name>
      <url-pattern>/secure/*</url-pattern>
    </web-resource-collection>
    <auth-constraint>
      <role-name>Admin</role-name>
    </auth-constraint>
  </security-constraint>
  <security-role>
    <description>The role that is required to log in to /secure/*</description>
    <role-name>Admin</role-name>
  </security-role>
  <login-config>
    <auth-method>BASIC</auth-method>
    <realm-name>exampleApplicationDomain</realm-name>
  </login-config>
</web-app>
----

[[configure-your-application-to-use-a-security-domain.]]
==== Configure your application to use a security domain.

You can configure your application's _jboss-web.xml_ to specify the
security domain you want to use for authentication. When using the
_elytron_ subsystem, this is defined when you created the
_application-security-domain_. When using the legacy _security_
subsystem, this is the name of the legacy security domain.

Example _jboss-web.xml_

[source, java]
----
<jboss-web>
  <security-domain>exampleApplicationDomain</security-domain>
</jboss-web>
----

Using _jboss-web.xml_ allows you to configure the security domain for a
single application only. Alternatively, you can specify a default
security domain for all applications using the _undertow_ subsystem.
This allows you to omit using _jboss-web.xml_ to configure a security
domain for an individual application.

[source, java]
----
/subsystem=undertow:write-attribute(name=default-security-domain, value="exampleApplicationDomain")
----

*IMPORTANT*: Setting _default-security-domain_ in the _undertow_
subsystem will apply to *ALL* applications. If _default-security-domain_
is set and an application specifies a security domain in a
_jboss-web.xml_ file, the configuration in _jboss-web.xml_ will override
the _default-security-domain_ in the _undertow_ subsystem.

[[using-elytron-and-legacy-security-subsystems-in-parallel]]
==== Using Elytron and Legacy Security Subsystems in Parallel

You can define authentication in both the _elytron_ and legacy
_security_ subsystems and use them in parallel. If you use both
_jboss-web.xml_ and _default-security-domain_ in the _undertow_
subsystem, WildFly will first try to match the configured security
domain in the _elytron_ subsystem. If a match is not found, then WildFly
will attempt to match the security domain with one configured in the
legacy _security_ subsystem. If the _elytron_ and legacy _security_
subsystem each have a security domain with the same name, the _elytron_
security domain is used.

[[override-an-applications-authentication-configuration]]
=== Override an Application's Authentication Configuration

You can override the authentication configuration of an application with
one configured in WildFly. To do this, use the
_override-deployment-configuration_ property in the
_application-security-domain_ section of the _undertow_ subsystem:

[source, java]
----
/subsystem=undertow/application-security-domain=exampleApplicationDomain:write-attribute(name=override-deployment-config,value=true)
----

For example, an application is configured to use _FORM_ authentication
with the _exampleApplicationDomain_ in its _jboss-web.xml_.

_Example jboss-web.xml_

[source, java]
----
<login-config>
  <auth-method>FORM</auth-method>
  <realm-name>exampleApplicationDomain</realm-name>
</login-config>
----

By enabling _override-deployment-configuration_, you can create a new
_http-authentication-factory_ that specifies a different authentication
mechanism such as _BASIC_.

_Example http-authentication-factory_

[source, java]
----
/subsystem=elytron/http-authentication-factory=exampleHttpAuth:read-resource()
{
    "outcome" => "success",
    "result" => {
        "http-server-mechanism-factory" => "global",
        "mechanism-configurations" => [{
            "mechanism-name" => "BASIC",
            "mechanism-realm-configurations" => [{"realm-name" => "exampleApplicationDomain"}]
        }],
        "security-domain" => "exampleSD"
    }
}
----

This will override the authentication mechanism defined in the
application's _jboss-web.xml_ and attempt to authenticate a user using
_BASIC_ instead of _FORM_.

[[create-and-use-a-credential-store]]
=== Create and Use a Credential Store

[[create-credential-store.]]
==== Create credential store.

[source, java]
----
/subsystem=elytron/credential-store=exampleCS:add(uri="cr-store://exampleCS?create=true",credential-reference={clear-text=cs-secret})
----

[[add-a-credential-to-a-credential-store.]]
==== Add a credential to a credential store.

[source, java]
----
/subsystem=elytron/credential-store=exampleCS/alias=keystorepw:add(secret-value="secret")
----

[[list-all-credentials-in-a-credential-store.]]
==== List all credentials in a credential store.

[source, java]
----
/subsystem=elytron/credential-store=exampleCS:read-children-names(child-type=alias)
{
    "outcome" => "success",
    "result" => ["keystorepw"]
}
----

[[remove-a-credential-from-a-credential-store.]]
==== Remove a credential from a credential store.

[source, java]
----
/subsystem=elytron/credential-store=exampleCS/alias=keystorepw:remove
----

[[use-a-credential-store.]]
==== Use a credential store.

[source, java]
----
/subsystem=elytron/key-store=twoWayKS:write-attribute(name=credential-reference,value={store=exampleCS,alias=keystorepw})
----

[[set-up-and-configure-authentication-for-the-management-interfaces]]
== Set up and Configure Authentication for the Management Interfaces

[[secure-the-management-interfaces-with-a-new-identity-store]]
=== Secure the Management Interfaces with a New Identity Store

[[create-a-security-domain-and-any-supporting-security-realms-decoders-or-mappers-for-your-identity-store.]]
==== Create a security domain and any supporting security realms,
decoders, or mappers for your identity store.

This process is covered in a previous section. For example, if you
wanted to secure the management interfaces using a filesystem-based
identity store, you would follow the steps in
link:#src-557133_WildFlyElytronSecurity-ConfigureAuthenticationwithaFilesystem-BasedIdentityStore[Configure
Authentication with a Filesystem-Based Identity Store].

[[create-an-http-authentication-factory-or-sasl-authentication-factory.]]
==== Create an http-authentication-factory or
sasl-authentication-factory.

Example _http-authentication-factory_

[source, java]
----
/subsystem=elytron/http-authentication-factory=example-http-auth:add(http-server-mechanism-factory=global,security-domain=exampleSD,mechanism-configurations=[{mechanism-name=DIGEST,mechanism-realm-configurations=[{realm-name=exampleManagementRealm}]}])
----

Example _sasl-authentication-factory_

[source, java]
----
/subsystem=elytron/sasl-authentication-factory=example-sasl-auth:add(sasl-server-factory=configured,security-domain=exampleSD,mechanism-configurations=[{mechanism-name=DIGEST-MD5,mechanism-realm-configurations=[{realm-name=exampleManagementRealm}]}])
----

[[update-the-management-interfaces-to-use-your-http-authentication-factory-or-sasl-authentication-factory.]]
==== Update the management interfaces to use your
http-authentication-factory or sasl-authentication-factory.

Example update _http-authentication-factory_

[source, java]
----
/core-service=management/management-interface=http-interface:write-attribute(name=http-authentication-factory, value=example-http-auth)
{
   "outcome" => "success",
   "response-headers" => {
       "operation-requires-reload" => true,
       "process-state" => "reload-required"
   }
}
 
reload
----

Example update _sasl-authentication-factory_

[source, java]
----
/core-service=management/management-interface=http-interface:write-attribute(name=http-upgrade.sasl-authentication-factory, value=example-sasl-auth)
{
   "outcome" => "success",
   "response-headers" => {
       "operation-requires-reload" => true,
       "process-state" => "reload-required"
   }
}
 
reload
----

[[silent-authentication]]
=== Silent Authentication

By default, WildFly provides an authentication mechanism for local
users, also know as silent authentication, through the _local_ security
realm.

Silent authentication must be used via a _sasl-authentication-factory_.

*IMPORTANT*: When enabling silent authentication, you must ensure the
security domain referenced by your _sasl-authentication-factory_
references a security realm that contains the _$local_ user. By default,
WildFly provides the _local_ identity realm that provides this user.

[[add-silent-authentication-to-an-existing-sasl-authentication-factory.]]
==== Add silent authentication to an existing
sasl-authentication-factory.

[source, java]
----
/subsystem=elytron/sasl-authentication-factory=example-sasl-auth:list-add(name=mechanism-configurations, value={mechanism-name=JBOSS-LOCAL-USER, realm-mapper=local})
 
reload
----

[[create-a-new-sasl-server-factory-with-silent-authentication.]]
==== Create a new sasl-server-factory with silent authentication.

[source, java]
----
/subsystem=elytron/sasl-authentication-factory=example-sasl-auth:add(sasl-server-factory=configured,security-domain=exampleSD,mechanism-configurations=[{mechanism-name=DIGEST-MD5,mechanism-realm-configurations=[{realm-name=exampleManagementRealm}]},{mechanism-name=JBOSS-LOCAL-USER, realm-mapper=local}])
 
reload
----

[[remove-silent-authentication-from-an-existing-sasl-server-factory]]
==== Remove silent authentication from an existing sasl-server-factory:

[source, java]
----
/subsystem=elytron/sasl-authentication-factory=managenet-sasl-authentication:read-resource
{
    "outcome" => "success",
    "result" => {
        "mechanism-configurations" => [
            {
                "mechanism-name" => "JBOSS-LOCAL-USER",
                "realm-mapper" => "local"
            },
            {
                "mechanism-name" => "DIGEST-MD5",
                "mechanism-realm-configurations" => [{"realm-name" => "ManagementRealm"}]
            }
        ],
        "sasl-server-factory" => "configured",
        "security-domain" => "ManagementDomain"
    }
}
 
/subsystem=elytron/sasl-authentication-factory=temp-sasl-authentication:list-remove(name=mechanism-configurations,index=0)
 
reload
----

[[using-rbac-with-elytron]]
=== Using RBAC with Elytron

RBAC can be configured to automatically assign or exclude roles for
users that are members of groups. This is configured in the
_access-control_ section of the core management. When the management
interfaces are secured with the _elytron_ subsystem, and users are
assigned groups when they authenticate. You can also configure roles to
be assigned to authenticated users in a variety of ways using the
_elytron_ subsystem, for example using a role mapper or a role decoder.

[[configure-ssltls]]
== Configure SSL/TLS

[[enable-one-way-ssltls-for-applications]]
=== Enable One-way SSL/TLS for Applications

In WildFly, you can use the Elytron subsystem, along with the Undertow
subsystem, to enable HTTPS for deployed applications.

[[obtain-or-generate-your-key-store]]
==== Obtain or generate your key store:

Before enabling HTTPS in WildFly, you must obtain or generate the
keystore you plan on using. To generate an example keystore:

[source, java]
----
$ keytool -genkeypair -alias localhost -keyalg RSA -keysize 1024 -validity 365 -keystore /path/to/keystore.jks -dname "CN=localhost" -keypass secret -storepass secret
----

[[configure-a-key-store-in-wildfly]]
==== Configure a key-store in WildFly:

[source, java]
----
/subsystem=elytron/key-store=httpsKS:add(path=/path/to/keystore.jks,credential-reference={clear-text=secret},type=JKS)
----

The previous command uses an absolute path to the keystore.
Alternatively you can use the _relative-to_ attribute to specify the
base directory variable and _path_ specify a relative path.

[source, java]
----
/subsystem=elytron/key-store=httpsKS:add(path=keystore.jks,relative-to=jboss.server.config.dir,credential-reference={clear-text=secret},type=JKS)
----

[[configure-a-key-manager-in-that-references-your-key-store]]
==== Configure a key-manager in that references your key-store:

[source, java]
----
/subsystem=elytron/key-manager=httpsKM:add(key-store=httpsKS,credential-reference={clear-text=secret})
----

[[configure-a-server-ssl-context-in-that-references-your-key-manager]]
==== Configure a server-ssl-context in that references your key-manager:

[source, java]
----
/subsystem=elytron/server-ssl-context=httpsSSC:add(key-manager=httpsKM,protocols=["TLSv1.2"])
----

*IMPORTANT*: You need to determine what SSL/TLS protocols you want to
support. The example commands above uses _TLSv1.2_.

[[check-and-see-if-the-https-listener-is-configured-to-use-a-legacy-security-realm-for-its-ssl-configuration]]
==== Check and see if the https-listener is configured to use a legacy
security realm for its SSL configuration:

[source, java]
----
/subsystem=undertow/server=default-server/https-listener=https:read-attribute(name=security-realm)
{
    "outcome" => "success",
    "result" => "ApplicationRealm"
}
----

The above command shows that the _https-listener_ is configured to use
the _ApplicationRealm_ legacy security realm for its SSL configuration.
Undertow cannot reference both a legacy security realm and an
_ssl-context_ in Elytron at the same time so you must remove the
reference to the legacy security realm. Also there has to be always
configured either _ssl-context_ or _security-realm_. Thus when changing
between those, you have to use batch operation:

*Remove the reference to the legacy security realm and update the*
*_https-listener_* *to use the* *_ssl-context_* *from Elytron* *:*

[source, java]
----
batch
/subsystem=undertow/server=default-server/https-listener=https:undefine-attribute(name=security-realm)
/subsystem=undertow/server=default-server/https-listener=https:write-attribute(name=ssl-context,value=httpsSSC)
run-batch
----

[[reload-the-server]]
==== Reload the server:

[source, java]
----
reload
----

HTTPS is now enabled for applications.

[[enable-two-way-ssltls-in-wildfly-for-applications]]
=== Enable Two-way SSL/TLS in WildFly for Applications

In WildFly, you can use the Elytron subsystem, along with the Undertow
subsystem, to enable two-way SSL/TLS for deployed applications.

[[obtain-or-generate-your-keystore]]
==== Obtain or generate your keystore:

Before enabling HTTPS in WildFly, you must obtain or generate the
keystores, truststores and certificates you plan on using.

Create server and client keystores:

[source, java]
----
$ keytool -genkeypair -alias localhost -keyalg RSA -keysize 1024 -validity 365 -keystore server.keystore.jks -dname "CN=localhost" -keypass secret -storepass secret
 
$ keytool -genkeypair -alias client -keyalg RSA -keysize 1024 -validity 365 -keystore client.keystore.jks -dname "CN=client" -keypass secret -storepass secret
----

Export the server and client certificates:

[source, java]
----
$ keytool -exportcert  -keystore server.keystore.jks -alias localhost -keypass secret -storepass secret -file server.cer
 
$ keytool -exportcert  -keystore client.keystore.jks -alias client -keypass secret -storepass secret -file client.cer
----

Import the sever and client certificates into the opposing truststores:

[source, java]
----
$ keytool -importcert -keystore server.truststore.jks -storepass secret -alias client -trustcacerts -file client.cer
 
$ keytool -importcert -keystore client.truststore.jks -storepass secret -alias localhost -trustcacerts -file server.cer
----

[[configure-a-key-store-for-server-keystore-and-truststore-in-wildfly]]
==== Configure a key-store for server keystore and truststore in
WildFly:

[source, java]
----
/subsystem=elytron/key-store=twoWayKS:add(path=/path/to/server.keystore.jks,credential-reference={clear-text=secret},type=JKS)
 
/subsystem=elytron/key-store=twoWayTS:add(path=/path/to/server.truststore.jks,credential-reference={clear-text=secret},type=JKS)
----

*NOTE* +
The previous command uses an absolute path to the keystore.
Alternatively you can use the _relative-to_ attribute to specify the
base directory variable and _path_ specify a relative path.

[source, java]
----
/subsystem=elytron/key-store=myKS:add(path=keystore.jks,relative-to=jboss.server.config.dir,credential-reference={clear-text=secret},type=JKS)
----

[[configure-a-key-manager-in-that-references-your-key-store-key-store]]
==== Configure a key-manager in that references your key store
key-store:

[source, java]
----
/subsystem=elytron/key-manager=twoWayKM:add(key-store=twoWayKS,credential-reference={clear-text=secret})
----

[[configure-a-trust-manager-in-that-references-your-truststore-key-store]]
==== Configure a trust-manager in that references your truststore
key-store:

[source, java]
----
/subsystem=elytron/trust-manager=twoWayTM:add(key-store=twoWayTS)
----

[[configure-a-server-ssl-context-in-that-references-your-key-manager-trust-manager-and-enables-client-authentication]]
==== Configure a server-ssl-context in that references your key-manager,
trust-manager, and enables client authentication:

[source, java]
----
/subsystem=elytron/server-ssl-context=twoWaySSC:add(key-manager=twoWayKM,protocols=["TLSv1.2"],trust-manager=twoWayTM,need-client-auth=true)
----

*IMPORTANT* +
You need to determine what SSL/TLS protocols you want to support. The
example commands above uses _TLSv1.2_.

[[check-and-see-if-the-https-listener-is-configured-to-use-a-legacy-security-realm-for-its-ssl-configuration-1]]
==== Check and see if the https-listener is configured to use a legacy
security realm for its SSL configuration:

[source, java]
----
/subsystem=undertow/server=default-server/https-listener=https:read-attribute(name=security-realm)
{
    "outcome" => "success",
    "result" => "ApplicationRealm"
}
----

The above command shows that the _https-listener_ is configured to use
the _ApplicationRealm_ legacy security realm for its SSL configuration.
Undertow cannot reference both a legacy security realm and an
_ssl-context_ in Elytron at the same time so you must remove the
reference to the legacy security realm. Also there has to be always
configured either _ssl-context_ or _security-realm_. Thus when changing
between those, you have to use batch operation:

[[remove-the-reference-to-the-legacy-security-realm-and-update-the-https-listener-to-use-the-ssl-context-from-elytron]]
==== Remove the reference to the legacy security realm and update the
https-listener to use the ssl-context from Elytron:

[source, java]
----
batch
/subsystem=undertow/server=default-server/https-listener=https:undefine-attribute(name=security-realm)
/subsystem=undertow/server=default-server/https-listener=https:write-attribute(name=ssl-context,value=twoWaySSC)
run-batch
----

[[reload-the-server-1]]
==== Reload the server

[source, java]
----
reload
----

[[configure-your-client-to-use-the-client-certificate]]
==== Configure your client to use the client certificate

You need to configure your client to present the trusted client
certificate to the server to complete the two-way SSL/TLS
authentication. For example, if using a browser, you need to import the
trusted certificate into the browser's truststore.

Two-Way HTTPS is now enabled for applications.

[[enable-one-way-ssltls-for-the-management-interfaces-using-the-elytron-subsystem]]
=== Enable One-way SSL/TLS for the Management Interfaces Using the
Elytron Subsystem

[[obtain-or-generate-your-key-store-1]]
==== Obtain or generate your key store:

Before enabling HTTPS in WildFly, you must obtain or generate the key
store you plan on using. To generate an example key store, use the
following command.

[source, java]
----
$ keytool -genkeypair -alias localhost -keyalg RSA -keysize 1024 -validity 365 -keystore keystore.jks -dname "CN=localhost" -keypass secret -storepass secret
----

[[create-a-key-store-key-manager-and-server-ssl-context.]]
==== Create a key-store, key-manager, and server-ssl-context.

[source, java]
----
/subsystem=elytron/key-store=httpsKS:add(path=keystore.jks,relative-to=jboss.server.config.dir,credential-reference={clear-text=secret},type=JKS)
 
/subsystem=elytron/key-manager=httpsKM:add(key-store=httpsKS,credential-reference={clear-text=secret})
 
/subsystem=elytron/server-ssl-context=httpsSSC:add(key-manager=httpsKM,protocols=["TLSv1.2"])
----

*IMPORTANT:* You need to determine what SSL/TLS protocols you want to
support. The example commands above uses _TLSv1.2_.

*NOTE:* The above command uses _relative-to_ to reference the location
of the keystore file. Alternatively, you can specify the full path to
the keystore in _path_ and omit _relative-to_.

[[enable-https-on-the-management-interface.]]
==== Enable HTTPS on the management interface.

[source, java]
----
/core-service=management/management-interface=http-interface:write-attribute(name=ssl-context, value=httpsSSC)
 
/core-service=management/management-interface=http-interface:write-attribute(name=secure-socket-binding, value=management-https)
----

[[reload-the-wildfly-instance.]]
==== Reload the WildFly instance.

[source, java]
----
reload
----

HTTPS is now enabled for the management interfaces.

[[enable-two-way-ssltls-for-the-management-interfaces-using-the-elytron-subsystem]]
=== Enable Two-way SSL/TLS for the Management Interfaces using the
Elytron Subsystem

[[obtain-or-generate-your-key-store.]]
==== Obtain or generate your key store.

Before enabling HTTPS in WildFly, you must obtain or generate the key
stores, trust stores and certificates you plan on using. To generate an
example set of key stores, trust stores, and certificates use the
following commands.

Generate your server and client key stores.

[source, java]
----
$ keytool -genkeypair -alias localhost -keyalg RSA -keysize 1024 -validity 365 -keystore server.keystore.jks -dname "CN=localhost" -keypass secret -storepass secret
 
$ keytool -genkeypair -alias client -keyalg RSA -keysize 1024 -validity 365 -keystore client.keystore.jks -dname "CN=client" -keypass secret -storepass secret
----

Export your server and client certificates.

[source, java]
----
$ keytool -exportcert  -keystore server.keystore.jks -alias localhost -keypass secret -storepass secret -file server.cer
 
$ keytool -exportcert  -keystore client.keystore.jks -alias client -keypass secret -storepass secret -file client.cer
----

Import the sever and client certificates into the opposing trust stores.

[source, java]
----
$ keytool -importcert -keystore server.truststore.jks -storepass secret -alias client -trustcacerts -file client.cer
 
$ keytool -importcert -keystore client.truststore.jks -storepass secret -alias localhost -trustcacerts -file server.cer
----

[[configure-key-store-a-key-manager-trust-manager-and-server-ssl-context-for-the-server-key-store-and-trust-store.]]
==== Configure key-store, a key-manager, trust-manager, and
server-ssl-context for the server key store and trust store.

[source, java]
----
/subsystem=elytron/key-store=twoWayKS:add(path=server.keystore.jks,relative-to=jboss.server.config.dir,credential-reference={clear-text=secret},type=JKS)
 
/subsystem=elytron/key-store=twoWayTS:add(path=server.truststore.jks,relative-to=jboss.server.config.dir,credential-reference={clear-text=secret},type=JKS)
 
/subsystem=elytron/key-manager=twoWayKM:add(key-store=twoWayKS,credential-reference={clear-text=secret})
 
/subsystem=elytron/trust-manager=twoWayTM:add(key-store=twoWayTS)
 
/subsystem=elytron/server-ssl-context=twoWaySSC:add(key-manager=twoWayKM,protocols=["TLSv1.2"],trust-manager=twoWayTM,want-client-auth=true,need-client-auth=true)
----

*IMPORTANT:* You need to determine what SSL/TLS protocols you want to
support. The example commands above uses _TLSv1.2_.

*NOTE:* The above command uses _relative-to_ to reference the location
of the keystore file. Alternatively, you can specify the full path to
the keystore in _path_ and omit _relative-to_.

[[enable-https-on-the-management-interface.-1]]
==== Enable HTTPS on the management interface.

[source, java]
----
/core-service=management/management-interface=http-interface:write-attribute(name=ssl-context, value=twoWaySSC)
 
/core-service=management/management-interface=http-interface:write-attribute(name=secure-socket-binding, value=management-https)
----

[[reload-the-wildfly-instance.-1]]
==== Reload the WildFly instance.

[source, java]
----
reload
----

[[configure-your-client-to-use-the-client-certificate.]]
==== Configure your client to use the client certificate.

You need to configure your client to present the trusted client
certificate to the server to complete the two-way SSL/TLS
authentication. For example, if using a browser, you need to import the
trusted certificate into the browser's trust store.

Two-way SSL/TLS is now enabled for the management interfaces.

[[using-an-ldap-key-store]]
=== Using an ldap-key-store

An _ldap-key-store_ allows you to use a keystore stored in an LDAP
server. You can use an _ldap-key-store_ in same way you can use a
_key-store_.

To create and use an _ldap-key-store_:

[[configure-a-dir-context.]]
==== Configure a dir-context.

To connect to the LDAP server from WildFly, you need to configure a
_dir-context_ that provides the URL as well as the principal used to
connect to the server.

*Example dir-context*

[source, java]
----
/subsystem=elytron/dir-context=exampleDC:add( \
  url="ldap://127.0.0.1:10389", \
  principal="uid=admin,ou=system", \
  credential-reference={clear-text=secret} \
)
----

[[configure-an-ldap-key-store.]]
==== Configure an ldap-key-store.

When configure an _ldap-key-store_, you need to specify both the
_dir-context_ used to connect to the LDAP server as well as how to
locate the keystore stored in the LDAP server. At a minimum, this
requires you specify a _search-path_.

*Example ldap-key-store*

[source, java]
----
/subsystem=elytron/ldap-key-store=ldapKS:add( \
  dir-context=exampleDC, \
  search-path="ou=Keystores,dc=wildfly,dc=org" \
)
----

[[use-the-ldap-key-store.]]
==== Use the ldap-key-store.

Once you have defined your _ldap-key-store_, you can use it in the same
places where a _key-store_ could be used. For example, you could use an
_ldap-key-store_ when configuring HTTPS and Two-Way HTTPS for
applications.

[[using-a-filtering-key-store]]
=== Using a filtering-key-store

A _filtering-key-store_ allows you to expose a subset of aliases from an
existing _key-store_, and use it in the same places you could use a
_key-store_. For example, if a keystore contained _alias1_, _alias2_,
and _alias3_, but you only wanted to expose _alias1_ and _alias3_, a
_filtering-key-store_ provides you several ways to do that.

To create a _filtering-key-store_:

[[configure-a-key-store.]]
==== Configure a key-store.

[source, java]
----
/subsystem=elytron/key-store=myKS:add( \
  path=keystore.jks, \
  relative-to=jboss.server.config.dir, \
  credential-reference={ \
    clear-text=secret \
  }, \
  type=JKS \
)
----

[[configure-a-filtering-key-store.]]
==== Configure a filtering-key-store.

When you configure a _filtering-key-store_, you specify which
_key-store_ you want to filter and the _alias-filter_ for filtering
aliases from the _key-store_. The filter can be specified in one of the
following formats:

* _alias1,alias3_, which is a comma-delimited list of aliases to expose.
* _ALL:-alias2_, which exposes all aliases in the keystore except the
ones listed.
* _NONE:+alias1:+alias3_, which exposes no aliases in the keystore
except the ones listed.

This example uses a comma-delimted list to expose _alias1_ and _alias3_.

[source, java]
----
/subsystem=elytron/filtering-key-store=filterKS:add( \
  key-store=myKS, \
  alias-filter="alias1,alias3" \
)
----

[[use-the-filtering-key-store.]]
==== Use the filtering-key-store.

Once you have defined your _filtering-key-store_, you can use it in the
same places where a _key-store_ could be used. For example, you could
use a _filtering-key-store_ when configuring HTTPS and Two-Way HTTPS for
applications.

[[reload-a-keystore]]
=== Reload a Keystore

You can reload a keystore configured in WildFly from the management CLI.
This is useful in cases where you have made changes to certificates
referenced by a keystore.

To reload a keystore.

[source, java]
----
/subsystem=elytron/key-store=httpsKS:load
----

[[check-the-content-of-a-keystore-by-alias]]
=== Check the Content of a Keystore by Alias

If you add a keystore to the _elytron_ subsystem using the _key-store_
component, you can check the keystore's contents using the _alias_ child
element and reading its attributes.

For example:

[source, java]
----
/subsystem=elytron/key-store=httpsKS/alias=localhost:read-attribute(name=certificate-chain)
{
    "outcome" => "success",
    "result" => [{
        "type" => "X.509",
        "algorithm" => "RSA",
        "format" => "X.509",
        "public-key" => "30:81:9f:30:0d:06:09:2a:8......
----

The following attributes can be read:

[cols=",",]
|=======================================================================
|Attribute |Description

|certificate |The certificate associated with the alias. If the alias
has a certificate chain this will always be undefined.

|certificate-chain |The certificate chain associated with the alias.

|creation-date |The creation date of the entry represented by this
alias.

|entry-type |The type of the entry for this alias. Available types:
PasswordEntry, PrivateKeyEntry, SecretKeyEntry, TrustedCertificateEntry,
and Other. Unrecognized types will be reported as Other.
|=======================================================================

[[custom-components]]
=== Custom Components

When configuring SSL/TLS in the _elytron_ subsystem, you can provide and
use custom implementations of the following components:

* _key-store_
* _key-manager_
* _trust-manager_
* _client-ssl-context_
* _server-ssl-context_

When creating custom implementations of Elytron components, they must
present the appropriate capabilities and requirements.

[[configuring-the-elytron-and-security-subsystems]]
== Configuring the Elytron and Security Subsystems

[[enable-and-disable-the-elytron-subsystem]]
=== Enable and Disable the Elytron Subsystem

[[to-add-the-elytron-extension-required-for-the-elytron-subsystem]]
==== To add the elytron extension required for the elytron subsystem:

[source, java]
----
/extension=org.wildfly.extension.elytron:add()
----

[[to-enable-the-elytron-subsystem-in-wildfly]]
==== To enable the Elytron subsystem in WildFly:

[source, java]
----
/subsystem=elytron:add
 
reload
----

[[to-disable-the-elytron-subsystem-in-wildfly]]
==== To disable the Elytron subsystem in WildFly:

[source, java]
----
/subsystem=elytron:remove
 
reload
----

*IMPORTANT:* Other subsystems within WildFly may have dependencies on
the _elytron_ subsystem. If these dependencies are not resolved before
disabling it, you will see errors when starting WildFly.

[[enable-and-disable-the-security-subsystem]]
=== Enable and Disable the Security Subsystem

[[to-disable-the-security-subsystem-in-wildfly]]
==== To disable the security subsystem in WildFly:

[source, java]
----
/subsystem=security:remove
 
reload
----

*IMPORTANT:* Other subsystems within WildFly may have dependencies on
the _security_ subsystem. If these dependencies are not resolved before
disabling it, you will see errors when starting WildFly.

[[to-enable-the-security-subsystem-in-wildfly]]
==== To enable the security subsystem in WildFly:

[source, java]
----
/subsystem=security:add
 
reload
----

[[use-the-elytron-and-security-subsystems-in-parallel]]
=== Use the Elytron and Security Subsystems in Parallel

By default the _elytron_ and _security_ subsystems will run in parallel
if both are enabled. For authentication in applications, you can use the
_application-security-domain_ property in the _undertow_ subsystem to
configure a security domain in the _elytron_ subsystem.

[source, java]
----
/subsystem=undertow/application-security-domain=exampleApplicationDomain:add(http-authentication-factory=example-http-auth)
----

*NOTE:* This must match the _security-domain_ configured in the
_jboss-web.xml_ of your application.

If the _application-security-domain_ is not set, WildFly will look for a
security domain configured in the _security_ subsystem that matches the
_security-domain_ configured in the _jboss-web.xml_ of your application.

For enabling HTTPS using a legacy security realm, you can use the
_security-realm_ attribute in the _https-listener_ section of the
_undertow_ subsystem:

[source, java]
----
/subsystem=undertow/server=default-server/https-listener=https:read-attribute(name=security-realm)
{
    "outcome" => "success",
    "result" => "ApplicationRealm"
}
----

For enabling HTTPS using _elytron_, you need to undefine the
_security-realm_ attribute and set the _ssl-context_ attribute. As there
has to be always configured either _ssl-context_ or _security-realm_ you
have to use batch operation when changing between those:

[source, java]
----
batch
/subsystem=undertow/server=default-server/https-listener=https:undefine-attribute(name=security-realm)
/subsystem=undertow/server=default-server/https-listener=https:write-attribute(name=ssl-context,value=httpsSSC)
run-batch
----

[[creating-elytron-subsystem-components]]
== Creating Elytron Subsystem Components

[[create-an-elytron-security-realm]]
=== Create an Elytron Security Realm

Security realms in the Elytron subsystem, when used in conjunction with
security domains, are use for both core management authentication as
well as for authentication with applications. Security realms are also
specifically typed based on their identity store, for example
_jdbc-realm_, _filesystem-realm_, _properties-realm_, etc.

Adding a security realm takes the general form:

[source, java]
----
/subsystem=elytron/type-of-realm=realmName:add(....)
----

Examples of adding specific realms, such as _jdbc-realm_,
_filesystem-realm_, and _properties-realm_ can be found in previous
sections.

[[create-an-elytron-role-decoder]]
=== Create an Elytron Role Decoder

A role decoder converts attributes from the identity provided by the
security realm into roles. Role decoders are also specifically typed
based on their functionality, for example _empty-role-decoder_,
_simple-role-decoder_, and _custom-role-decoder_.

Adding a role decoder takes the general form:

[source, java]
----
/subsystem=elytron/ROLE-DECODER-TYPE=roleDeoderName:add(....)
----

[[create-an-elytron-permission-mapper]]
=== Create an Elytron Permission Mapper

In addition to roles being assigned to a identity, permissions may also
be assigned. A permission mapper assigns permissions to an identity.
Permission mappers are also specifically typed based on their
functionality, for example _logical-permission-mapper_,
_simple-permission-mapper_, and _custom-permission-mapper_.

Adding a permission mapper takes the general form:

[source, java]
----
/subsystem=elytron/simple-permission-mapper=PermissionMapperName:add(...)
----

[[create-an-elytron-role-mapper]]
=== Create an Elytron Role Mapper

A role mapper maps roles after they have been decoded to other roles.
Examples include normalizing role names or adding and removing specific
roles from principals after they have been decoded. Role mappers are
also specifically typed based on their functionality, for example
_add-prefix-role-mapper_, _add-suffix-role-mapper_, and
_constant-role-mapper_.

Adding a role mapper takes the general form:

[source, java]
----
/subsystem=elytron/ROLEM-MAPPER-TYPE=roleMapperName:add(...)
----

[[create-an-elytron-security-domain]]
=== Create an Elytron Security Domain

Security domains in the Elytron subsystem, when used in conjunction with
security realms, are use for both core management authentication as well
as for authentication with applications.

Adding a security domain takes the general form:

[source, java]
----
/subsystem=elytron/security-domain=domainName:add(realms=[{realm=realmName,role-decoder=roleDecoderName}],default-realm=realmName,permission-mapper=permissionMapperName,role-mapper=roleMapperName,...)
----

[[create-an-elytron-authentication-factory]]
=== Create an Elytron Authentication Factory

An authentication factory is an authentication policy used for specific
authentication mechanisms. Authenticaion factories are specifically
based on the authentication mechanism, for example
_http-authentication-factory_ and +
_sasl-authentication-factory_ and _kerberos-security-factory_.

Adding an authentication factory takes the general form:

[source, java]
----
/subsystem=elytron/AUTH-FACTORY-TYPE=authFactoryName:add(....)
----

[[create-an-elytron-policy-provider]]
=== Create an Elytron Policy Provider

Elytron subsystem provides a specific resource definition that can be
used to configure a default Java Policy provider. The subsystem allows
you to define multiple policy providers but select a single one as the
default:

[source, java]
----
/subsystem=elytron/policy=policy-provider-a:add(custom-policy=\[{name=policy-provider-a, class-name=MyPolicyProviderA, module=x.y.z}\])
----

[source, java]
----
----

[[using-elytron-within-wildfly]]
= Using Elytron within WildFly

[[using-the-out-of-the-box-elytron-components]]
== Using the Out of the Box Elytron Components

[[securing-management-interfaces]]
=== Securing Management Interfaces

You can find more details on the enabling WildFly to use the out of the
box Elytron components for securing the management interfaces in the
link:Elytron_Subsystem.html#src-557147_ElytronSubsystem-DefaultManagementAuthenticationConfiguration[Default
Management Authentication Configuration] section.

[[securing-applications]]
=== Securing Applications

The _elytron_ subsystem provides _application-http-authentication_ by
default which can be used to secure applications. For more details on
how _application-http-authentication_ is configured, see the
link:Elytron_Subsystem.html#src-557147_ElytronSubsystem-OutoftheBoxConfiguration[Out
of the Box Configuration] section.

To configure applications to use _application-http-authentication_, see
link:Using_the_Elytron_Subsystem.html#src-557140_UsingtheElytronSubsystem-ConfigureApplicationstoUseElytronorLegacySecurityforAuthentication[Configure
Applications to Use Elytron or Legacy Security for Authentication]. You
can also override the default behavior of all applications using the
steps in
link:Using_the_Elytron_Subsystem.html#src-557140_safe-id-VXNpbmd0aGVFbHl0cm9uU3Vic3lzdGVtLU92ZXJyaWRlYW5BcHBsaWNhdGlvbidzQXV0aGVudGljYXRpb25Db25maWd1cmF0aW9u[Override
an Application's Authentication Configuration].

[[using-ssltls]]
=== Using SSL/TLS

WildFly does provide a default one-way SSL/TLS configuration using the
legacy core management authentication but does not provide one in the
_elytron_ subsystem. You can find more details on configuring SSL/TLS
using the _elytron_ subsystem for both the management interfaces as well
as for applications in
link:Using_the_Elytron_Subsystem.html#src-557140_UsingtheElytronSubsystem-ssl-tls[Configure
SSL/TLS]

[[using-elytron-with-other-subsystems]]
=== Using Elytron with Other Subsystems

In addition to securing applications and management interfaces, Elytron
also integrates with other subsystems in WildFly.

[cols=",",]
|=======================================================================
|Subsystem |Details

|batch-jberet |You can configure the batch-jberet to run batch jobs
using an Elytron security domain.

|datasources |You can use a credential store or an Elytron security
domain to provide authentication information in a datasource definition.

|messaging-activemq |You can secure remote connections to the remote
connections used by the messaging-activemq subsystem.

|iiop-openjdk |You can use the elytron subsystem to configure SSL/TLS
between clients and servers using the iiop-openjdk subsystem.

|mail |You can use a credential store to provide authentication
information in a server definition in the mail subsystem.

|undertow |You can use the elytron subsystem to configure both SSL/TLS
and application authentication.
|=======================================================================

[[undertow-subsystem]]
== Undertow Subsystem

[[ejb-subsystem]]
== EJB Subsystem

Configuration can be added to the EJB subsystem to map a security domain
name referenced in a deployment to an Elytron security domain:

[source, java]
----
/subsystem=ejb3/application-security-domain=MyAppSecurity:add(security-domain=ApplicationDomain)
----

Which results in:

[source, java]
----
<subsystem xmlns="urn:jboss:domain:ejb3:5.0">
...
    <application-security-domains>
        <application-security-domain name="MyAppSecurity" security-domain="ApplicationDomain"/>
    </application-security-domains>
...
</subsystem>
----

_Note: If the deployment was already deployed at this point the
application server should be reloaded or the deployment redeployed for
the application security domain mapping to take effect._

An `application-security-domain` has two main attributes:

* name - the name of the security domain as specified in a deployment
* security-domain - a reference to the Elytron security domain that
should be used

When an application security domain mapping is configured for a bean in
a deployment, this indicates that security should be handled by Elytron.

[[webservices-subsystem]]
== WebServices Subsystem

There is adapter in webservices subsystem to make authentication works
for elytron security domain automatically. Like configure with legacy
security domain, you can configure elytron security domain in deployment
descriptor or annotation to secure webservice endpoint.

[[legacy-security-subsystem]]
== Legacy Security Subsystem

As previously described, Elytron based security is configured by
chaining together different capability references to form a complete
security policy. To allow an incremental migration from the legacy
Security subsystem some of the major components of this subsystem can be
mapped to Elytron capabilities and used within an Elytron based set up.

[[client-authentication-with-elytron-client]]
= Client Authentication with Elytron Client

WildFly Elytron uses the Elytron Client project to enable remote clients
to authenticate using Elytron. Elytron Client has the following
components:

[cols=",",]
|=======================================================================
|Component |Description

|Authentication Configuration |Contains authentication information such
as usernames, passwords, allowed SASL mechanisms, and the security realm
to use during digest authentication.

|MatchRule |Rule used for deciding which authentication configuration to
use.

|Authentication Context |Set of rules and authentication configurations
to use with a client for establishing a connection.
|=======================================================================

When a connection is established, the client makes use of an
authentication context, which gives rules that match which
authentication configuration is used with an outbound connection. For
example, you could have a rules that use one authentication
configuration when connecting to _server1_ and another authentication
configuration when connecting with _server2_. The authentication context
is comprised of a set of authentication configurations and a set of
rules that define how they are selected when establishing a connection.
An authentication context can also reference _ssl-context_ and can be
matched with rules.

To create a client that uses security information when establishing a
connection:

* Create one or more authentication configurations.
* Create an authentication context by creating rule and authentication
configuration pairs.
* Create a runnable for establishing your connection.
* Use your authentication context to run your runnable.

When you establish your connection, Elytron Client will use the set of
rules provided by the authentication context to match the correct
authentication configuration to use during authentication.

You can use one of the following approaches to use security information
when establishing a client connection.

*IMPORTANT*: When using Elytron Client to make EJB calls, any hard-coded
programatic authentication information, such as setting
_Context.SECURITY_PRINCIPAL_ in the _javax.naming.InitialContext_, will
override the Elytron Client configuration.

[[the-configuration-file-approach]]
== The Configuration File Approach

The configuration file approach involves creating an XML file with your
authentication configuration, authentication context, and match rules.

*custom-config.xml*

[source, java]
----
<configuration>
    <authentication-client xmlns="urn:elytron:1.0">
        <authentication-rules>
            <rule use-configuration="monitor">
                <match-host name="127.0.0.1" />
            </rule>
            <rule use-configuration="administrator">
                <match-host name="localhost" />
            </rule>
        </authentication-rules>
        <authentication-configurations>
            <configuration name="monitor">
                <allow-sasl-mechanisms names="DIGEST-MD5" />
                 <use-service-loader-providers />
                 <set-user-name name="monitor" />
                 <credentials>
                     <clear-password password="password1!" />
                 </credentials>
                 <set-mechanism-realm name="ManagementRealm" />
             </configuration>
             
             <configuration name="administrator">
                <allow-sasl-mechanisms names="DIGEST-MD5" />
                 <use-service-loader-providers />
                 <set-user-name name="administrator" />
                 <credentials>
                     <clear-password password="password1!" />
                 </credentials>
                 <set-mechanism-realm name="ManagementRealm" />
             </configuration>
        </authentication-configurations>
    </authentication-client>
</configuration>
----

You can then reference that file in your client's code by setting a
system property when running your client.

[source, java]
----
$ java -Dwildfly.config.url=/path/to/the.xml .....
----

*IMPORTANT*: If you use the
link:#src-557133_WildFlyElytronSecurity-TheProgrammaticApproach[The
Programmatic Approach], it will override any provided configuration
files even if the _wildfly.config.url_ system property is set.

When creating rules, you can look for matches on various parameters such
as hostname, port, protocol, or username. A full list of options for
_MatchRule_ are available in the
http://wildfly-security.github.io/wildfly-elytron/org/wildfly/security/auth/client/MatchRule.html[Javadocs].
Rules are evaluated in the order in which they are configured.

*Common Rules*

[cols=",",]
|=======================================================================
|Rule |Description

|match-domain |Takes a single name attribute specifying the security
domain to match against.

|match-host |Takes a single name attribute specifying the hostname to
match against. For example, the host 127.0.0.1 would match on
http://127.0.0.1:9990/my/path .

|match-no-userinfo |Matches against URIs with no userinfo.

|match-path |Takes a single name attribute specifying the path to match
against. For example, the path /my/path/ would match on
http://127.0.0.1:9990/my/path .

|match-port |Takes a single name attribute specifying the port to match
against. For example, the port 9990 would match on
http://127.0.0.1:9990/my/path .

|match-protocol |Takes a single name attribute specifying the protocol
to match against. For example, the protocol http would match on
http://127.0.0.1:9990/my/path .

|match-purpose |Takes a names attribute specifying the list of purposes
to match against.

|match-urn |Takes a single name attribute specifying the URN to match
against.

|match-userinfo |Takes a single name attribute specifying the userinfo
to match against.
|=======================================================================

[[the-programmatic-approach]]
== The Programmatic Approach

The programatic approach configures all the Elytron Client configuration
in the client's code:

[source, java]
----
//create your authentication configuration
AuthenticationConfiguration adminConfig = 
    AuthenticationConfiguration.EMPTY
      .useProviders(() -> new Provider[] { new WildFlyElytronProvider() })
      .allowSaslMechanisms("DIGEST-MD5")
      .useRealm("ManagementRealm")
      .useName("administrator")
      .usePassword("password1!");
 
//create your authentication context
AuthenticationContext context = AuthenticationContext.empty();
context = context.with(MatchRule.ALL.matchHost("127.0.0.1"), adminConfig);
 
 
//create your runnable for establishing a connection
Runnable runnable = 
    new Runnable() {
      public void run() {
        try { 
           //Establish your connection and do some work
        } catch (Exception e) {
          e.printStackTrace();
        }
      }
    };
 
//use your authentication context to run your client
context.run(runnable);
----

When adding configuration details to _AuthenticationConfiguration_ and
_AuthenticationContext_, each method call returns a new instance of that
object. For example, if you wanted separate configurations when
connecting over different hostnames, you could do the following:

[source, java]
----
//create your authentication configuration
AuthenticationConfiguration commonConfig = 
    AuthenticationConfiguration.EMPTY
      .useProviders(() -> new Provider[] { new WildFlyElytronProvider() })
      .allowSaslMechanisms("DIGEST-MD5")
      .useRealm("ManagementRealm");
 
AuthenticationConfiguration administrator = 
    commonConfig
      .useName("administrator")
      .usePassword("password1!");
      
      
AuthenticationConfiguration monitor = 
    commonConfig
      .useName("monitor")
      .usePassword("password1!");
 
 
//create your authentication context
AuthenticationContext context = AuthenticationContext.empty();
context = context.with(MatchRule.ALL.matchHost("127.0.0.1"), administrator);
context = context.with(MatchRule.ALL.matchHost("localhost"), monitor);
----

*Common Rules*

[cols=",",]
|=======================================================================
|Rule |Description

|matchLocalSecurityDomain(String name) |This is the same as match-domain
in the configuration file approach.

|matchNoUser() |This is the same as match-no-user in the configuration
file approach.

|matchPath(String pathSpec) |This is the same as match-path in the
configuration file approach.

|matchPort(int port) |This is the same as match-port in the
configuration file approach.

|matchProtocol(String protoName) |This is the same as match-port in the
configuration file approach.

|matchPurpose(String purpose) |Create a new rule which is the same as
this rule, but also matches the given purpose name.

|matchPurposes(String... purposes) |This is the same as match-purpose in
the configuration file approach.

|matchUrnName(String name) |This is the same as match-urn in the
configuration file approach.

|matchUser(String userSpec) |This is the same as match-userinfo in the
configuration file approach.
|=======================================================================

Also, instead of starting with an empty authentication configuration,
you can start with the current configured one by using
_captureCurrent()_.

[source, java]
----
//create your authentication configuration
AuthenticationConfiguration commonConfig = AuthenticationConfiguration.captureCurrent();
----

Using _captureCurrent()_ will capture any previously established
authentication context and use it as your new base configuration. A
authentication context is established once its been activated by calling
_run()_. If _captureCurrent()_ is called and no context is currently
active, it will try and use the default authentication if available. You
can find more details about this in
link:#src-557133_WildFlyElytronSecurity-TheConfigurationFileApproach[The
Configuration File Approach],
link:#src-557133_WildFlyElytronSecurity-TheDefaultConfigurationApproach[The
Default Configuration Approach], and
link:#src-557133_WildFlyElytronSecurity-UsingElytronClientwithClientsDeployedtoWildFly[Using
Elytron Client with Clients Deployed to WildFly] sections.

Using _AuthenticationConfiguration.EMPTY_ should only be used as a base
to build a configuration on top of and should not be used on its own. It
provides a configuration that uses the JVM-wide registered providers and
enables anonymous authentication.

When specifying the providers on top of the
_AuthenticationConfiguration.EMPTY_ configuration, you can specify a
custom list, but most users should use _WildFlyElytronProvider()_
providers.

When creating an authentication context, using the _context.with(...)_
will create a new context that merges the rules and authentication
configuration from the current context with the provided rule and
authentication configuration. The provided rule and authentication
configuration will appear after the ones in the current context.

[[the-default-configuration-approach]]
== The Default Configuration Approach

The default configuration approach relies completely on the
configuration provided by Elytron Client:

[source, java]
----
//create your runnable for establishing a connection
Runnable runnable = 
    new Runnable() {
      public void run() {
        try { 
           //Establish your connection and do some work
        } catch (Exception e) {
          e.printStackTrace();
        }
      }
    };
 
// run runnable directly  
runnable.run();
----

To provide a default configuration, Elytron Client tries to
auto-discover a _wildfly-config.xml_ file on the filesystem. It looks in
the following locations:

* Location specified by the _wildfly.config.url_ system property set
outside of the client code.
* The classpath root directory.
* The _META-INF_ directory on the classpath.

If it does not find one, it will try and use the default
_wildfly-config.xml_ provided in the
_$WILDFLY_HOME/bin/client/jboss-client.jar_.

*default wildfly-config.xml*

[source, java]
----
<configuration>
  <authentication-client xmlns="urn:elytron:1.0">
    <authentication-rules>
      <rule use-configuration="default" />
    </authentication-rules>
    <authentication-configurations>
      <configuration name="default">
        <allow-all-sasl-mechanisms />
        <set-mechanism-properties>
          <property key="wildfly.sasl.local-user.quiet-auth" value="true" />
        </set-mechanism-properties>
        <use-service-loader-providers />
      </configuration>
    </authentication-configurations>
  </authentication-client>
</configuration>
----

[[using-elytron-client-with-clients-deployed-to-wildfly]]
== Using Elytron Client with Clients Deployed to WildFly

Clients deployed to WildFly can also make use of Elytron Client. In
cases where you have included a _wildfly-config.xml_ with your
deployment or the system property has been set, an
_AuthenticationContext_ is automatically parsed and created from that
file.

To load a configuration file outside of the deployment, you can use the
_parseAuthenticationClientConfiguration(URI)_ method. This method will
return an _AuthentcationContext_ which you can then use in your client's
code using the
link:#src-557133_WildFlyElytronSecurity-TheProgrammaticApproach[The
Programmatic Approach].

Additionally, clients will also automatically parse and create an
AuthenticationContext from the client configuration provided by the
_elytron_ subsystem. The client configuration in the _elytron_ subsystem
can also take advantage of other components defined in the _elytron_
subsystem such as credential stores. If client configuration is provided
by BOTH the deployment and the _elytron_ subsystem, the _elytron_
subsystem's configuration is used.

[[using-keycloak-with-wildfly-elytron]]
= Using KeyCloak with WildFly Elytron
