Developer Guide
===============

[[wildfly-developer-guide]]
= WildFly Developer Guide

[[target-audience]]
== Target Audience

Java Developers

[[prerequisites]]
== Prerequisites

[[class-loading-in-wildfly]]
= Class loading in WildFly

Since JBoss AS 7, Class loading is considerably different to previous
versions of JBoss AS. Class loading is based on the
link:#src-557207[MODULES] project. Instead of the more familiar
hierarchical class loading environment, WildFly's class loading is based
on modules that have to define explicit dependencies on other modules.
Deployments in WildFly are also modules, and do not have access to
classes that are defined in jars in the application server unless an
explicit dependency on those classes is defined.

[[deployment-module-names]]
== Deployment Module Names

Module names for top level deployments follow the format
`deployment.myarchive.war` while sub deployments are named like
`deployment.myear.ear.mywar.war`.

This means that it is possible for a deployment to import classes from
another deployment using the other deployments module name, the details
of how to add an explicit module dependency are explained below.

[[automatic-dependencies]]
== Automatic Dependencies

Even though in WildFly modules are isolated by default, as part of the
deployment process some dependencies on modules defined by the
application server are set up for you automatically. For instance, if
you are deploying a Java EE application a dependency on the Java EE
API's will be added to your module automatically. Similarly if your
module contains a beans.xml file a dependency on
http://seamframework.org/Weld[Weld]will be added automatically, along
with any supporting modules that weld needs to operate.

For a complete list of the automatic dependencies that are added, please
see link:#src-557207[Implicit module dependencies for deployments].

Automatic dependencies can be excluded through the use of
`jboss-deployment-structure.xml`.

[[class-loading-precedence]]
== Class Loading Precedence

A common source of errors in Java applications is including API classes
in a deployment that are also provided by the container. This can result
in multiple versions of the class being created and the deployment
failing to deploy properly. To prevent this in WildFly, module
dependencies are added in a specific order that should prevent this
situation from occurring.

In order of highest priority to lowest priority

1.  System Dependencies - These are dependencies that are added to the
module automatically by the container, including the Java EE api's.
2.  User Dependencies - These are dependencies that are added through
`jboss-deployment-structure.xml` or through the `Dependencies:` manifest
entry.
3.  Local Resource - Class files packaged up inside the deployment
itself, e.g. class files from `WEB-INF/classes` or `WEB-INF/lib` of a
war.
4.  Inter deployment dependencies - These are dependencies on other
deployments in an ear deployment. This can include classes in an ear's
lib directory, or classes defined in other ejb jars.

[[war-class-loading]]
== WAR Class Loading

The war is considered to be a single module, so classes defined in
`WEB-INF/lib` are treated the same as classes in `WEB-INF/classes`. All
classes packaged in the war will be loaded with the same class loader.

[[ear-class-loading]]
== EAR Class Loading

Ear deployments are multi-module deployments. This means that not all
classes inside an ear will necessarily have access to all other classes
in the ear, unless explicit dependencies have been defined. By default
the `EAR/lib` directory is a single module, and every WAR or EJB jar
deployment is also a separate module. Sub deployments (wars and
ejb-jars) always have a dependency on the parent module, which gives
them access to classes in `EAR/lib`, however they do not always have an
automatic dependency on each other. This behaviour is controlled via the
`ear-subdeployments-isolated` setting in the ee subsystem configuration:

[source,java]
----
<subsystem xmlns="urn:jboss:domain:ee:1.0" >            
  <ear-subdeployments-isolated>false</ear-subdeployments-isolated>
</subsystem>
----

By default this is set to false, which allows the sub-deployments to see
classes belonging to other sub-deployments within the .ear.

For example, consider the following .ear deployment:

[source,java]
----
myapp.ear
 |
 |--- web.war
 |
 |--- ejb1.jar
 |
 |--- ejb2.jar
----

If the ear-subdeployments-isolated is set to false, then the classes in
web.war can access classes belonging to ejb1.jar and ejb2.jar.
Similarly, classes from ejb1.jar can access classes from ejb2.jar (and
vice-versa).

[IMPORTANT]

The ear-subdeployments-isolated element value has no effect on the
isolated classloader of the .war file(s). i.e. irrespective of whether
this flag is set to true or false, the .war within a .ear will have a
isolated classloader and other sub-deployments within that .ear will not
be able to access classes from that .war. This is as per spec.

If the ear-subdeployments-isolated is set to true then no automatic
module dependencies between the sub-deployments are set up. User must
manually setup the dependency with `Class-Path` entries, or by setting
up explicit module dependencies.

Portability

[IMPORTANT]

The Java EE specification says that portable applications should not
rely on sub deployments having access to other sub deployments unless an
explicit Class-Path entry is set in the MANIFEST.MF. So portable
applications should always use Class-Path entry to explicitly state
their dependencies.

[IMPORTANT]

It is also possible to override the ear-subdeployments-isolated element
value at a per deployment level. See the section on
jboss-deployment-structure.xml below.

`Dependencies:` *Manifest Entries*

Deployments (or more correctly modules within a deployment) may set up
dependencies on other modules by adding a `Dependencies:` manifest
entry. This entry consists of a comma separated list of module names
that the deployment requires. The available modules can be seen under
the `modules` directory in the application server distribution. For
example to add a dependency on javassist and apache velocity you can add
a manifest entry as follows:

`Dependencies: org.javassist export,org.apache.velocity export services,org.antlr`

Each dependency entry may also specify some of the following parameters
by adding them after the module name:

* `export` This means that the dependencies will be exported, so any
module that depends on this module will also get access to the
dependency.
* `services` By default items in META-INF of a dependency are not
accessible, this makes items from `META-INF/services` accessible so
http://download.oracle.com/javase/6/docs/api/java/util/ServiceLoader.html[services]in
the modules can be loaded.
* `optional` If this is specified the deployment will not fail if the
module is not available.
* `meta-inf` This will make the contents of the `META-INF` directory
available (unlike `services`, which just makes `META-INF/services`
available). In general this will not cause any deployment descriptors in
META-INF to be processed, with the exception of `beans.xml`. If a
`beans.xml` file is present this module will be scanned by Weld and any
resulting beans will be available to the application.
* `annotations` If a jandex index has be created for the module these
annotations will be merged into the deployments annotation index. The
https://github.com/jbossas/jandex[Jandex] index can be generated using
the
https://github.com/jbossas/jandex/blob/master/src/main/java/org/jboss/jandex/JandexAntTask.java[Jandex
ant task], and must be named `META-INF/jandex.idx`. Note that it is not
necessary to break open the jar being indexed to add this to the modules
class path, a better approach is to create a jar containing just this
index, and adding it as an additional resource root in the `module.xml`
file.

Adding a dependency to all modules in an EAR

[IMPORTANT]

Using the `export` parameter it is possible to add a dependency to all
sub deployments in an ear. If a module is exported from a
`Dependencies:` entry in the top level of the ear (or by a jar in the
`ear/lib` directory) it will be available to all sub deployments as
well.

[IMPORTANT]

To generate a MANIFEST.MF entry when using maven put the following in
your pom.xml:

pom.xml

[source,java]
----
<build>
   ...
   <plugins>
     <plugin>
       <groupId>org.apache.maven.plugins</groupId>
       <artifactId>maven-war-plugin</artifactId>
       <configuration>
          <archive>
             <manifestEntries>
                <Dependencies>org.slf4j</Dependencies>
             </manifestEntries>
          </archive>
       </configuration>
     </plugin>
   </plugins>
</build>
----

If your deployment is a jar you must use the `maven-jar-plugin` rather
than the `maven-war-plugin`.

[[class-path-entries]]
=== Class Path Entries

It is also possible to add module dependencies on other modules inside
the deployment using the `Class-Path` manifest entry. This can be used
within an ear to set up dependencies between sub deployments, and also
to allow modules access to additional jars deployed in an ear that are
not sub deployments and are not in the `EAR/lib` directory. If a jar in
the `EAR/lib` directory references a jar via `Class-Path:` then this
additional jar is merged into the parent ear's module, and is accessible
to all sub deployments in the ear.

[[global-modules]]
== Global Modules

It is also possible to set up global modules, that are accessible to all
deployments. This is done by modifying the configuration file
(standalone/domain.xml).

For example, to add javassist to all deployments you can use the
following XML:

standalone.xml/domain.xml

[source,java]
----
<subsystem xmlns="urn:jboss:domain:ee:1.0" >            
  <global-modules>
    <module name="org.javassist" slot="main" />            
  </global-modules> 
</subsystem>
----

Note that the `slot` field is optional and defaults to `main`.

[[jboss-deployment-structure-file]]
== JBoss Deployment Structure File

`jboss-deployment-structure.xml` is a JBoss specific deployment
descriptor that can be used to control class loading in a fine grained
manner. It should be placed in the top level deployment, in `META-INF`
(or `WEB-INF` for web deployments). It can do the following:

* Prevent automatic dependencies from being added
* Add additional dependencies
* Define additional modules
* Change an EAR deployments isolated class loading behaviour
* Add additional resource roots to a module

An example of a complete `jboss-deployment-structure.xml` file for an
ear deployment is as follows:

jboss-deployment-structure.xml

[source,java]
----
<jboss-deployment-structure>
  <!-- Make sub deployments isolated by default, so they cannot see each others classes without a Class-Path entry -->
  <ear-subdeployments-isolated>true</ear-subdeployments-isolated>
  <!-- This corresponds to the top level deployment. For a war this is the war's module, for an ear -->
  <!-- This is the top level ear module, which contains all the classes in the EAR's lib folder     -->
  <deployment>
     <!-- exclude-subsystem prevents a subsystems deployment unit processors running on a deployment -->
     <!-- which gives basically the same effect as removing the subsystem, but it only affects single deployment -->
     <exclude-subsystems>
        <subsystem name="resteasy" />
    </exclude-subsystems>
    <!-- Exclusions allow you to prevent the server from automatically adding some dependencies     -->
    <exclusions>
        <module name="org.javassist" />
    </exclusions>
    <!-- This allows you to define additional dependencies, it is the same as using the Dependencies: manifest attribute -->
    <dependencies>
      <module name="deployment.javassist.proxy" />
      <module name="deployment.myjavassist" />
      <!-- Import META-INF/services for ServiceLoader impls as well -->
      <module name="myservicemodule" services="import"/>
    </dependencies>
    <!-- These add additional classes to the module. In this case it is the same as including the jar in the EAR's lib directory -->
    <resources>
      <resource-root path="my-library.jar" />
    </resources>
  </deployment>
  <sub-deployment name="myapp.war">
    <!-- This corresponds to the module for a web deployment -->
    <!-- it can use all the same tags as the <deployment> entry above -->
    <dependencies>
      <!-- Adds a dependency on a ejb jar. This could also be done with a Class-Path entry -->
      <module name="deployment.myear.ear.myejbjar.jar" />
    </dependencies>
    <!-- Set's local resources to have the lowest priority -->
    <!-- If the same class is both in the sub deployment and in another sub deployment that -->
    <!-- is visible to the war, then the Class from the other deployment will be loaded,  -->
    <!-- rather than the class actually packaged in the war. -->
    <!-- This can be used to resolve ClassCastExceptions  if the same class is in multiple sub deployments-->
    <local-last value="true" />
  </sub-deployment>
  <!-- Now we are going to define two additional modules -->
  <!-- This one is a different version of javassist that we have packaged -->
  <module name="deployment.myjavassist" >
    <resources>
     <resource-root path="javassist.jar" >
       <!-- We want to use the servers version of javassist.util.proxy.* so we filter it out-->
       <filter>
         <exclude path="javassist/util/proxy" />
       </filter>
     </resource-root>
    </resources>
  </module>
  <!-- This is a module that re-exports the containers version of javassist.util.proxy -->
  <!-- This means that there is only one version of the Proxy classes defined          -->
  <module name="deployment.javassist.proxy" >
    <dependencies>
      <module name="org.javassist" >
        <imports>
          <include path="javassist/util/proxy" />
          <exclude path="/**" />
        </imports>
      </module>
    </dependencies>
  </module>
</jboss-deployment-structure>
----

[IMPORTANT]

The xsd for jboss-deployment-structure.xml is available at
https://github.com/wildfly/wildfly-core/blob/e737eff554ee433ca54835154fd67725fd52f63e/server/src/main/resources/schema/jboss-deployment-structure-1_2.xsd[https://github.com/wildfly/wildfly/blob/master/build/src/main/resources/docs/schema/jboss-deployment-structure-1_2.xsd]

[[accessing-jdk-classes]]
== Accessing JDK classes

Not all JDK classes are exposed to a deployment by default. If your
deployment uses JDK classes that are not exposed you can get access to
them using jboss-deployment-structure.xml with system dependencies:

Using jboss-deployment-structure.xml to access JDK classes

[source,java]
----
<jboss-deployment-structure xmlns="urn:jboss:deployment-structure:1.1">
    <deployment>
        <dependencies>
            <system export="true">
                <paths>
                    <path name="com/sun/corba/se/spi/legacy/connection"/>
                </paths>
            </system>
        </dependencies>
    </deployment>
</jboss-deployment-structure>
----

[[the-jboss.api-property-and-application-use-of-modules-shipped-with-wildfly]]
== The "jboss.api" property and application use of modules shipped with
WildFly

The WildFly distribution includes a large number of modules, a great
many of which are included for use by WildFly internals, with no testing
of the appropriateness of their direct use by applications or any
commitment to continue to ship those modules in future releases if they
are no longer needed by the internals. So how can a user know whether it
is advisable for their application to specify an explicit dependency on
a module WildFly ships? The "jboss.api" property specified in the
module's module.xml file can tell you:

Example declaration of the jboss.api property

[source,java]
----
<module xmlns="urn:jboss:module:1.3" name="com.google.guava">
    <properties>
        <property name="jboss.api" value="private"/>
    </properties>
----

If a module does not have a property element like the above, then it's
equivalent to one with a value of "public".

Following are the meanings of the various values you may see for the
jboss.api property:

[cols=",",]
|=======================================================================
|Value |Meaning

|public |May be explicitly depended upon by end user applications. Will
continue to be available in future releases within the same major series
and should not have incompatible API changes in future releases within
the same minor series, and ideally not within the same major series.

|private |Intended for internal use only. Only tested according to
internal usage. May not be safe for end user applications to use
directly.Could change significantly or be removed in a future release
without notice.

|unsupported |If you see this value in a module.xml in a WildFly
release, please file a bug report, as it is not applicable in WildFly.
In EAP it has a meaning equivalent to "private" but that does not mean
the module is "private" in WildFly; it could very easily be "public".

|preview |May be explicitly depended upon by end user applications, but
there are no guarantees of continued availability in future releases or
that there will not be incompatible API changes. This is not a common
classification in WildFly. It is not used in WildFly 10.

|deprecated |May be explicitly depended upon by end user applications.
Stable and reliable but an alternative should be sought. Will be removed
in a future major release.
|=======================================================================

Note that these definitions are only applicable to WildFly. In EAP and
other Red Hat products based on WildFly the same classifiers are used,
with generally similar meaning, but the precise meaning is per the
definitions on the Red Hat customer support portal.

If an application declares a direct dependency on a module marked
"private", "unsupported" or "deprecated", during deployment a WARN
message will be logged. The logging will be in log categories
"org.jboss.as.dependency.private", "org.jboss.as.dependency.unsupported"
and "org.jboss.as.dependency.deprecated" respectively. These categories
are not used for other purposes, so once you feel sufficiently warned
the logging can be safely suppressed by turning the log level for the
relevant category to ERROR or higher.

Other than the WARN messages noted above, declaring a direct dependency
on a non-public module has no impact on how WildFly processes the
deployment.

[[implicit-module-dependencies-for-deployments]]
= Implicit module dependencies for deployments

As explained in the link:#src-557207[Class Loading in WildFly] article,
WildFly 8 is based on module classloading. A class within a module B
isn't visible to a class within a module A, unless module B adds a
dependency on module A. Module dependencies can be explicitly (as
explained in that classloading article) or can be "implicit". This
article will explain what implicit module dependencies mean and how,
when and which modules are added as implicit dependencies.

[[whats-an-implicit-module-dependency]]
== What's an implicit module dependency?

Consider an application deployment which contains EJBs. EJBs typically
need access to classes from the javax.ejb.* package and other Java EE
API packages. The jars containing these packages are already shipped in
WildFly and are available as "modules". The module which contains the
javax.ejb.* classes has a specific name and so does the module which
contains all the Java EE API classes. For an application to be able to
use these classes, it has to add a dependency on the relevant modules.
Forcing the application developers to add module dependencies like these
(i.e. dependencies which can be "inferred") isn't a productive approach.
Hence, whenever an application is being deployed, the deployers within
the server, which are processing this deployment "implicitly" add these
module dependencies to the deployment so that these classes are visible
to the deployment at runtime. This way the application developer doesn't
have to worry about adding them explicitly. How and when these implicit
dependencies are added is explained in the next section.

[[how-and-when-is-an-implicit-module-dependency-added]]
== How and when is an implicit module dependency added?

When a deployment is being processed by the server, it goes through a
chain of "deployment processors". Each of these processors will have a
way to check if the deployment meets a certain criteria and if it does,
the deployment processor adds a implicit module dependency to that
deployment. Let's take an example - Consider (again) an EJB3 deployment
which has the following class:

MySuperDuperBean.java

[source,java]
----
@Stateless
public class MySuperDuperBean {
 
...
 
}
----

As can be seen, we have a simple @Stateless EJB. When the deployment
containing this class is being processed, the EJB deployment processor
will see that the deployment contains a class with the @Stateless
annotation and thus identifies this as a EJB deployment. *This is just
one of the several ways, various deployment processors can identify a
deployment of some specific type.* The EJB deployment processor will
then add an implicit dependency on the Java EE API module, so that all
the Java EE API classes are visible to the deployment.

Some subsystems will always add a API classes, even if the trigger
condition is not met. These are listed separately below.

In the next section, we'll list down the implicit module dependencies
that are added to a deployment, by various deployers within WildFly.

[[which-are-the-implicit-module-dependencies]]
== Which are the implicit module dependencies?

[cols=",,,",]
|=======================================================================
|Subsystem responsible for adding the implicit dependency |Dependencies
that are always added |Dependencies that are added if a trigger
condition is met |Trigger which leads to the implicit module dependency
being added

|Core Server |javax.api sun.jdk org.jboss.vfs |  | 

|Batch Subsystem |javax.batch.api |  | 

|EE Subsystem |javaee.api |  | 

|EJB3 subsystem |  |javaee.api |The presence of ejb-jar.xml (in valid
locations in the deployment, as specified by spec) or the presence of
annotation based EJBs (ex: @Stateless, @Stateful, @MessageDriven etc)

|JAX-RS (Resteasy) subsystem |javax.xml.bind.api
|org.jboss.resteasy.resteasy-atom-provider
org.jboss.resteasy.resteasy-cdi org.jboss.resteasy.resteasy-jaxrs
org.jboss.resteasy.resteasy-jaxb-provider
org.jboss.resteasy.resteasy-jackson-provider
org.jboss.resteasy.resteasy-jsapi
org.jboss.resteasy.resteasy-multipart-provider
org.jboss.resteasy.async-http-servlet-30 |The presence of JAX-RS
annotations in the deployment

|JCA subsystem |javax.resource.api |javax.jms.api javax.validation.api
org.jboss.logging org.jboss.ironjacamar.api org.jboss.ironjacamar.impl
org.hibernate.validator |If the deployment is a resource adaptor (RAR)
deployment.

|JPA (Hibernate) subsystem |javax.persistence.api |javaee.api
org.jboss.as.jpa org.hibernate |The presence of an @PersistenceUnit or
@PersistenceContext annotation, or a <persistence-unit-ref> or
<persistence-context-ref> in a deployment descriptor..

|Logging Subsystem |org.jboss.logging org.apache.commons.logging
org.apache.log4j org.slf4j org.jboss.logging.jul-to-slf4j-stub |  | 

|SAR Subsystem |  |org.jboss.logging org.jboss.modules |The deployment
is a SAR archive

|Security Subsystem |org.picketbox |  | 

|Web Subsystem |  |javaee.api com.sun.jsf-impl org.hibernate.validator
org.jboss.as.web org.jboss.logging |The deployment is a WAR archive. JSF
is only added if used. Multiple version options exist for mojarra.

|Web Services Subsystem |org.jboss.ws.api org.jboss.ws.spi |  | 

|Weld (CDI) Subsystem |  |javax.persistence.api javaee.api org.javassist
org.jboss.interceptor org.jboss.as.weld org.jboss.logging
org.jboss.weld.core org.jboss.weld.api org.jboss.weld.spi |If a
beans.xml file is detected in the deployment
|=======================================================================

[[ejb-invocations-from-a-remote-standalone-client-using-jndi]]
= EJB invocations from a remote standalone client using JNDI

This chapter explains how to invoke EJBs from a remote client by using
the JNDI API to first lookup the bean proxy and then invoke on that
proxy.

[IMPORTANT]

After you have read this article, do remember to take a look at
https://docs.jboss.org/author/display/WFLY8/Remote+EJB+invocations+via+JNDI+-+EJB+client+API+or+remote-naming+project[Remote
EJB invocations via JNDI - EJB client API or remote-naming project]

Before getting into the details, we would like the users to know that we
have introduced a new EJB client API, which is a WildFly-specific API
and allows invocation on remote EJBs. This client API isn't based on
JNDI. So remote clients need not rely on JNDI API to invoke on EJBs. A
separate document covering the EJB remote client API will be made
available. For now, you can refer to the javadocs of the EJB client
project at http://docs.jboss.org/ejbclient/. In this document, we'll
just concentrate on the traditional JNDI based invocation on EJBs. So
let's get started:

[[deploying-your-ejbs-on-the-server-side]]
== Deploying your EJBs on the server side:

[IMPORTANT]

Users who already have EJBs deployed on the server side can just skip to
the next section.

As a first step, you'll have to deploy your application containing the
EJBs on the Wildfly server. If you want those EJBs to be remotely
invocable, then you'll have to expose at least one remote view for that
bean. In this example, let's consider a simple Calculator stateless bean
which exposes a RemoteCalculator remote business interface. We'll also
have a simple stateful CounterBean which exposes a RemoteCounter remote
business interface. Here's the code:

[source,java]
----
package org.jboss.as.quickstarts.ejb.remote.stateless;
 
/**
 * @author Jaikiran Pai
 */
public interface RemoteCalculator {
 
    int add(int a, int b);
 
    int subtract(int a, int b);
}
----

[source,java]
----
package org.jboss.as.quickstarts.ejb.remote.stateless;
 
import javax.ejb.Remote;
import javax.ejb.Stateless;
 
/**
 * @author Jaikiran Pai
 */
@Stateless
@Remote(RemoteCalculator.class)
public class CalculatorBean implements RemoteCalculator {
 
    @Override
    public int add(int a, int b) {
        return a + b;
    }
 
    @Override
    public int subtract(int a, int b) {
        return a - b;
    }
}
----

[source,java]
----
package org.jboss.as.quickstarts.ejb.remote.stateful;
 
/**
 * @author Jaikiran Pai
 */
public interface RemoteCounter {
 
    void increment();
 
    void decrement();
 
    int getCount();
}
----

[source,java]
----
package org.jboss.as.quickstarts.ejb.remote.stateful;
 
import javax.ejb.Remote;
import javax.ejb.Stateful;
 
/**
 * @author Jaikiran Pai
 */
@Stateful
@Remote(RemoteCounter.class)
public class CounterBean implements RemoteCounter {
 
    private int count = 0;
 
    @Override
    public void increment() {
        this.count++;
    }
 
    @Override
    public void decrement() {
        this.count--;
    }
 
    @Override
    public int getCount() {
        return this.count;
    }
}
----

Let's package this in a jar (how you package it in a jar is out of scope
of this chapter) named "jboss-as-ejb-remote-app.jar" and deploy it to
the server. Make sure that your deployment has been processed
successfully and there aren't any errors.

[[writing-a-remote-client-application-for-accessing-and-invoking-the-ejbs-deployed-on-the-server]]
== Writing a remote client application for accessing and invoking the
EJBs deployed on the server

The next step is to write an application which will invoke the EJBs that
you deployed on the server. In WildFly, you can either choose to use the
WildFly specific EJB client API to do the invocation or use JNDI to
lookup a proxy for your bean and invoke on that returned proxy. In this
chapter we will concentrate on the JNDI lookup and invocation and will
leave the EJB client API for a separate chapter.

So let's take a look at what the client code looks like for looking up
the JNDI proxy and invoking on it. Here's the entire client code which
invokes on a stateless bean:

[source,java]
----
package org.jboss.as.quickstarts.ejb.remote.client;
 
import javax.naming.Context;
import javax.naming.InitialContext;
import javax.naming.NamingException;
import java.security.Security;
import java.util.Hashtable;
 
import org.jboss.as.quickstarts.ejb.remote.stateful.CounterBean;
import org.jboss.as.quickstarts.ejb.remote.stateful.RemoteCounter;
import org.jboss.as.quickstarts.ejb.remote.stateless.CalculatorBean;
import org.jboss.as.quickstarts.ejb.remote.stateless.RemoteCalculator;
import org.jboss.sasl.JBossSaslProvider;
 
/**
 * A sample program which acts a remote client for a EJB deployed on Wildfly 10 server.
 * This program shows how to lookup stateful and stateless beans via JNDI and then invoke on them
 *
 * @author Jaikiran Pai
 */
public class RemoteEJBClient {
 
    public static void main(String[] args) throws Exception {
        // Invoke a stateless bean
        invokeStatelessBean();
 
        // Invoke a stateful bean
        invokeStatefulBean();
    }
 
    /**
     * Looks up a stateless bean and invokes on it
     *
     * @throws NamingException
     */
    private static void invokeStatelessBean() throws NamingException {
        // Let's lookup the remote stateless calculator
        final RemoteCalculator statelessRemoteCalculator = lookupRemoteStatelessCalculator();
        System.out.println("Obtained a remote stateless calculator for invocation");
        // invoke on the remote calculator
        int a = 204;
        int b = 340;
        System.out.println("Adding " + a + " and " + b + " via the remote stateless calculator deployed on the server");
        int sum = statelessRemoteCalculator.add(a, b);
        System.out.println("Remote calculator returned sum = " + sum);
        if (sum != a + b) {
            throw new RuntimeException("Remote stateless calculator returned an incorrect sum " + sum + " ,expected sum was " + (a + b));
        }
        // try one more invocation, this time for subtraction
        int num1 = 3434;
        int num2 = 2332;
        System.out.println("Subtracting " + num2 + " from " + num1 + " via the remote stateless calculator deployed on the server");
        int difference = statelessRemoteCalculator.subtract(num1, num2);
        System.out.println("Remote calculator returned difference = " + difference);
        if (difference != num1 - num2) {
            throw new RuntimeException("Remote stateless calculator returned an incorrect difference " + difference + " ,expected difference was " + (num1 - num2));
        }
    }
 
    /**
     * Looks up a stateful bean and invokes on it
     *
     * @throws NamingException
     */
    private static void invokeStatefulBean() throws NamingException {
        // Let's lookup the remote stateful counter
        final RemoteCounter statefulRemoteCounter = lookupRemoteStatefulCounter();
        System.out.println("Obtained a remote stateful counter for invocation");
        // invoke on the remote counter bean
        final int NUM_TIMES = 20;
        System.out.println("Counter will now be incremented " + NUM_TIMES + " times");
        for (int i = 0; i < NUM_TIMES; i++) {
            System.out.println("Incrementing counter");
            statefulRemoteCounter.increment();
            System.out.println("Count after increment is " + statefulRemoteCounter.getCount());
        }
        // now decrementing
        System.out.println("Counter will now be decremented " + NUM_TIMES + " times");
        for (int i = NUM_TIMES; i > 0; i--) {
            System.out.println("Decrementing counter");
            statefulRemoteCounter.decrement();
            System.out.println("Count after decrement is " + statefulRemoteCounter.getCount());
        }
    }
 
    /**
     * Looks up and returns the proxy to remote stateless calculator bean
     *
     * @return
     * @throws NamingException
     */
    private static RemoteCalculator lookupRemoteStatelessCalculator() throws NamingException {
        final Hashtable jndiProperties = new Hashtable();
        jndiProperties.put(Context.URL_PKG_PREFIXES, "org.jboss.ejb.client.naming");
        final Context context = new InitialContext(jndiProperties);
        // The app name is the application name of the deployed EJBs. This is typically the ear name
        // without the .ear suffix. However, the application name could be overridden in the application.xml of the
        // EJB deployment on the server.
        // Since we haven't deployed the application as a .ear, the app name for us will be an empty string
        final String appName = "";
        // This is the module name of the deployed EJBs on the server. This is typically the jar name of the
        // EJB deployment, without the .jar suffix, but can be overridden via the ejb-jar.xml
        // In this example, we have deployed the EJBs in a jboss-as-ejb-remote-app.jar, so the module name is
        // jboss-as-ejb-remote-app
        final String moduleName = "jboss-as-ejb-remote-app";
        // AS7 allows each deployment to have an (optional) distinct name. We haven't specified a distinct name for
        // our EJB deployment, so this is an empty string
        final String distinctName = "";
        // The EJB name which by default is the simple class name of the bean implementation class
        final String beanName = CalculatorBean.class.getSimpleName();
        // the remote view fully qualified class name
        final String viewClassName = RemoteCalculator.class.getName();
        // let's do the lookup
        return (RemoteCalculator) context.lookup("ejb:" + appName + "/" + moduleName + "/" + distinctName + "/" + beanName + "!" + viewClassName);
    }
 
    /**
     * Looks up and returns the proxy to remote stateful counter bean
     *
     * @return
     * @throws NamingException
     */
    private static RemoteCounter lookupRemoteStatefulCounter() throws NamingException {
        final Hashtable jndiProperties = new Hashtable();
        jndiProperties.put(Context.URL_PKG_PREFIXES, "org.jboss.ejb.client.naming");
        final Context context = new InitialContext(jndiProperties);
        // The app name is the application name of the deployed EJBs. This is typically the ear name
        // without the .ear suffix. However, the application name could be overridden in the application.xml of the
        // EJB deployment on the server.
        // Since we haven't deployed the application as a .ear, the app name for us will be an empty string
        final String appName = "";
        // This is the module name of the deployed EJBs on the server. This is typically the jar name of the
        // EJB deployment, without the .jar suffix, but can be overridden via the ejb-jar.xml
        // In this example, we have deployed the EJBs in a jboss-as-ejb-remote-app.jar, so the module name is
        // jboss-as-ejb-remote-app
        final String moduleName = "jboss-as-ejb-remote-app";
        // AS7 allows each deployment to have an (optional) distinct name. We haven't specified a distinct name for
        // our EJB deployment, so this is an empty string
        final String distinctName = "";
        // The EJB name which by default is the simple class name of the bean implementation class
        final String beanName = CounterBean.class.getSimpleName();
        // the remote view fully qualified class name
        final String viewClassName = RemoteCounter.class.getName();
        // let's do the lookup (notice the ?stateful string as the last part of the jndi name for stateful bean lookup)
        return (RemoteCounter) context.lookup("ejb:" + appName + "/" + moduleName + "/" + distinctName + "/" + beanName + "!" + viewClassName + "?stateful");
    }
}
----

[IMPORTANT]

The entire server side and client side code is hosted at the github repo
here
https://github.com/wildfly/quickstart/tree/master/ejb-remote[ejb-remote]

The code has some comments which will help you understand each of those
lines. But we'll explain here in more detail what the code does. As a
first step in the client code, we'll do a lookup of the EJB using a JNDI
name. In AS7, for remote access to EJBs, you use the ejb: namespace with
the following syntax:

*For stateless beans:*

[source,java]
----
ejb:<app-name>/<module-name>/<distinct-name>/<bean-name>!<fully-qualified-classname-of-the-remote-interface>
----

*For stateful beans:*

[source,java]
----
ejb:<app-name>/<module-name>/<distinct-name>/<bean-name>!<fully-qualified-classname-of-the-remote-interface>?stateful
----

The ejb: namespace identifies it as a EJB lookup and is a constant (i.e.
doesn't change) for doing EJB lookups. The rest of the parts in the jndi
name are as follows:

*app-name* : This is the name of the .ear (without the .ear suffix) that
you have deployed on the server and contains your EJBs.

* Java EE 6 allows you to override the application name, to a name of
your choice by setting it in the application.xml. If the deployment uses
uses such an override then the app-name used in the JNDI name should
match that name.
* EJBs can also be deployed in a .war or a plain .jar (like we did in
step 1). In such cases where the deployment isn't an .ear file, then the
app-name must be an empty string, while doing the lookup.

*module-name* : This is the name of the .jar (without the .jar suffix)
that you have deployed on the server and the contains your EJBs. If the
EJBs are deployed in a .war then the module name is the .war name
(without the .war suffix).

* Java EE 6 allows you to override the module name, by setting it in the
ejb-jar.xml/web.xml of your deployment. If the deployment uses such an
override then the module-name used in the JNDI name should match that
name.
* Module name part cannot be an empty string in the JNDI name

*distinct-name* : This is a WildFly-specific name which can be
optionally assigned to the deployments that are deployed on the server.
More about the purpose and usage of this will be explained in a separate
chapter. If a deployment doesn't use distinct-name then, use an empty
string in the JNDI name, for distinct-name

*bean-name* : This is the name of the bean for which you are doing the
lookup. The bean name is typically the unqualified classname of the bean
implementation class, but can be overriden through either ejb-jar.xml or
via annotations. The bean name part cannot be an empty string in the
JNDI name.

*fully-qualified-classname-of-the-remote-interface* : This is the fully
qualified class name of the interface for which you are doing the
lookup. The interface should be one of the remote interfaces exposed by
the bean on the server. The fully qualified class name part cannot be an
empty string in the JNDI name.

For stateful beans, the JNDI name expects an additional "?stateful" to
be appended after the fully qualified interface name part. This is
because for stateful beans, a new session gets created on JNDI lookup
and the EJB client API implementation doesn't contact the server during
the JNDI lookup to know what kind of a bean the JNDI name represents
(we'll come to this in a while). So the JNDI name itself is expected to
indicate that the client is looking up a stateful bean, so that an
appropriate session can be created.

Now that we know the syntax, let's see our code and check what JNDI name
it uses. Since our stateless EJB named CalculatorBean is deployed in a
jboss-as-ejb-remote-app.jar (without any ear) and since we are looking
up the org.jboss.as.quickstarts.ejb.remote.stateless.RemoteCalculator
remote interface, our JNDI name will be:

[source,java]
----
ejb:/jboss-as-ejb-remote-app//CalculatorBean!org.jboss.as.quickstarts.ejb.remote.stateless.RemoteCalculator
----

That's what the lookupRemoteStatelessCalculator() method in the above
client code uses.

For the stateful EJB named CounterBean which is deployed in hte same
jboss-as-ejb-remote-app.jar and which exposes the
org.jboss.as.quickstarts.ejb.remote.stateful.RemoteCounter, the JNDI
name will be:

[source,java]
----
ejb:/jboss-as-ejb-remote-app//CounterBean!org.jboss.as.quickstarts.ejb.remote.stateful.RemoteCounter?stateful
----

That's what the lookupRemoteStatefulCounter() method in the above client
code uses.

Now that we know of the JNDI name, let's take a look at the following
piece of code in the lookupRemoteStatelessCalculator():

[source,java]
----
final Hashtable jndiProperties = new Hashtable();
jndiProperties.put(Context.URL_PKG_PREFIXES, "org.jboss.ejb.client.naming");
final Context context = new InitialContext(jndiProperties);
----

Here we are creating a JNDI InitialContext object by passing it some
JNDI properties. The Context.URL_PKG_PREFIXES is set to
org.jboss.ejb.client.naming. This is necessary because we should let the
JNDI API know what handles the ejb: namespace that we use in our JNDI
names for lookup. The "org.jboss.ejb.client.naming" has a
URLContextFactory implementation which will be used by the JNDI APIs to
parse and return an object for ejb: namespace lookups. You can either
pass these properties to the constructor of the InitialContext class or
have a jndi.properites file in the classpath of the client application,
which (atleast) contains the following property:

[source,java]
----
java.naming.factory.url.pkgs=org.jboss.ejb.client.naming
----

So at this point, we have setup the InitialContext and also have the
JNDI name ready to do the lookup. You can now do the lookup and the
appropriate proxy which will be castable to the remote interface that
you used as the fully qualified class name in the JNDI name, will be
returned. Some of you might be wondering, how the JNDI implementation
knew which server address to look, for your deployed EJBs. The answer is
in AS7, the proxies returned via JNDI name lookup for ejb: namespace do
not connect to the server unless an invocation on those proxies is done.

Now let's get to the point where we invoke on this returned proxy:

[source,java]
----
// Let's lookup the remote stateless calculator
        final RemoteCalculator statelessRemoteCalculator = lookupRemoteStatelessCalculator();
        System.out.println("Obtained a remote stateless calculator for invocation");
        // invoke on the remote calculator
        int a = 204;
        int b = 340;
        System.out.println("Adding " + a + " and " + b + " via the remote stateless calculator deployed on the server");
        int sum = statelessRemoteCalculator.add(a, b);
----

We can see here that the proxy returned after the lookup is used to
invoke the add(...) method of the bean. It's at this point that the JNDI
implementation (which is backed by the EJB client API) needs to know the
server details. So let's now get to the important part of setting up the
EJB client context properties.

[[setting-up-ejb-client-context-properties]]
== Setting up EJB client context properties

A EJB client context is a context which contains contextual information
for carrying out remote invocations on EJBs. This is a WildFly-specific
API. The EJB client context can be associated with multiple EJB
receivers. Each EJB receiver is capable of handling invocations on
different EJBs. For example, an EJB receiver "Foo" might be able to
handle invocation on a bean identified by
app-A/module-A/distinctinctName-A/Bar!RemoteBar, whereas a EJB receiver
named "Blah" might be able to handle invocation on a bean identified by
app-B/module-B/distinctName-B/BeanB!RemoteBean. Each such EJB receiver
knows about what set of EJBs it can handle and each of the EJB receiver
knows which server target to use for handling the invocations on the
bean. For example, if you have a AS7 server at 10.20.30.40 IP address
which has its remoting port opened at 4447 and if that's the server on
which you deployed that CalculatorBean, then you can setup a EJB
receiver which knows its target address is 10.20.30.40:4447. Such an EJB
receiver will be capable enough to communicate to the server via the
JBoss specific EJB remote client protocol (details of which will be
explained in-depth in a separate chapter).

Now that we know what a EJB client context is and what a EJB receiver
is, let's see how we can setup a client context with 1 EJB receiver
which can connect to 10.20.30.40 IP address at port 4447. That EJB
client context will then be used (internally) by the JNDI implementation
to handle invocations on the bean proxy.

The client will have to place a jboss-ejb-client.properties file in the
classpath of the application. The jboss-ejb-client.properties can
contain the following properties:

[source,java]
----
endpoint.name=client-endpoint
remote.connectionprovider.create.options.org.xnio.Options.SSL_ENABLED=false
 
remote.connections=default
 
remote.connection.default.host=10.20.30.40
remote.connection.default.port = 8080
remote.connection.default.connect.options.org.xnio.Options.SASL_POLICY_NOANONYMOUS=false
 
remote.connection.default.username=appuser
remote.connection.default.password=apppassword
----

[IMPORTANT]

This file includes a reference to a default password. Be sure to change
this as soon as possible.

The above properties file is just an example. The actual file that was
used for this sample program is available here for reference
https://github.com/wildfly/quickstart/blob/master/ejb-remote/client/src/main/resources/jboss-ejb-client.properties[jboss-ejb-client.properties]

[IMPORTANT]

We'll see what each of it means.

First the endpoint.name property. We mentioned earlier that the EJB
receivers will communicate with the server for EJB invocations.
Internally, they use JBoss Remoting project to carry out the
communication. The endpoint.name property represents the name that will
be used to create the client side of the enpdoint. The endpoint.name
property is optional and if not specified in the
jboss-ejb-client.properties file, it will default to
"config-based-ejb-client-endpoint" name.

Next is the remote.connectionprovider.create.options.<....> properties:

[source,java]
----
remote.connectionprovider.create.options.org.xnio.Options.SSL_ENABLED=false
----

The "remote.connectionprovider.create.options." property prefix can be
used to pass the options that will be used while create the connection
provider which will handle the "remote:" protocol. In this example we
use the "remote.connectionprovider.create.options." property prefix to
pass the "org.xnio.Options.SSL_ENABLED" property value as false. That
property will then be used during the connection provider creation.
Similarly other properties can be passed too, just append it to the
"remote.connectionprovider.create.options." prefix

Next we'll see:

[source,java]
----
remote.connections=default
----

This is where you define the connections that you want to setup for
communication with the remote server. The "remote.connections" property
uses a comma separated value of connection "names". The connection names
are just logical and are used grouping together the connection
configuration properties later on in the properties file. The example
above sets up a single remote connection named "default". There can be
more than one connections that are configured. For example:

[source,java]
----
remote.connections=one, two
----

Here we are listing 2 connections named "one" and "two". Ultimately,
each of the connections will map to a EJB receiver. So if you have 2
connections, that will setup 2 EJB receivers that will be added to the
EJB client context. Each of these connections will be configured with
the connection specific properties as follows:

[source,java]
----
remote.connection.default.host=10.20.30.40
remote.connection.default.port = 8080
remote.connection.default.connect.options.org.xnio.Options.SASL_POLICY_NOANONYMOUS=false
----

As you can see we are using the "remote.connection.<connection-name>."
prefix for specifying the connection specific property. The connection
name here is "default" and we are setting the "host" property of that
connection to point to 10.20.30.40. Similarly we set the "port" for that
connection to 4447.

By default WildFly uses 8080 as the remoting port. The EJB client API
uses the http port, with the http-upgrade functionality, for
communicating with the server for remote invocations, so that's the port
we use in our client programs (unless the server is configured for some
other http port)

[IMPORTANT]

[source,java]
----
remote.connection.default.username=appuser
remote.connection.default.password=apppassword
----

The given user/password must be set by using the command bin/add-user.sh
﻿(or.bat). +
The user and password must be set because the security-realm is enabled
for the subsystem remoting (see standalone*.xml or domain.xml) by
default. +
If you do not need the security for remoting you might remove the
attribute security-realm in the configuration.

security-realm is enabled by default.

[IMPORTANT]

We then use the "remote.connection.<connection-name>.connect.options."
property prefix to setup options that will be used during the connection
creation.

Here's an example of setting up multiple connections with different
properties for each of those:

[source,java]
----
remote.connectionprovider.create.options.org.xnio.Options.SSL_ENABLED=false
 
remote.connections=one, two
 
remote.connection.one.host=localhost
remote.connection.one.port=6999
remote.connection.one.connect.options.org.xnio.Options.SASL_POLICY_NOANONYMOUS=false
 
remote.connection.two.host=localhost
remote.connection.two.port=7999
remote.connection.two.connect.options.org.xnio.Options.SASL_POLICY_NOANONYMOUS=false
----

As you can see we setup 2 connections "one" and "two" which both point
to "localhost" as the "host" but different ports. Each of these
connections will internally be used to create the EJB receivers in the
EJB client context.

So that's how the jboss-ejb-client.properties file can be setup and
placed in the classpath.

[[section]]
====

The EJB client code will by default look for jboss-ejb-client.properties
in the classpath. However, you can specify a different file of your
choice by setting the "jboss.ejb.client.properties.file.path" system
property which points to a properties file on your filesystem,
containing the client context configurations. An example for that would
be
"-Djboss.ejb.client.properties.file.path=/home/me/my-client/custom-jboss-ejb-client.properties"

[[section-1]]
====

A jboss-client jar is shipped in the distribution. It's available at
WILDFLY_HOME/bin/client/jboss-client.jar. Place this jar in the
classpath of your client application.

If you are using Maven to build the client application, then please
follow the instructions in the WILDFLY_HOME/bin/client/README.txt to add
this jar as a Maven dependency.

[IMPORTANT]

[[summary]]
== Summary

In the above examples, we saw what it takes to invoke a EJB from a
remote client. To summarize:

* On the server side you need to deploy EJBs which expose the remote
views.
* On the client side you need a client program which:
** Has a jboss-ejb-client.properties in its classpath to setup the
server connection information
** Either has a jndi.properties to specify the
java.naming.factory.url.pkgs property or passes that as a property to
the InitialContext constructor
** Setup the client classpath to include the jboss-client jar that's
required for remote invocation of the EJBs. The location of the jar is
mentioned above. You'll also need to have your application's bean
interface jars and other jars that are required by your application, in
the client classpath

[[ejb-invocations-from-a-remote-server]]
= EJB invocations from a remote server

The purpose of this chapter is to demonstrate how to lookup and invoke
on EJBs deployed on an WildFly server instance *from another* WildFly
server instance. This is different from invoking the EJBs
https://docs.jboss.org/author/display/AS71/EJB+invocations+from+a+remote+client+using+JNDI[from
a remote standalone client]

Let's call the server, from which the invocation happens to the EJB, as
"Client Server" and the server on which the bean is deployed as the
"Destination Server".

[IMPORTANT]

Note that this chapter deals with the case where the bean is deployed on
the "Destination Server" but *not* on the "Client Server".

[[application-packaging]]
== Application packaging

In this example, we'll consider a EJB which is packaged in a myejb.jar
which is within a myapp.ear. Here's how it would look like:

[source,java]
----
myapp.ear
|
|---- myejb.jar
|        |
|        |---- <org.myapp.ejb.*> // EJB classes
----

[IMPORTANT]

Note that packaging itself isn't really important in the context of this
article. You can deploy the EJBs in any standard way (.ear, .war or
.jar).

[[beans]]
== Beans

In our example, we'll consider a simple stateless session bean which is
as follows:

[source,java]
----
package org.myapp.ejb;
 
public interface Greeter {
    
    String greet(String user);
}
----

[source,java]
----
package org.myapp.ejb;
 
import javax.ejb.Remote;
import javax.ejb.Stateless;
 
@Stateless
@Remote (Greeter.class)
public class GreeterBean implements Greeter {
 
    @Override
    public String greet(String user) {
        return "Hello " + user + ", have a pleasant day!";
    }
}
----

[[security]]
== Security

WildFly 8 is secure by default. What this means is that no communication
can happen with an WildFly instance from a remote client (irrespective
of whether it is a standalone client or another server instance) without
passing the appropriate credentials. Remember that in this example, our
"client server" will be communicating with the "destination server". So
in order to allow this communication to happen successfully, we'll have
to configure user credentials which we will be using during this
communication. So let's start with the necessary configurations for
this.

[[configuring-a-user-on-the-destination-server]]
== Configuring a user on the "Destination Server"

As a first step we'll configure a user on the destination server who
will be allowed to access the destination server. We create the user
using the `add-user` script that's available in the JBOSS_HOME/bin
folder. In this example, we'll be configuring a `Application User` named
`ejb` and with a password `test` in the `ApplicationRealm`. Running the
`add-user` script is an interactive process and you will see
questions/output as follows:

add-user

[source,java]
----
jpai@jpai-laptop:bin$ ./add-user.sh
 
What type of user do you wish to add?
&nbsp;a) Management User (mgmt-users.properties)
&nbsp;b) Application User (application-users.properties)
(a): b
 
Enter the details of the new user to add.
Realm (ApplicationRealm) :
Username : ejb
Password :
Re-enter Password :
What roles do you want this user to belong to? (Please enter a comma separated list, or leave blank for none)\[&nbsp; \]:
About to add user 'ejb' for realm 'ApplicationRealm'
Is this correct yes/no? yes
Added user 'ejb' to file '/jboss-as-7.1.1.Final/standalone/configuration/application-users.properties'
Added user 'ejb' to file '/jboss-as-7.1.1.Final/domain/configuration/application-users.properties'
Added user 'ejb' with roles to file '/jboss-as-7.1.1.Final/standalone/configuration/application-roles.properties'
Added user 'ejb' with roles to file '/jboss-as-7.1.1.Final/domain/configuration/application-roles.properties'
----

As you can see in the output above we have now configured a user on the
destination server who'll be allowed to access this server. We'll use
this user credentials later on in the client server for communicating
with this server. The important bits to remember are the user we have
created in this example is `ejb` and the password is `test.`

[IMPORTANT]

Note that you can use any username and password combination you want to.

[IMPORTANT]

You do *not* require the server to be started to add a user using the
add-user script.

[[start-the-destination-server]]
== Start the "Destination Server"

As a next step towards running this example, we'll start the
"Destination Server". In this example, we'll use the standalone server
and use the _standalone-full.xml_ configuration. The startup command
will look like:

[source,java]
----
./standalone.sh -server-config=standalone-full.xml
----

Ensure that the server has started without any errors.

[IMPORTANT]

It's very important to note that if you are starting both the server
instances on the same machine, then each of those server instances
*must* have a unique `jboss.node.name` system property. You can do that
by passing an appropriate value for `-Djboss.node.name` system property
to the startup script:

[source,java]
----
./standalone.sh -server-config=standalone-full.xml -Djboss.node.name=<add appropriate value here>
----

[[deploying-the-application]]
== Deploying the application

The application ( _myapp.ear_ in our case) will be deployed to
"Destination Server". The process of deploying the application is out of
scope of this chapter. You can either use the Command Line Interface or
the Admin console or any IDE or manually copy it to
JBOSS_HOME/standalone/deployments folder (for standalone server). Just
ensure that the application has been deployed successfully.

So far, we have built a EJB application and deployed it on the
"Destination Server". Now let's move to the "Client Server" which acts
as the client for the deployed EJBs on the "Destination Server".

[[configuring-the-client-server-to-point-to-the-ejb-remoting-connector-on-the-destination-server]]
== Configuring the "Client Server" to point to the EJB remoting
connector on the "Destination Server"

As a first step on the "Client Server", we need to let the server know
about the "Destination Server"'s EJB remoting connector, over which it
can communicate during the EJB invocations. To do that, we'll have to
add a " _remote-outbound-connection_" to the remoting subsystem on the
"Client Server". The " _remote-outbound-connection_" configuration
indicates that a outbound connection will be created to a remote server
instance from that server. The " _remote-outbound-connection_" will be
backed by a " _outbound-socket-binding_" which will point to a remote
host and a remote port (of the "Destination Server"). So let's see how
we create these configurations.

[[start-the-client-server]]
== Start the "Client Server"

In this example, we'll start the "Client Server" on the same machine as
the "Destination Server". We have copied the entire server installation
to a different folder and while starting the "Client Server" we'll use a
port-offset (of 100 in this example) to avoid port conflicts:

[source,java]
----
./standalone.sh -server-config=standalone-full.xml -Djboss.socket.binding.port-offset=100
----

[[create-a-security-realm-on-the-client-server]]
== Create a security realm on the client server

Remember that we need to communicate with a secure destination server.
In order to do that the client server has to pass the user credentials
to the destination server. Earlier we created a user on the destination
server who'll be allowed to communicate with that server. Now on the
"client server" we'll create a security-realm which will be used to pass
the user information.

In this example we'll use a security realm which stores a Base64 encoded
password and then passes on that credentials when asked for. Earlier we
created a user named `ejb` and password `test`. So our first task here
would be to create the base64 encoded version of the password `test`.
You can use any utility which generates you a base64 version for a
string. I used http://www.base64encode.org/[this online site] which
generates the base64 encoded string. So for the `test` password, the
base64 encoded version is `dGVzdA==`

[IMPORTANT]

While generating the base64 encoded string make sure that you don't have
any trailing or leading spaces for the original password. That can lead
to incorrect encoded versions being generated.

[IMPORTANT]

With new versions the add-user script will show the base64 password if
you type 'y' if you've been ask

[source,java]
----
Is this new user going to be used for one AS process to connect to another AS process e.g. slave domain controller?
----

Now that we have generated that base64 encoded password, let's use in
the in the security realm that we are going to configure on the "client
server". I'll first shutdown the client server and edit the
standalone-full.xml file to add the following in the `<management>`
section

Now let's create a " _security-realm_" for the base64 encoded password.

[source,java]
----
/core-service=management/security-realm=ejb-security-realm:add()
/core-service=management/security-realm=ejb-security-realm/server-identity=secret:add(value=dGVzdA==)
----

[IMPORTANT]

Notice that the CLI show the message _"process-state" =>
"reload-required"_, so you have to restart the server before you can use
this change.

upon successful invocation of this command, the following configuration
will be created in the _management_ section:

standalone-full.xml

[source,java]
----
<management>
        <security-realms>
            ...
            <security-realm name="ejb-security-realm">
                <server-identities>
                    <secret value="dGVzdA=="/>
                </server-identities>
            </security-realm>
        </security-realms>
...
----

As you can see I have created a security realm named
"ejb-security-realm" (you can name it anything) with the base64 encoded
password. So that completes the security realm configuration for the
client server. Now let's move on to the next step.

[[create-a-outbound-socket-binding-on-the-client-server]]
== Create a outbound-socket-binding on the "Client Server"

Let's first create a _outbound-socket-binding_ which points the
"Destination Server"'s host and port. We'll use the CLI to create this
configuration:

[source,java]
----
/socket-binding-group=standard-sockets/remote-destination-outbound-socket-binding=remote-ejb:add(host=localhost, port=8080)
----

The above command will create a outbound-socket-binding named "
_remote-ejb_" (we can name it anything) which points to "localhost" as
the host and port 8080 as the destination port. Note that the host
information should match the host/IP of the "Destination Server" (in
this example we are running on the same machine so we use "localhost")
and the port information should match the http-remoting connector port
used by the EJB subsystem (by default it's 8080). When this command is
run successfully, we'll see that the standalone-full.xml (the file which
we used to start the server) was updated with the following
outbound-socket-binding in the socket-binding-group:

[source,java]
----
<socket-binding-group name="standard-sockets" default-interface="public" port-offset="${jboss.socket.binding.port-offset:0}">
        ...
        <outbound-socket-binding name="remote-ejb">
            <remote-destination host="localhost" port="8080"/>
        </outbound-socket-binding>
    </socket-binding-group>
----

[[create-a-remote-outbound-connection-which-uses-this-newly-created-outbound-socket-binding]]
== Create a "remote-outbound-connection" which uses this newly created
"outbound-socket-binding"

Now let's create a " _remote-outbound-connection_" which will use the
newly created outbound-socket-binding (pointing to the EJB remoting
connector of the "Destination Server"). We'll continue to use the CLI to
create this configuration:

[source,java]
----
/subsystem=remoting/remote-outbound-connection=remote-ejb-connection:add(outbound-socket-binding-ref=remote-ejb, protocol=http-remoting, security-realm=ejb-security-realm, username=ejb)
----

The above command creates a remote-outbound-connection, named "
_remote-ejb-connection_" (we can name it anything), in the remoting
subsystem and uses the previously created " _remote-ejb_"
outbound-socket-binding (notice the outbound-socket-binding-ref in that
command) with the http-remoting protocol. Furthermore, we also set the
security-realm attribute to point to the security-realm that we created
in the previous step. Also notice that we have set the username
attribute to use the user name who is allowed to communicate with the
destination server.

What this step does is, it creates a outbound connection, on the client
server, to the remote destination server and sets up the username to the
user who allowed to communicate with that destination server and also
sets up the security-realm to a pre-configured security-realm capable of
passing along the user credentials (in this case the password). This way
when a connection has to be established from the client server to the
destination server, the connection creation logic will have the
necessary security credentials to pass along and setup a successful
secured connection.

Now let's run the following two operations to set some default
connection creation options for the outbound connection:

[source,java]
----
/subsystem=remoting/remote-outbound-connection=remote-ejb-connection/property=SASL_POLICY_NOANONYMOUS:add(value=false)
----

[source,java]
----
/subsystem=remoting/remote-outbound-connection=remote-ejb-connection/property=SSL_ENABLED:add(value=false)
----

Ultimately, upon successful invocation of this command, the following
configuration will be created in the remoting subsystem:

[source,java]
----
<subsystem xmlns="urn:jboss:domain:remoting:1.1">
....
            <outbound-connections>
                <remote-outbound-connection name="remote-ejb-connection" outbound-socket-binding-ref="remote-ejb" protocol="http-remoting" security-realm="ejb-security-realm" username="ejb">
                    <properties>
                        <property name="SASL_POLICY_NOANONYMOUS" value="false"/>
                        <property name="SSL_ENABLED" value="false"/>
                    </properties>
                </remote-outbound-connection>
            </outbound-connections>
        </subsystem>
----

From a server configuration point of view, that's all we need on the
"Client Server". Our next step is to deploy an application on the
"Client Server" which will invoke on the bean deployed on the
"Destination Server".

[[packaging-the-client-application-on-the-client-server]]
== Packaging the client application on the "Client Server"

Like on the "Destination Server", we'll use .ear packaging for the
client application too. But like previously mentioned, that's not
mandatory. You can even use a .war or .jar deployments. Here's how our
client application packaging will look like:

[source,java]
----
client-app.ear
|
|--- META-INF
|        |
|        |--- jboss-ejb-client.xml
|
|--- web.war
|        |
|        |--- WEB-INF/classes
|        |        |
|        |        |---- <org.myapp.FooServlet> // classes in the web app
----

In the client application we'll use a servlet which invokes on the bean
deployed on the "Destination Server". We can even invoke the bean on the
"Destination Server" from a EJB on the "Client Server". The code remains
the same (JNDI lookup, followed by invocation on the proxy). The
important part to notice in this client application is the file
_jboss-ejb-client.xml_ which is packaged in the META-INF folder of a top
level deployment (in this case our client-app.ear). This
_jboss-ejb-client.xml_ contains the EJB client configurations which will
be used during the EJB invocations for finding the appropriate
destinations (also known as, EJB receivers). The contents of the
jboss-ejb-client.xml are explained next.

[IMPORTANT]

If your application is deployed as a top level .war deployment, then the
jboss-ejb-client.xml is expected to be placed in .war/WEB-INF/ folder
(i.e. the same location where you place any web.xml file).

[[contents-on-jboss-ejb-client.xml]]
== Contents on jboss-ejb-client.xml

The jboss-ejb-client.xml will look like:

[source,java]
----
<jboss-ejb-client xmlns="urn:jboss:ejb-client:1.0">
    <client-context>
        <ejb-receivers>
            <remoting-ejb-receiver outbound-connection-ref="remote-ejb-connection"/>
        </ejb-receivers>
    </client-context>
</jboss-ejb-client>
----

You'll notice that we have configured the EJB client context (for this
application) to use a remoting-ejb-receiver which points to our earlier
created " _remote-outbound-connection_" named "
_remote-ejb-connection_". This links the EJB client context to use the "
_remote-ejb-connection_" which ultimately points to the EJB remoting
connector on the "Destination Server".

[[deploy-the-client-application]]
== Deploy the client application

Let's deploy the client application on the "Client Server". The process
of deploying the application is out of scope, of this chapter. You can
use either the CLI or the admin console or a IDE or deploy manually to
JBOSS_HOME/standalone/deployments folder. Just ensure that the
application is deployed successfully.

[[client-code-invoking-the-bean]]
== Client code invoking the bean

We mentioned that we'll be using a servlet to invoke on the bean, but
the code to invoke the bean isn't servlet specific and can be used in
other components (like EJB) too. So let's see how it looks like:

[source,java]
----
import javax.naming.Context;
import java.util.Hashtable;
import javax.naming.InitialContext;
 
...
public void invokeOnBean() {
        try {
            final Hashtable props = new Hashtable();
            // setup the ejb: namespace URL factory
            props.put(Context.URL_PKG_PREFIXES, "org.jboss.ejb.client.naming");
            // create the InitialContext
            final Context context = new javax.naming.InitialContext(props);
 
            // Lookup the Greeter bean using the ejb: namespace syntax which is explained here https://docs.jboss.org/author/display/AS71/EJB+invocations+from+a+remote+client+using+JNDI
            final Greeter bean = (Greeter) context.lookup("ejb:" + "myapp" + "/" + "myejb" + "/" + "" + "/" + "GreeterBean" + "!" + org.myapp.ejb.Greeter.class.getName());
 
   // invoke on the bean
   final String greeting = bean.greet("Tom");
 
            System.out.println("Received greeting: " + greeting);
 
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
}
----

That's it! The above code will invoke on the bean deployed on the
"Destination Server" and return the result.

[[remote-ejb-invocations-via-jndi---which-approach-to-use]]
= Remote EJB invocations via JNDI - Which approach to use?

[[purpose]]
= Purpose

WildFly provides EJB client API project as well as remote-naming project
for invoking on remote objects exposed via JNDI. This article explains
which approach to use when and what the differences and scope of each of
these projects is.

[[history]]
= History

Previous versions of JBoss AS (versions < WildFly 8) used JNP project (
http://anonsvn.jboss.org/repos/jbossas/projects/naming/) as the JNDI
naming implementation. Developers of client applications of previous
versions of JBoss AS will be familiar with the `jnp:// PROVIDER_URL` URL
they used to use in their applications for communicating with the JNDI
server on the JBoss server.

Starting WildFly 8, the JNP project is _not_ used. Neither on the server
side nor on the client side. The client side of the JNP project has now
been replaced by jboss-remote-naming project (
https://github.com/jbossas/jboss-remote-naming). There were various
reasons why the JNP client was replaced by jboss-remote-naming project.
One of them was the JNP project did not allow fine grained security
configurations while communicating with the JNDI server. The
jboss-remote-naming project is backed by the jboss-remoting project (
https://github.com/jboss-remoting/jboss-remoting) which allows much more
and better control over security.

[[overview]]
= Overview

Now that we know that for remote client JNDI communication with WildFly
8 requires jboss-remote-naming project, let's quickly see what the code
looks like.

[[client-code-relying-on-jndi.properties-in-classpath]]
== Client code relying on jndi.properties in classpath

[source,java]
----
void doLookup() {
  // Create an InitialContext using the javax.naming.* API
  Context ctx = new InitialContext();
  ctx.lookup("foo/bar");
  ...
}
----

As you can see, there's not much here in terms of code. We first create
a InitialContext (
http://download.oracle.com/javase/6/docs/api/javax/naming/InitialContext.html)
which as per the API will look for a jndi.properties in the classpath of
the application. We'll see what our jndi.properties looks like, later.
Once the InitialContext is created, we just use it to do a lookup on a
JNDI name which we know is bound on the server side. We'll come back to
the details of this lookup string in a while.

Let's now see what the jndi.properties in our client classpath looks
like:

[source,java]
----
java.naming.factory.initial=org.jboss.naming.remote.client.InitialContextFactory
java.naming.provider.url=http-remoting://localhost:8080
----

Those 2 properties are important for jboss-remote-naming project to be
used for communicating with the WildFly server. The first property tells
the JNDI API which initial context factory to use. In this case we are
pointing it to the InitailContextFactory class supplied by the
jboss-remote-naming project. The other property is the PROVIDER_URL.
Developers familiar with previous JBoss AS versions would remember that
they used `jnp://localhost:1099` (just an example). In WildFly, the URI
protocol scheme for jboss-remote-naming project is `remote://`. The rest
of the PROVIDER_URL part is the server hostname or IP and the port on
which the remoting connector is exposed on the server side. By default
the http-remoting connector port in WildFly 8 is 8080. That's what we
have used in our example. The hostname we have used is localhost but
that should point to the server IP or hostname where the server is
running.

[IMPORTANT]

JNP client project in previous AS versions allowed a comma separated
list for PROVIDER_URL value, so that if one of the server isn't
accessible then the JNDI API would use the next available server. The
jboss-remote-naming project has similar support starting 1.0.3.Final
version of that project (which is available in a WildFly release *after*
7.1.1.Final).

WildFly 8 can use the PROVIDER_URL like:

java.naming.provider.url=http-remoting://server1:8080,http-remoting://server2:8080

So we saw how to setup the JNDI properties in the jndi.properties file.
The JNDI API also allows you to pass these properties to the constructor
of the InitialContext class (please check the javadoc of that class for
more details). Let's quickly see what the code would look like:

[source,java]
----
void doLookup() {
  Properties jndiProps = new Properties();
  jndiProps.put(Context.INITIAL_CONTEXT_FACTORY, "org.jboss.naming.remote.client.InitialContextFactory");
  jndiProps.put(Context.PROVIDER_URL,"http-remoting://localhost:8080");
  // create a context passing these properties
  Context ctx = new InitialContext(jndiProps);
  // lookup
  ctx.lookup("foo/bar");
  ...
}
----

That's it! You can see that the values that we pass to those properties
are the same as what we did via the jndi.properties. It's upto the
client application to decide which approach they want to follow.

[[how-does-remoting-naming-work]]
== How does remoting naming work

We have so far had an overview of how the client code looks like when
using the jboss-remote-naming (henceforth referred to as remote-naming -
too tired of typing jboss-remote-naming everytime
image:images/s/en_GB/7202/8bb4a7d7a43e6723fe7875221f32b3124c55e6e1/_/images/icons/emoticons/wink0.png[images/s/en_GB/7202/8bb4a7d7a43e6723fe7875221f32b3124c55e6e1/_/images/icons/emoticons/wink0.png]
) project. Let's now have a brief look at how the remote-naming project
internally establishes the communication with the server and allows JNDI
operations from the client side.

Like previously mentioned, remote-naming internally uses jboss-remoting
project. When the client code creates an InitialContext backed by the
org.jboss.naming.remote.client.InitialContextFactory class, the
`org.jboss.naming.remote.client.InitialContextFactory` internally looks
for the PROVIDER_URL (and other) properties that are applicable for that
context ( _doesn't_ matter whether it comes from the jndi.properties
file or whether passed explicitly to the constructor of the
InitialContext). Once it identifies the server and port to connect to,
the remote-naming project internally sets up a connection using the
jboss-remoting APIs with the remoting connector which is exposed on that
port.

We previously mentioned that remote-naming, backed by jboss-remoting
project, has increased support for security configurations. Starting
WildFly 8, every service including the http remoting connector (which
listens by default on port 8080), is secured (see
https://community.jboss.org/wiki/AS710Beta1-SecurityEnabledByDefault for
details). This means that when trying to do JNDI operations like a
lookup, the client has to pass appropriate user credentials. In our
examples so far we haven't passed any username/pass or any other
credentials while creating the InitialContext. That was just to keep the
examples simple. But let's now take the code a step further and see one
of the ways how we pass the user credentials. Let's at the moment just
assume that the remoting connector on port 8080 is accessible to a user
named " `peter`" whose password is expected to be " `lois`".

[IMPORTANT]

Note: The server side configurations for the remoting connector to allow
"peter" to access the connector, is out of the scope of this
documentation. The WildFly 8 documentation already has chapters on how
to set that up.

[source,java]
----
void doLookup() {
  Properties jndiProps = new Properties();
  jndiProps.put(Context.INITIAL_CONTEXT_FACTORY, "org.jboss.naming.remote.client.InitialContextFactory");
  jndiProps.put(Context.PROVIDER_URL,"http-remoting://localhost:8080");
  // username
  jndiProps.put(Context.SECURITY_PRINCIPAL, "peter");
  // password
  jndiProps.put(Context.SECURITY_CREDENTIALS, "lois");
  // create a context passing these properties
  Context ctx = new InitialContext(jndiProps);
  // lookup
  ctx.lookup("foo/bar");
  ...
}
----

The code is similar to our previous example, except that we now have
added 2 additional properties that are passed to the InitialContext
constructor. The first is
http://docs.oracle.com/javase/6/docs/api/javax/naming/Context.html#SECURITY_PRINCIPAL
which passes the username (peter in this case) and the second is
http://docs.oracle.com/javase/6/docs/api/javax/naming/Context.html#SECURITY_CREDENTIALS
which passes the password (lois in this case). Of course the same
properties can be configured in the jndi.properties file (read the
javadoc of the Context class for appropriate properties to be used in
the jndi.properties). This is one way of passing the security
credentials for JNDI communication with WildFly. There are some other
ways to do this too. But we won't go into those details here for two
reasons. One, it's outside the scope of this article and two (which is
kind of the real reason) I haven't looked fully at the remote-naming
implementation details to see what other ways are allowed.

[[jndi-operations-allowed-using-remote-naming-project]]
== JNDI operations allowed using remote-naming project

So far we have mainly concentrated on how the naming context is created
and what it internally does when an instance is created. Let's now take
this one step further and see what kind of operations are allowed for a
JNDI context backed by the remote-naming project.

The JNDI Context has various methods
http://docs.oracle.com/javase/6/docs/api/javax/naming/Context.html that
are exposed for JNDI operations. One important thing to note in case of
remote-naming project is that, the project's scope is to allow a client
to communicate with the JNDI backend exposed by the server. As such, the
remote-naming project does *not* support many of the methods that are
exposed by the javax.naming.Context class. The remote-naming project
only supports the read-only kind of methods (like the lookup() method)
and does not support any write kind of methods (like the bind() method).
The client applications are expected to use the remote-naming project
mainly for lookups of JNDI objects. Neither WildFly 8 nor remote-naming
project allows writing/binding to the JNDI server from a remote
application.

[[pre-requisites-of-remotely-accessible-jndi-objects]]
== Pre-requisites of remotely accessible JNDI objects

On the server side, the JNDI can contain numerous objects that are bound
to it. However, _not_ all of those are exposed remotely. The two
conditions that are to be satisfied by the objects bound to JNDI, to be
remotely accessible are:

\1) Such objects should be bound under the `java:jboss/exported/`
namespace. For example, `java:jboss/exported/foo/bar` +
2) Objects bound to the `java:jboss/exported/` namespace are expected to
be serializable. This allows the objects to be sent over the wire to the
remote clients

Both these conditions are important and are required for the objects to
be remotely accessible via JNDI.

[[jndi-lookup-strings-for-remote-clients-backed-by-the-remote-naming-project]]
== JNDI lookup strings for remote clients backed by the remote-naming
project

In our examples, so far, we have been consistently using " `foo/bar`" as
the JNDI name to lookup from a remote client using the remote-naming
project. There's a bit more to understand about the JNDI name and how it
maps to the JNDI name that's bound on the server side.

First of all, the JNDI names used while using the remote-naming project
are *always* relative to the java:jboss/exported/ namespace. So in our
examples, we are using " `foo/bar`" JNDI name for the lookup, that
actually is (internally) " `java:jboss/exported/foo/bar`". The
remote-naming project expects it to *always* be relative to the "
`java:jboss/exported/`" namespace. Once connected with the server side,
the remote-naming project will lookup for "foo/bar" JNDI name under the
" `java:jboss/exported/`" namespace of the server.

[IMPORTANT]

Note: Since the JNDI name that you use on the client side is *always*
relative to java:jboss/exported namespace, you *shouldn't* be prefixing
the java:jboss/exported/ string to the JNDI name. For example, if you
use the following JNDI name:

ctx.lookup("java:jboss/exported/helloworld");

then remote-naming will translate it to

ctx.lookup("java:jboss/exported/java:jboss/exported/helloworld");

and as a result, will fail during lookup.

The remote-naming implementation perhaps should be smart enough to strip
off the java:jboss/exported/ namespace prefix if supplied. But let's not
go into that here.

[[how-does-remote-naming-project-implementation-transfer-the-jndi-objects-to-the-clients]]
== How does remote-naming project implementation transfer the JNDI
objects to the clients

When a lookup is done on a JNDI string, the remote-naming implementation
internally uses the connection to the remoting connector (which it has
established based on the properties that were passed to the
InitialContext) to communicate with the server. On the server side, the
implementation then looks for the JNDI name under the
`java:jboss/exported/` namespace. Assuming that the JNDI name is
available, under that namespace, the remote-naming implementation then
passes over the object bound at that address to the client. This is
where the requirement about the JNDI object being serializable comes
into picture. remote-naming project internally uses jboss-marshalling
project to marshal the JNDI object over to the client. On the client
side the remote-naming implementation then unmarshalles the object and
returns it to the client application.

So literally, each lookup backed by the remote-naming project entails a
server side communication/interaction and then marshalling/unmarshalling
of the object graph. This is very important to remember. We'll come back
to this later, to see why this is important when it comes to using EJB
client API project for doing EJB lookups ( link:#src-557207[EJB
invocations from a remote client using JNDI]) as against using
remote-naming project for doing the same thing.

[[summary-1]]
= Summary

That pretty much covers whatever is important to know, in the
remote-naming project, for a typical client application. Don't close the
browser yet though, since we haven't yet come to the part of EJB
invocations from a remote client using the remote-naming project. In
fact, the motivation behind writing this article was to explain why
_not_ to use remote-naming project (in most cases) for doing EJB
invocations against WildFly server.

Those of you who don't have client applications doing remote EJB
invocations, can just skip the rest of this article if you aren't
interested in those details.

[[remote-ejb-invocations-backed-by-the-remote-naming-project]]
= Remote EJB invocations backed by the remote-naming project

In previous sections of this article we saw that whatever is exposed in
the java:jboss/exported/ namespace is accessible remotely to the client
applications under the relative JNDI name. Some of you might already
have started thinking about exposing remote views of EJBs under that
namespace.

It's important to note that WildFly server side already by default
exposes the remote views of a EJB under the `java:jboss/exported/`
namespace (although it isn't logged in the server logs). So assuming
your server side application has the following stateless bean:

[source,java]
----
package org.myapp.ejb;
 
@Stateless
@Remote(Foo.class)
public class FooBean implements Foo {
...
 public String sayBar() {
     return "Baaaaaaaar";
 }
}
----

Then the " `Foo`" remote view is exposed under the
`java:jboss/exported/` namespace under the following JNDI name scheme
(which is similar to that mandated by EJB3.1 spec for `java:global/`
namespace):
link:/pages/createpage.action?spaceKey=WFLY&title=app-name&linkCreation=true&fromPageId=557285[app-name]

`app-name/module-name/bean-name!bean-interface`

where,

`app-name` = the name of the .ear (without the .ear suffix) or the
application name configured via application.xml deployment descriptor.
If the application isn't packaged in a .ear then there will be *no*
app-name part to the JNDI string. +
`module-name` = the name of the .jar or .war (without the .jar/.war
suffix) in which the bean is deployed or the module-name configured in
web.xml/ejb-jar.xml of the deployment. The module name is mandatory part
in the JNDI string. +
`bean-name` = the name of the bean which by default is the simple name
of the bean implementation class. Of course it can be overridden either
by using the "name" attribute of the bean definining annotation
(@Stateless(name="blah") in this case) or even the ejb-jar.xml
deployment descriptor. +
`bean-interface` = the fully qualified class name of the interface being
exposed by the bean.

So in our example above, let's assume the bean is packaged in a
myejbmodule.jar which is within a myapp.ear. So the JNDI name for the
Foo remote view under the `java:jboss/exported/` namespace would be:

`java:jboss/exported/myapp/myejbmodule/FooBean!org.myapp.ejb.Foo`

That's where WildFly will *automatically* expose the remote views of the
EJBs under the `java:jboss/exported/` namespace, *in addition to* the
java:global/ java:app/ java:module/ namespaces mandated by the EJB 3.1
spec.

[IMPORTANT]

Note that only the java:jboss/exported/ namespace is available to remote
clients.

So the next logical question would be, are these remote views of EJBs
accessible and invokable using the remote-naming project on the client
application. The answer is _yes_! Let's quickly see the client code for
invoking our `FooBean`. Again, let's just use " `peter`" and " `lois`"
as username/pass for connecting to the remoting connector.

[source,java]
----
void doBeanLookup() {
  ...
  Properties jndiProps = new Properties();
  jndiProps.put(Context.INITIAL_CONTEXT_FACTORY, "org.jboss.naming.remote.client.InitialContextFactory");
  jndiProps.put(Context.PROVIDER_URL,"http-remoting://localhost:8080");
  // username
  jndiProps.put(Context.SECURITY_PRINCIPAL, "peter");
  // password
  jndiProps.put(Context.SECURITY_CREDENTIALS, "lois");
  // This is an important property to set if you want to do EJB invocations via the remote-naming project
  jndiProps.put("jboss.naming.client.ejb.context", true);
  // create a context passing these properties
  Context ctx = new InitialContext(jndiProps);
  // lookup the bean     Foo
  beanRemoteInterface = (Foo) ctx.lookup("myapp/myejbmodule/FooBean!org.myapp.ejb.Foo");
  String bar = beanRemoteInterface.sayBar();
  System.out.println("Remote Foo bean returned " + bar);
  ctx.close();
  // after this point the beanRemoteInterface is not longer valid!
}
----

As you can see, most of the code is similar to what we have been seeing
so far for setting up a JNDI context backed by the remote-naming
project. The only parts that change are:

\1) An additional " `jboss.naming.client.ejb.context`" property that is
added to the properties passed to the InitialContext constructor. +
2) The JNDI name used for the lookup +
3) And subsequently the invocation on the bean interface returned by the
lookup.

Let's see what the " `jboss.naming.client.ejb.context`" does. In
WildFly, remote access/invocations on EJBs is facilitated by the JBoss
specific EJB client API, which is a project on its own
https://github.com/jbossas/jboss-ejb-client. So no matter, what
mechanism you use (remote-naming or core EJB client API), the
invocations are ultimately routed through the EJB client API project. In
this case too, the remote-naming internally uses EJB client API to
handle EJB invocations. From a EJB client API project perspective, for
successful communication with the server, the project expects a
`EJBClientContext` backed by (atleast one) `EJBReceiver`(s). The
`EJBReceiver` is responsible for handling the EJB invocations. One type
of a `EJBReceiver` is a `RemotingConnectionEJBReceiver` which internally
uses jboss-remoting project to communicate with the remote server to
handle the EJB invocations. Such a `EJBReceiver` expects a connection
backed by the jboss-remoting project. Of course to be able to connect to
the server, such a `EJBReceiver` would have to know the server address,
port, security credentials and other similar parameters. If you were
using the core EJB client API, then you would have configured all these
properties via the jboss-ejb-client.properties or via programatic API
usage as explained here link:#src-557207[EJB invocations from a remote
client using JNDI]. But in the example above, we are using remote-naming
project and are _not_ directly interacting with the EJB client API
project.

If you look closely at what's being passed, via the JNDI properties, to
the remote-naming project and if you remember the details that we
explained in a previous section about how the remote-naming project
establishes a connection to the remote server, you'll realize that these
properties are indeed the same as what the
`RemotingConnectionEJBReceiver` would expect to be able to establish the
connection to the server. Now this is where the "
`jboss.naming.client.ejb.context`" property comes into picture. When
this is set to true and passed to the InitialContext creation (either
via jndi.properties or via the constructor of that class), the
remote-naming project internally will do whatever is necessary to setup
a `EJBClientContext`, containing a `RemotingConnectionEJBReceiver` which
is created using the *same* remoting connection that is created by and
being used by remote-naming project for its own JNDI communication
usage. So effectively, the InitialContext creation via the remote-naming
project has now internally triggered the creation of a
`EJBClientContext` containing a `EJBReceiver` capable of handling the
EJB invocations (remember, no remote EJB invocations are possible
without the presence of a `EJBClientContext` containing a `EJBReceiver`
which can handle the EJB).

So we now know the importance of the "
`jboss.naming.client.ejb.context`" property and its usage. Let's move on
the next part in that code, the JNDI name. Notice that we have used the
JNDI name relative to the `java:jboss/exported/` namespace while doing
the lookup. And since we know that the Foo view is exposed on that JNDI
name, we cast the returned object back to the Foo interface. Remember
that we earlier explained how each lookup via remote-naming triggers a
server side communication and a marshalling/unmarshalling process. This
applies for EJB views too. In fact, the remote-naming project has no
clue (since that's not in the scope of that project to know) whether
it's an EJB or some random object.

Once the unmarshalled object is returned (which actually is a proxy to
the bean), the rest is straightforward, we just invoke on that returned
object. Now since the remote-naming implementation has done the
necessary setup for the EJBClientContext (due to the presence of "
`jboss.naming.client.ejb.context`" property), the invocation on that
proxy will internally use the `EJBClientContext` (the proxy is smart
enough to do that) to interact with the server and return back the
result. We won't go into the details of how the EJB client API handles
the communication/invocation.

_Long story short, using the remote-naming project for doing remote EJB
invocations against WildFly is possible!_

[[why-use-the-ejb-client-api-approach-then]]
= Why use the EJB client API approach then?

I can guess that some of you might already question why/when would one
use the EJB client API style lookups as explained in the
link:#src-557207[EJB invocations from a remote client using JNDI]
article instead of just using (what appears to be a simpler)
remote-naming style lookups.

Before we answer that, let's understand a bit about the EJB client
project. The EJB client project was implemented keeping in mind various
optimizations and features that would be possible for handling remote
invocations. One such optimization was to avoid doing unnecessary server
side communication(s) which would typically involve network calls,
marshalling/unmarshalling etc... The easiest place where this
optimization can be applied, is to the EJB lookup. Consider the
following code (let's ignore how the context is created):

[source,java]
----
ctx.lookup("foo/bar");
----

Now `foo/bar` JNDI name could potentially point to *any* type of object
on the server side. The jndi name itself won't have the type/semantic
information of the object bound to that name on the server side. If the
context was setup using the remote-naming project (like we have seen
earlier in our examples), then the only way for remote-naming to return
an object for that lookup operation is to communicate with the server
and marshal/unmarshal the object bound on the server side. And that's
exactly what it does (remember, we explained this earlier).

The EJB client API project on the other hand optimizes this lookup. In
order to do so, it expects the client application to let it know that a
EJB is being looked up. It does this, by expecting the client
application to use the JNDI name of the format " `ejb:`" namespace and
also expecting the client application to setup the JNDI context by
passing the " `org.jboss.ejb.client.naming`" value for the
`Context.URL_PKG_PREFIXES` property.

Example:

[source,java]
----
final Properties jndiProperties = new Properties();
jndiProperties.put(Context.URL_PKG_PREFIXES, "org.jboss.ejb.client.naming");
// create the context
final Context context = new InitialContext(jndiProperties);
 
// lookup
Foo beanProxy = context.lookup("ejb:myapp/myejbmodule//FooBean!org.myapp.ejb.Foo");
String bar = beanProxy.sayBar();
----

More details about such code can be found here link:#src-557207[EJB
invocations from a remote client using JNDI]

When a client application looks up anything under the " `ejb:`"
namespace, it is a clear indication (for the EJB client API project) to
know that the client is looking up an EJB. That's where it steps in to
do the necessary optimizations that might be applicable. So unlike, in
the case of remote-naming project (which has no clue about the semantics
of the object being looked up), the EJB client API project does *not*
trigger a server side communication or a marshal/unmarshal process when
you do lookup for a remote view of a stateless bean (it's important to
note that we have specifically mentioned stateless bean here, we'll come
to that later). Instead, the EJB client API just returns a
java.lang.reflect.Proxy instance of the remote view type that's being
looked up. This not just saves a network call, marshalling/unmarshalling
step but it also means that you can create an EJB proxy even when the
server isn't up yet. Later on, when the invocation on the proxy happens,
the EJB client API _does_ communicate with the server to carry out the
invocation.

[[is-the-lookup-optimization-applicable-for-all-bean-types]]
== Is the lookup optimization applicable for all bean types?

In the previous section we (intentionally) mentioned that the lookup
optimization by the EJB client API project happens for stateless beans.
This kind of optimization is *not* possible for stateful beans because
in case of stateful beans, a lookup is expected to create a session for
that stateful bean and for session creation we do have to communicate
with the server since the server is responsible for creating that
session.

That's exactly why the EJB client API project expects the JNDI name
lookup string for stateful beans to include the " `?stateful`" string at
the end of the JNDI name:

[source,java]
----
context.lookup("ejb:myapp/myejbmodule//StatefulBean!org.myapp.ejb.Counter?stateful");
----

Notice the use of `"?stateful`" in that JNDI name. See
link:#src-557207[EJB invocations from a remote client using JNDI] for
more details about such lookup.

The presence of " `?stateful`" in the JNDI name lookup string is a
directive to the EJB client API to let it know that a stateful bean is
being looked up and it's necessary to communicate with the server and
create a session during that lookup.

So as you can see, we have managed to optimize certain operations by
using the EJB client API for EJB lookup/invocation as against using the
remote-naming project. There are other EJB client API implementation
details (and probably more might be added) which are superior when it is
used for remote EJB invocations in client applications as against
remote-naming project which doesn't have the intelligence to carry out
such optimizations for EJB invocations. _That's why the remote-naming
project_ *_for remote EJB invocations_* _is considered "_ `deprecated`
_"_. Note that if you want to use remote-naming for looking up and
invoking on non-EJB remote objects then you are free to do so. In fact,
that's why that project has been provided. You can even use the
remote-naming project for EJB invocations (like we just saw), if you are
fine with _not_ wanting the optimizations that the EJB client API can do
for you or if you have other restrictions that force you to use that
project.

[[restrictions-for-ejbs]]
== Restrictions for EJB's

If the remote-naming is used there are some restrictions as there is no
full support of the ejb-client features.

* No loadbalancing, if the URL conatains multiple "remote://" servers
there is no loadbalancing, the first available server will be used and
only in case it is not longer available there will be a failover to the
next available one.
* No cluster support. As a cluster needs to be defined in the
jboss-ejb-client.properties this feature can not be used and there is no
cluster node added
* No client side interceptor. The EJBContext.getCurrent() can not be
used and it is not possible to add a client interceptor
* No UserTransaction support
* All proxies become invalid if .close() for the related Initalcontext
is invoked, or the InitialContext is not longer referenced and gets
garbage-collected. In this case the underlying EJBContext is destroyed
and the conections are closed.
* It is not possible to use remote-naming if the client is an
application deployed on another JBoss instance

[[jboss-ejb-3-reference-guide]]
= JBoss EJB 3 reference guide

This chapter details the extensions that are available when developing
Enterprise Java Beans ^tm^ on WildFly 8.

Currently there is no support for configuring the extensions using an
implementation specific descriptor file.

[[resource-adapter-for-message-driven-beans]]
== Resource Adapter for Message Driven Beans

Each Message Driven Bean must be connected to a resource adapter.

[[specification-of-resource-adapter-using-metadata-annotations]]
=== Specification of Resource Adapter using Metadata Annotations

The `ResourceAdapter` annotation is used to specify the resource adapter
with which the MDB should connect.

The `value` of the annotation is the name of the deployment unit
containing the resource adapter. For example `jms-ra.rar`.

For example:

[source,java]
----
@MessageDriven(messageListenerInterface = PostmanPat.class)
@ResourceAdapter("ejb3-rar.rar")
----

[[run-as-principal]]
== Run-as Principal

Whenever a run-as role is specified for a given method invocation the
default anonymous principal is used as the caller principal. This
principal can be overridden by specifying a run-as principal.

[[specification-of-run-as-principal-using-metadata-annotations]]
=== Specification of Run-as Principal using Metadata Annotations

The `RunAsPrincipal` annotation is used to specify the run-as principal
to use for a given method invocation.

The `value` of the annotation specifies the name of the principal to
use. The actual type of the principal is undefined and should not be
relied upon.

Using this annotation without specifying a run-as role is considered an
error.

For example:

[source,java]
----
@RunAs("admin")
@RunAsPrincipal("MyBean")
----

[[security-domain]]
== Security Domain

Each Enterprise Java Bean ^tm^ can be associated with a security domain.
Only when an EJB is associated with a security domain will
authentication and authorization be enforced.

[[specification-of-security-domain-using-metadata-annotations]]
=== Specification of Security Domain using Metadata Annotations

The `SecurityDomain` annotation is used to specify the security domain
to associate with the EJB.

The `value` of the annotation is the name of the security domain to be
used.

For example:

[source,java]
----
@SecurityDomain("other")
----

[[transaction-timeout]]
== Transaction Timeout

For any newly started transaction a transaction timeout can be specified
in seconds.

When a transaction timeout of `0` is used, then the actual transaction
timeout will default to the domain configured default. +
_TODO: add link to tx subsystem_

Although this is only applicable when using transaction attribute
`REQUIRED` or `REQUIRES_NEW` the application server will not detect
invalid setups.

New Transactions

[IMPORTANT]

Take care that even when transaction attribute `REQUIRED` is specified,
the timeout will only be applicable if a *new* transaction is started.

[[specification-of-transaction-timeout-with-metadata-annotations]]
=== Specification of Transaction Timeout with Metadata Annotations

The `TransactionTimeout` annotation is used to specify the transaction
timeout for a given method.

The `value` of the annotation is the timeout used in the given `unit`
granularity. It must be a positive integer or 0. Whenever 0 is specified
the default domain configured timeout is used.

The `unit` specifies the granularity of the `value`. The actual value
used is converted to seconds. Specifying a granularity lower than
`SECONDS` is considered an error, even when the computed value will
result in an even amount of seconds.

For example:@TransactionTimeout(value = 10, unit = TimeUnit.SECONDS)

[[specification-of-transaction-timeout-in-the-deployment-descriptor]]
=== Specification of Transaction Timeout in the Deployment Descriptor

The `trans-timeout` element is used to define the transaction timeout
for business, home, component, and message-listener interface methods;
no-interface view methods; web service endpoint methods; and timeout
callback methods.

The `trans-timeout` element resides in the `urn:trans-timeout` namespace
and is part of the standard `container-transaction` element as defined
in the jboss namespace.

For the rules when a `container-transaction` is applicable please refer
to EJB 3.1 FR 13.3.7.2.1.

[[example-of-trans-timeout]]
==== Example of trans-timeout

jboss-ejb3.xml

[source,java]
----
<jboss:ejb-jar xmlns:jboss="http://www.jboss.com/xml/ns/javaee"
               xmlns="http://java.sun.com/xml/ns/javaee"
               xmlns:tx="urn:trans-timeout"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
               xsi:schemaLocation="http://www.jboss.com/xml/ns/javaee http://www.jboss.org/j2ee/schema/jboss-ejb3-2_0.xsd
http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/ejb-jar_3_1.xsd
urn:trans-timeout http://www.jboss.org/j2ee/schema/trans-timeout-1_0.xsd"
               version="3.1"
               impl-version="2.0">
    <assembly-descriptor>
        <container-transaction>
            <method>
                <ejb-name>BeanWithTimeoutValue</ejb-name>
                <method-name>*</method-name>
                <method-intf>Local</method-intf>
            </method>
            <tx:trans-timeout>
                <tx:timeout>10</tx:timeout>
                <tx:unit>Seconds</tx:unit>
            </tx:trans-timeout>
        </container-transaction>
    </assembly-descriptor>
</jboss:ejb-jar>
----

[[timer-service]]
== Timer service

The service is responsible to call the registered timeout methods of the
different session beans.

[IMPORTANT]

A persistent timer will be identified by the name of the EAR, the name
of the sub-deployment JAR and the Bean's name. +
If one of those names are changed (e.g. EAR name contain a version) the
timer entry became orphaned and the timer event will not longer be
fired.

[[single-event-timer]]
=== Single event timer

The timer is will be started once at the specified time.

In case of a server restart the timeout method of a persistent timer
will only be called directly if the specified time is elapsed. +
If the timer is not persistent (since EJB3.1 see 18.2.3) it will be not
longer available if JBoss is restarted or the application is redeployed.

[[recurring-timer]]
=== Recurring timer

The timer will be started at the specified first occurrence and after
that point at each time if the interval is elapsed. +
If the timer will be started during the last execution is not finished
the execution will be suppressed with a warning to avoid concurrent
execution.

In case of server downtime for a persistent timer, the timeout method
will be called only once if one, or more than one, interval is
elapsed. +
If the timer is not persistent (since EJB3.1 see 18.2.3) it will not
longer be active after the server is restarted or the application is
redeployed.

[[calendar-timer]]
=== Calendar timer

The timer will be started if the schedule expression match. It will be
automatically deactivated and removed if there will be no next
expiration possible, i.e. If you set a specific year.

For example:

________________________________________________________
@Schedule( ... dayOfMonth="1", month="1", year="2012") +
// start once at 01-01-2012 00:00:00
________________________________________________________

[[programmatic-calendar-timer]]
==== Programmatic calendar timer

If the timer is persistent it will be fetched at server start and the
missed timeouts are called concurrent. +
If a persistent timer contains an end date it will be executed once
nevertheless how many times the execution was missed. Also a retry will
be suppressed if the timeout method throw an Exception. +
In case of such expired timer access to the given Timer object might
throw a NoMoreTimeoutExcption or NoSuchObjectException.

If the timer is non persistent it will not longer be active after the
server is restarted or the application is redeployed.

*TODO*: clarify whether this should happen concurrently/blocked or even
fired only once like a recurring timer!

[[annotated-calendar-timer]]
==== Annotated calendar timer

If the timer is non persistent it will not activated for missed events
during the server is down. In case of server start the timer is
scheduled based on the @Schedule annotation.

If the timer is persistent (default if not deactivated by annotation)
all missed events are fetched at server start and the annotated timeout
method is called concurrent.

*TODO*: clarify whether this should happen concurrently/blocked or even
fired only once like a recurring timer!

[[jpa-reference-guide]]
= JPA reference guide

[[introduction]]
== Introduction

The WildFly JPA subsystem implements the JPA 2.1 container-managed
requirements. Deploys the persistence unit definitions, the persistence
unit/context annotations and persistence unit/context references in the
deployment descriptor. JPA Applications use the Hibernate (version 5.1)
persistence provider, which is included with WildFly. The JPA subsystem
uses the standard SPI (javax.persistence.spi.PersistenceProvider) to
access the Hibernate persistence provider and some additional extensions
as well.

During application deployment, JPA use is detected (e.g. persistence.xml
or @PersistenceContext/Unit annotations) and injects Hibernate
dependencies into the application deployment. This makes it easy to
deploy JPA applications.

In the remainder of this documentation, "entity manager" refers to an
instance of the _javax.persistence.EntityManager_ class.
http://download.oracle.com/javaee/7/api/javax/persistence/package-summary.html[Javadoc
for the JPA interfaces]and https://jcp.org/en/jsr/detail?id=338[JPA 2.1
specification].

The index of the Hibernate documentation is at
http://hibernate.org/orm/documentation/5.1/.

[[update-your-persistence.xml-for-hibernate-5.1]]
== Update your Persistence.xml for Hibernate 5.1

The persistence provider class name in Hibernate 4.3.0 (and greater) is
*org.hibernate.jpa.HibernatePersistenceProvider*.

Instead of specifying:

*<provider>org.hibernate.ejb.HibernatePersistence</provider>*

Switch to:

*<provider>org.hibernate.jpa.HibernatePersistenceProvider</provider>*

Or remove the persistence provider class name from your persistence.xml
(so the default provider will be used).

[[entity-manager]]
== Entity manager

The entity manager (javax.persistence.EntityManager class) is similar to
the Hibernate Session class; applications use it to
create/read/update/delete data (and related operations). Applications
can use application-managed or container-managed entity managers. Keep
in mind that the entity manager is not thread safe, don't share the same
entity manager instance with multiple threads.

Internally, the entity manager, has a persistence context for managing
entities. You can think of the persistence context as being closely
associated with the entity manager.

[[container-managed-entity-manager]]
== Container-managed entity manager

When you inject a container-managed entity managers into an application
variable, it is treated like an (EE container controlled) Java proxy
object, that will be associated with an underlying EntityManager
instance, for each started JTA transaction and is flushed/closed when
the JTA transaction commits. Such that when your application code
invokes EntityManager.anyMethod(), the current JTA transaction is
searched (using persistence unit name as key) for the underlying
EntityManager instance, if not found, a new EntityManager instance is
created and associated with the current JTA transaction, to be reused
for the next EntityManager invocation. Use the @PersistenceContext
annotation, to inject a container-managed entity manager into a
javax.persistence.EntityManager variable.

[[application-managed-entity-manager]]
== Application-managed entity manager

An application-managed entity manager is kept around until the
application closes it. The scope of the application-managed entity
manager is from when the application creates it and lasts until the
application closes it. Use the _@PersistenceUnit_ annotation, to inject
a persistence unit into a _javax.persistence.EntityManagerFactory
variable_. The EntityManagerFactory can return an application-managed
entity manager.

[[persistence-context]]
== Persistence Context

The JPA persistence context contains the entities managed by the entity
manager (via the JPA persistence provider). The underlying entity
manager maintains the persistence context. The persistence context acts
like a first level (transactional) cache for interacting with the
datasource. Loaded entities are placed into the persistence context
before being returned to the application. Entities changes are also
placed into the persistence context (to be saved in the database when
the transaction commits).

[[transaction-scoped-persistence-context]]
== Transaction-scoped Persistence Context

The transaction-scoped persistence context coordinates with the (active)
JTA transaction. When the transaction commits, the persistence context
is flushed to the datasource (entity objects are detached but may still
be referenced by application code). All entity changes that are expected
to be saved to the datasource, must be made during a transaction.
Entities read outside of a transaction will be detached when the entity
manager invocation completes. Example transaction-scoped persistence
context is below.

[source,java]
----
@Stateful  // will use container managed transactions
public class CustomerManager {
  @PersistenceContext(unitName = "customerPU") // default type is PersistenceContextType.TRANSACTION
  EntityManager em;
  public customer createCustomer(String name, String address) {
    Customer customer = new Customer(name, address);
    em.persist(customer);  // persist new Customer when JTA transaction completes (when method ends).
                           // internally:
                           //    1. Look for existing "customerPU" persistence context in active JTA transaction and use if found.
                           //    2. Else create new "customerPU" persistence context (e.g. instance of org.hibernate.ejb.HibernatePersistence)
                           //       and put in current active JTA transaction.
    return customer;       // return Customer entity (will be detached from the persistence context when caller gets control)
  }  // Transaction.commit will be called, Customer entity will be persisted to the database and "customerPU" persistence context closed
----

[[extended-persistence-context]]
== Extended Persistence Context

The (ee container managed) extended persistence context can span
multiple transactions and allows data modifications to be queued up
(like a shopping cart), without an active JTA transaction (to be applied
during the next JTA TX). The Container-managed extended persistence
context can only be injected into a stateful session bean. You can also
think of the extended persistence context, as being an entity manager.

[source,java]
----
@PersistenceContext(type = PersistenceContextType.EXTENDED, unitName = "inventoryPU")
EntityManager em;
----

[[extended-persistence-context-inheritance]]
=== Extended Persistence Context Inheritance

[source,java]
----
JPA 2.0 specification section 7.6.2.1
 
If a stateful session bean instantiates a stateful session bean (executing in the same EJB container instance) which also has such an extended persistence context, the extended persistence context of the first stateful session bean is inherited by the second stateful session bean and bound to it, and this rule recursively applies—independently of whether transactions are active or not at the point of the creation of the stateful session beans.
----

By default, the current stateful session bean being created, will (
*deeply*) inherit the extended persistence context from any stateful
session bean executing in the current Java thread. The *deep*
inheritance of extended persistence context includes walking multiple
levels up the stateful bean call stack (inheriting from parent beans).
The *deep* inheritance of extended persistence context includes sibling
beans. For example, parentA references child beans beanBwithXPC &
beanCwithXPC. Even though parentA doesn't have an extended persistence
context, beanBwithXPC & beanCwithXPC will share the same extended
persistence context.

Some other EE application servers, use *shallow* inheritance, where
stateful session bean only inherit from the parent stateful session bean
(if there is a parent bean). Sibling beans do not share the same
extended persistence context unless their (common) parent bean also has
the same extended persistence context.

Applications can include a (top-level) *jboss-all.xml* deployment
descriptor that specifies either the (default) *DEEP* extended
persistence context inheritance or *SHALLOW*.

The WF/docs/schema/jboss-jpa_1_0.xsd describes the *jboss-jpa*
deployment descriptor that may be included in the *jboss-all.xml*. Below
is an example of using *SHALLOW* extended persistence context
inheritance:

________________________________________________________
<jboss> +
<jboss-jpa xmlns="http://www.jboss.com/xml/ns/javaee"> +
<extended-persistence inheritance="SHALLOW"/> +
</jboss-jpa> +
</jboss>
________________________________________________________

Below is an example of using *DEEP* extended persistence inheritance:

________________________________________________________
<jboss> +
<jboss-jpa xmlns="http://www.jboss.com/xml/ns/javaee"> +
<extended-persistence inheritance="DEEP"/> +
</jboss-jpa> +
</jboss>
________________________________________________________

The AS console/cli can change the *default* extended persistence context
setting (DEEP or SHALLOW). The following cli commands will read the
current JPA settings and enable SHALLOW extended persistence context
inheritance for applications that do not include the *jboss-jpa*
deployment descriptor:

_______________________________________________________________________________
./jboss-cli.sh +
cd subsystem=jpa +
:read-resource +
:write-attribute(name=default-extended-persistence-inheritance,value="SHALLOW")
_______________________________________________________________________________

[[entities]]
== Entities

JPA allows use of your (pojo) plain old Java class to represent a
database table row.

[source,java]
----
@PersistenceContext EntityManager em;
Integer bomPk = getIndexKeyValue();
BillOfMaterials bom = em.find(BillOfMaterials.class, bomPk); // read existing table row into BillOfMaterials class
 
BillOfMaterials createdBom = new BillOfMaterials("...");     // create new entity
em.persist(createdBom);  // createdBom is now managed and will be saved to database when the current JTA transaction completes
----

The entity lifecycle is managed by the underlying persistence provider.

* New (transient): an entity is new if it has just been instantiated
using the new operator, and it is not associated with a persistence
context. It has no persistent representation in the database and no
identifier value has been assigned.
* Managed (persistent): a managed entity instance is an instance with a
persistent identity that is currently associated with a persistence
context.
* Detached: the entity instance is an instance with a persistent
identity that is no longer associated with a persistence context,
usually because the persistence context was closed or the instance was
evicted from the context.
* Removed: a removed entity instance is an instance with a persistent
identity, associated with a persistence context, but scheduled for
removal from the database.

[[deployment]]
== Deployment

The persistence.xml contains the persistence unit configuration (e.g.
datasource name) and as described in the JPA 2.0 spec (section 8.2), the
jar file or directory whose META-INF directory contains the
persistence.xml file is termed the root of the persistence unit. In Java
EE environments, the root of a persistence unit must be one of the
following (quoted directly from the JPA 2.0 specification):

"

* an EJB-JAR file
* the WEB-INF/classes directory of a WAR file
* a jar file in the WEB-INF/lib directory of a WAR file
* a jar file in the EAR library directory
* an application client jar file

The persistence.xml can specify either a JTA datasource or a non-JTA
datasource. The JTA datasource is expected to be used within the EE
environment (even when reading data without an active transaction). If a
datasource is not specified, the default-datasource will instead be used
(must be configured).

NOTE: Java Persistence 1.0 supported use of a jar file in the root of
the EAR as the root of a persistence unit. This use is no longer
supported. Portable applications should use the EAR library directory
for this case instead.

"

Question: Can you have a EAR/META-INF/persistence.xml?

Answer: No, the above may deploy but it could include other archives
also in the EAR, so you may have deployment issues for other reasons.
Better to put the persistence.xml in an EAR/lib/somePuJar.jar.

[[troubleshooting]]
== Troubleshooting

The *org.jboss.as.jpa* logging can be enabled to get the following
information:

* INFO - when persistence.xml has been parsed, starting of persistence
unit service (per deployed persistence.xml), stopping of persistence
unit service
* DEBUG - informs about entity managers being injected, creating/reusing
transaction scoped entity manager for active transaction
* TRACE - shows how long each entity manager operation took in
milliseconds, application searches for a persistence unit, parsing of
persistence.xml

To enable TRACE, open the as/standalone/configuration/standalone.xml (or
as/domain/configuration/domain.xml) file. Search for *<subsystem
xmlns="urn:jboss:domain:logging:1.0">* and add the *org.jboss.as.jpa*
category. You need to change the console-handler level from *INFO* to
*TRACE*.

[source,java]
----
<subsystem xmlns="urn:jboss:domain:logging:1.0">
     <console-handler name="CONSOLE">
      <level name="TRACE" />
      ...
     </console-handler>
 
     </periodic-rotating-file-handler>
     <logger category="com.arjuna">
        <level name="WARN" />
     </logger>
 
     <logger category="org.jboss.as.jpa">
        <level name="TRACE" />
     </logger>
 
     <logger category="org.apache.tomcat.util.modeler">
        <level name="WARN" />
     </logger>
     ...
----

To see what is going on at the JDBC level, enable *jboss.jdbc.spy* TRACE
and add spy="true" to the datasource.

[source,java]
----
<datasource jndi-name="java:jboss/datasources/..." pool-name="..." enabled="true" spy="true">
<logger category="jboss.jdbc.spy">
  <level name="TRACE"/>
</logger>
----

To troubleshoot issues with the Hibernate second level cache, try
enabling trace for *org.hibernate.SQL + org.hibernate.cache.infinispan +
org.infinispan:*

[source,java]
----
<subsystem xmlns="urn:jboss:domain:logging:1.0">
     <console-handler name="CONSOLE">
      <level name="TRACE" />
      ...
     </console-handler>
 
     </periodic-rotating-file-handler>
     <logger category="com.arjuna">
        <level name="WARN" />
     </logger>
 
     <logger category="org.hibernate.SQL">
        <level name="TRACE" />
     </logger>
 
     <logger category="org.hibernate">
        <level name="TRACE" />
     </logger>
      <logger category="org.infinispan">
        <level name="TRACE" />
     </logger>
 
     <logger category="org.apache.tomcat.util.modeler">
        <level name="WARN" />
     </logger>
     ...
----

[[using-the-infinispan-second-level-cache]]
== Using the Infinispan second level cache

To enable the second level cache with Hibernate 5.1, just set the
*hibernate.cache.use_second_level_cache* property to true, as is done in
the following example (also set the
http://docs.oracle.com/javaee/6/api/javax/persistence/SharedCacheMode.html[shared-cache-mode]
accordingly). By default the application server uses Infinispan as the
cache provider for *JPA applications*, so you don't need specify
anything on top of that. The Infinispan version that is included in
WildFly is expected to work with the Hibernate version that is included
with WildFly. Example persistence.xml settings:

[source,java]
----
<?xml version="1.0" encoding="UTF-8"?><persistence xmlns="http://java.sun.com/xml/ns/persistence" version="1.0">
<persistence-unit name="2lc_example_pu">
   <description>example of enabling the second level cache.</description>
   <jta-data-source>java:jboss/datasources/mydatasource</jta-data-source>
   <shared-cache-mode>ENABLE_SELECTIVE</shared-cache-mode>
   <properties>
      <property name="hibernate.cache.use_second_level_cache" value="true"/>
   </properties>
</persistence-unit>
</persistence>
----

Here is an example of enabling the second level cache for a Hibernate
native API hibernate.cfg.xml file:

[source,java]
----
<property name="hibernate.cache.region.factory_class" value="org.jboss.as.jpa.hibernate5.infinispan.InfinispanRegionFactory"/>
<property name="hibernate.cache.infinispan.cachemanager" value="java:jboss/infinispan/container/hibernate"/>
<property name="hibernate.transaction.manager_lookup_class" value="org.hibernate.transaction.JBossTransactionManagerLookup"/>
<property name="hibernate.cache.use_second_level_cache" value="true"/>
----

The Hibernate native API application will also need a MANIFEST.MF:

[source,java]
----
Dependencies: org.infinispan,org.hibernate
----

http://infinispan.org/docs/8.0.x/user_guide/user_guide.html#_using_infinispan_as_jpa_hibernate_second_level_cache_provider[Infinispan
Hibernate/JPA second level cache provider documentation] contains
advanced configuration information but you should bear in mind that when
Hibernate runs within WildFly 8, some of those configuration options,
such as region factory, are not needed. Moreover, the application server
providers you with option of selecting a different cache container for
Infinispan via *hibernate.cache.infinispan.container* persistence
property. To reiterate, this property is not mandatory and a default
container is already deployed for by the application server to host the
second level cache.

Here is an example of what the Hibernate cache settings may currently be
in your standalone.xml:

[source,java]
----
 <cache-container name="hibernate" default-cache="local-query" module="org.hibernate.infinispan">
    <local-cache name="entity">
        <transaction mode="NON_XA"/>
        <eviction strategy="LRU" max-entries="10000"/>
        <expiration max-idle="100000"/>
    </local-cache>
    <local-cache name="local-query">
        <eviction strategy="LRU" max-entries="10000"/>
        <expiration max-idle="100000"/>
    </local-cache>
    <local-cache name="timestamps"/>
</cache-container>
----

Below is an example of customizing the "entity", "immutable-entity",
"local-query", "pending-puts", "timestamps" cache configuration may look
like:

[source,java]
----
 <cache-container name="hibernate" module="org.hibernate.infinispan" default-cache="immutable-entity">
    <local-cache name="entity">
        <transaction mode="NONE"/>
        <eviction max-entries="-1"/>
        <expiration max-idle="120000"/>
    </local-cache>
    <local-cache name="immutable-entity">
        <transaction mode="NONE"/>
        <eviction max-entries="-1"/>
        <expiration max-idle="120000"/>
    </local-cache>
    <local-cache name="local-query">
        <eviction max-entries="-1"/>
        <expiration max-idle="300000"/>
    </local-cache>
    <local-cache name="pending-puts">
        <transaction mode="NONE"/>
        <eviction strategy="NONE"/>
        <expiration max-idle="60000"/>
    </local-cache>
    <local-cache name="timestamps">
        <transaction mode="NONE"/>
        <eviction strategy="NONE"/>
    </local-cache>
</cache-container>
----

Persistence.xml to use the above custom settings:

[source,java]
----
<properties>
    <property name="hibernate.cache.use_second_level_cache" value="true"/>
    <property name="hibernate.cache.use_query_cache" value="true"/>
    <property name="hibernate.cache.infinispan.immutable-entity.cfg" value="immutable-entity"/>
    <property name="hibernate.cache.infinispan.timestamps.cfg" value="timestamps"/>
    <property name="hibernate.cache.infinispan.pending-puts.cfg" value="pending-puts"/>
</properties>
----

[[replacing-the-current-hibernate-5.x-jars-with-a-newer-version]]
== Replacing the current Hibernate 5.x jars with a newer version

Just update the current
wildfly/modules/system/layers/base/org/hibernate/main folder to contain
the newer version (after stopping your WildFly server instance).

1.  Delete *.index files in
wildfly/modules/system/layers/base/org/hibernate/main and
wildfly/modules/system/layers/base/org/hibernate/envers/main folders.
2.  Backup the current contents of
wildfly/modules/system/layers/base/org/hibernate in case you make a
mistake.
3.  Remove the older jars and copy new Hibernate jars into
wildfly/modules/system/layers/base/org/hibernate/main +
wildfly/modules/system/layers/base/org/hibernate/envers/main.
4.  Update the
wildfly/modules/system/layers/base/org/hibernate/main/module.xml +
wildfly/modules/system/layers/base/org/hibernate/envers/main/module.xml
to name the jars that you copied in.
5.  Also update the hibernate-infinispan jars in
wildfly/modules/system/layers/base/org/hibernate/infinispan.

[[using-hibernate-search]]
== Using Hibernate Search

WildFly includes Hibernate Search. If you want to use the bundled
version of Hibernate Search - which requires to use the default
Hibernate ORM 5.1 persistence provider - this will be automatically
enabled. +
Having this enabled means that, provided your application includes any
entity which is annotated with
*org.hibernate.search.annotations.Indexed*, the module
*org.hibernate.search.orm:main* will be made available to your
deployment; this will also include the required version of Apache
Lucene.

If you do not want this module to be exposed to your deployment, set the
persistence property *wildfly.jpa.hibernate.search.module* to either
*none* to not automatically inject any Hibernate Search module, or to
any other module identifier to inject a different module. +
For example you could set
*wildfly.jpa.hibernate.search.module=org.hibernate.search.orm:5.4.0.Alpha1*
to use the experimental version 5.4.0.Alpha1 instead of the provided
module; in this case you'll have to download and add the custom modules
to the application server as other versions are not included. +
When setting *wildfly.jpa.hibernate.search.module=none* you might also
opt to include Hibernate Search and its dependencies within your
application but we highly recommend the modules approach.

[[packaging-the-hibernate-jpa-persistence-provider-with-your-application]]
== Packaging the Hibernate JPA persistence provider with your
application

WildFly allows the packaging of Hibernate persistence provider jars with
the application. The JPA deployer will detect the presence of a
persistence provider in the application and
*jboss.as.jpa.providerModule* needs to be set to *application*.<?xml
version="1.0" encoding="UTF-8"?> +
<persistence xmlns="http://java.sun.com/xml/ns/persistence"
version="1.0"> +
<persistence-unit name="myOwnORMVersion_pu"> +
<description>Hibernate Persistence Unit.</description> +
<jta-data-source>java:jboss/datasources/PlannerDS</jta-data-source> +
<properties> +
<property name="jboss.as.jpa.providerModule" value="application" /> +
</properties> +
</persistence-unit> +
</persistence>

[source,java]
----
----

[[migrating-from-openjpa]]
== Migrating from OpenJPA

You need to copy the OpenJPA jars (e.g. openjpa-all.jar serp.jar) into
the WildFly modules/org/apache/openjpa/main folder and update
modules/org/apache/openjpa/main/module.xml to include the same jar file
names that you copied in. This will help you get your application that
depends on OpenJPA, to deploy on WildFly.

[source,java]
----
 <module xmlns="urn:jboss:module:1.1" name="org.apache.openjpa">
    <resources>
        <resource-root path="jipijapa-openjpa-1.0.1.Final.jar"/>
        <resource-root path="openjpa-all.jar">
           <filter>
              <exclude path="javax/**" />
           </filter>
        </resource-root>
        <resource-root path="serp.jar"/>
    </resources>
 
    <dependencies>
        <module name="javax.api"/>
        <module name="javax.annotation.api"/>
        <module name="javax.enterprise.api"/>
        <module name="javax.persistence.api"/>
        <module name="javax.transaction.api"/>
        <module name="javax.validation.api"/>
        <module name="javax.xml.bind.api"/>
        <module name="org.apache.commons.collections"/>
        <module name="org.apache.commons.lang"/>
        <module name="org.jboss.as.jpa.spi"/>
        <module name="org.jboss.logging"/>
        <module name="org.jboss.vfs"/>
        <module name="org.jboss.jandex"/>
    </dependencies>
</module>
----

[[migrating-from-eclipselink]]
== Migrating from EclipseLink

You need to copy the EclipseLink jar (e.g. eclipselink-2.6.0.jar or
eclipselink.jar as in the example below) into the WildFly
modules/org/eclipse/persistence/main folder and update
modules/org/eclipse/persistence/main/module.xml to include the
EclipseLink jar (take care to use the jar name that you copied in). If
you happen to leave the EclipseLink version number in the jar name, the
module.xml should reflect that. This will help you get your application
that depends on EclipseLink, to deploy on WildFly.

[source,java]
----
 <module xmlns="urn:jboss:module:1.1" name="org.eclipse.persistence">
    <resources>
        <resource-root path="jipijapa-eclipselink-10.0.0.Final.jar"/>
        <resource-root path="eclipselink.jar">           <filter>
              <exclude path="javax/**" />
           </filter>
        </resource-root>
    </resources>
 
    <dependencies>
        <module name="asm.asm"/>
        <module name="javax.api"/>
        <module name="javax.annotation.api"/>
        <module name="javax.enterprise.api"/>
        <module name="javax.persistence.api"/>
        <module name="javax.transaction.api"/>
        <module name="javax.validation.api"/>
        <module name="javax.xml.bind.api"/>
        <module name="org.antlr"/>
        <module name="org.apache.commons.collections"/>
        <module name="org.dom4j"/>
        <module name="org.jboss.as.jpa.spi"/>
        <module name="org.jboss.logging"/>
        <module name="org.jboss.vfs"/>
    </dependencies>
</module>
----

As a workaround for issue
https://bugs.eclipse.org/bugs/show_bug.cgi?id=414974[id=414974], set
(WildFly) system property "eclipselink.archive.factory" to value
"org.jipijapa.eclipselink.JBossArchiveFactoryImpl" via jboss-cli.sh
command (WildFly server needs to be running when this command is
issued):

[source,java]
----
jboss-cli.sh --connect '/system-property=eclipselink.archive.factory:add(value=org.jipijapa.eclipselink.JBossArchiveFactoryImpl)'
----

. The following shows what the standalone.xml (or your WildFly
configuration you are using) file might look like after updating the
system properties:

[source,java]
----
<system-properties>
   ...
   <property name="eclipselink.archive.factory" value="org.jipijapa.eclipselink.JBossArchiveFactoryImpl"/>
</system-properties>
----

You should then be able to deploy applications with persistence.xml that
include;

[source,java]
----
<provider>org.eclipse.persistence.jpa.PersistenceProvider</provider>
----

Also refer to page
https://community.jboss.org/wiki/HowToUseEclipseLinkWithAS7[how to use
EclipseLink with WildFly guide here].

[[migrating-from-datanucleus]]
== Migrating from DataNucleus

Read the
http://www.datanucleus.org/products/accessplatform_5_0/jpa/javaee.html[how
to use DataNucleus with WildFly guide here].

[[native-hibernate-use]]
== Native Hibernate use

Applications that use the Hibernate API directly, are referred to here
as native Hibernate applications. Native Hibernate applications, can
choose to use the Hibernate jars included with WildFly or they can
package their own copy of the Hibernate jars. Applications that utilize
JPA will automatically have the Hibernate classes injected onto the
application deployment classpath. Meaning that JPA applications, should
expect to use the Hibernate jars included in WildFly.

Example MANIFEST.MF entry to add dependency for Hibernate native
applications:

[source,java]
----
Manifest-Version: 1.0
...
Dependencies: org.hibernate
----

If you use the Hibernate native api in your application and also use the
JPA api to access the same entities (from the same Hibernate
session/EntityManager), you could get surprising results (e.g.
HibernateSession.saveOrUpdate(entity) is different than
EntityManager.merge(entity). Each entity should be managed by either
Hibernate native API or JPA code.

[[injection-of-hibernate-session-and-sessionfactoryinjection-of-hibernate-session-and-sessionfactory]]
== Injection of Hibernate Session and SessionFactoryInjection of
Hibernate Session and SessionFactory

You can inject a org.hibernate.Session and org.hibernate.SessionFactory
directly, just as you can do with EntityManagers and
EntityManagerFactorys.

[source,java]
----
import org.hibernate.Session;
import org.hibernate.SessionFactory;
@Stateful public class MyStatefulBean ... {
   @PersistenceContext(unitName="crm") Session session1;
   @PersistenceContext(unitName="crm2", type=EXTENDED) Session extendedpc;
   @PersistenceUnit(unitName="crm") SessionFactory factory;
}
----

[[hibernate-properties]]
== Hibernate properties

WildFly automatically sets the following Hibernate (5.x) properties (if
not already set in persistence unit definition):

[cols=",",]
|=======================================================================
|Property |Purpose

|hibernate.id.new_generator_mappings =true |New applications should let
this default to true, older applications with existing data might need
to set to false (see note below). It really depends on whether your
application uses the @GeneratedValue(AUTO) which will generates new key
values for newly created entities. The application can override this
value (in the persistence.xml).

|hibernate.transaction.jta.platform= instance of
org.hibernate.service.jta.platform.spi.JtaPlatform interface |The
transaction manager, user transaction and transaction synchronization
registry is passed into Hibernate via this class.

|hibernate.ejb.resource_scanner = instance of
org.hibernate.ejb.packaging.Scanner interface |Instance of entity
scanning class is passed in that knows how to use the AS annotation
indexer (for faster deployment).

|hibernate.transaction.manager_lookup_class |This property is removed if
found in the persistence.xml (could conflict with JtaPlatform)

|hibernate.session_factory_name = qualified persistence unit name |Is
set to the application name + persistence unit name (application can
specify a different value but it needs to be unique across all
application deployments on the AS instance).

|hibernate.session_factory_name_is_jndi = false |only set if the
application didn't specify a value for hibernate.session_factory_name.

|hibernate.ejb.entitymanager_factory_name = qualified persistence unit
name |Is set to the application name + persistence unit name
(application can specify a different value but it needs to be unique
across all application deployments on the AS instance).

|hibernate.query.jpaql_strict_compliance=true | 

|hibernate.auto_quote_keyword=false | 

|hibernate.implicit_naming_strategy=org.hibernate.boot.model.naming.ImplicitNamingStrategyJpaCompliantImpl
| 
|=======================================================================

In Hibernate 4.x (and greater), if *new_generator_mappings* is *true*:

* @GeneratedValue(AUTO) maps to
org.hibernate.id.enhanced.SequenceStyleGenerator
* @GeneratedValue(TABLE) maps to
org.hibernate.id.enhanced.TableGenerator
* @GeneratedValue(SEQUENCE) maps to
org.hibernate.id.enhanced.SequenceStyleGenerator

In Hibernate 4.x (and greater), if *new_generator_mappings* is *false*:

* @GeneratedValue(AUTO) maps to Hibernate "native"
* @GeneratedValue(TABLE) maps to
org.hibernate.id.MultipleHiLoPerTableGenerator
* @GeneratedValue(SEQUENCE) to Hibernate "seqhilo"

[[persistence-unit-properties]]
== Persistence unit properties

The following properties are supported in the persistence unit
definition (in the persistence.xml file):

[cols=",",]
|=======================================================================
|Property |Purpose

|jboss.as.jpa.providerModule |name of the persistence provider module
(default is org.hibernate). Should be application, if a persistence
provider is packaged with the application. See note below about some
module names that are built in (based on the provider).

|jboss.as.jpa.adapterModule |name of the integration classes that help
WildFly to work with the persistence provider.

|jboss.as.jpa.adapterClass |class name of the integration adapter.

|jboss.as.jpa.managed |set to false to disable container managed JPA
access to the persistence unit. The default is true, which enables
container managed JPA access to the persistence unit. This is typically
set to false for Spring applications.

|jboss.as.jpa.classtransformer |set to false to disable class
transformers for the persistence unit. Set to true, to allow entity
class enhancing/rewriting.

|wildfly.jpa.default-unit |set to true to choose the default persistence
unit in an application. This is useful if you inject a persistence
context without specifying the unitName (@PersistenceContext
EntityManager em) but have multiple persistence units specified in your
persistence.xml.

|wildfly.jpa.twophasebootstrap |persistence providers (like Hibernate
ORM 4.3+ via EntityManagerFactoryBuilder), allow a two phase persistence
unit bootstrap, which improves JPA integration with CDI. Setting the
wildfly.jpa.twophasebootstrap hint to false, disables the two phase
bootstrap (for the persistence unit that contains the hint).

|wildfly.jpa.allowdefaultdatasourceuse |set to false to prevent
persistence unit from using the default data source. Defaults to true.
This is only important for persistence units that do not specify a
datasource.

|jboss.as.jpa.deferdetach |Controls whether transaction scoped
persistence context used in non-JTA transaction thread, will detach
loaded entities after each EntityManager invocation or when the
persistence context is closed (e.g. business method ends). Defaults to
false (entities are cleared after EntityManager invocation) and if set
to true, the detach is deferred until the context is closed.

|wildfly.jpa.hibernate.search.module |Controls which version of
Hibernate Search to include on classpath. Only makes sense when using
Hibernate as JPA implementation. The default is auto; other valid values
are none or a full module identifier to use an alternative version.

|jboss.as.jpa.scopedname |Specify the qualified (application scoped)
persistence unit name to be used. By default, this is internally set to
the application name + persistence unit name. The
hibernate.cache.region_prefix will default to whatever you set
jboss.as.jpa.scopedname to. Make sure you set the
jboss.as.jpa.scopedname value to a value not already in use by other
applications deployed on the same application server instance.

|wildfly.jpa.allowjoinedunsync |If set to true, allows an
SynchronizationType.UNSYNCHRONIZED persistence context that has been
joined to the active JTA transaction, to be propagated into a
SynchronizationType.SYNCHRONIZED persistence context. Otherwise, an
IllegalStateException exception would of been thrown that complains that
an unsychronized persistence context cannot be propagated into a
synchronized persistence context. Defaults to false.

|wildfly.jpa.skipmixedsynctypechecking |Set to true to disable the
throwing of an IllegalStateException exception when propagating an
SynchronizationType.UNSYNCHRONIZED persistence context into a
SynchronizationType.SYNCHRONIZED persistence context. This is a
workaround intended to allow applications that used to incorrectly not
get IllegalStateException exception with extended persistence contexts,
to avoid the IllegalStateException, so they don't have to change their
application right away (for compatibility purposes). This hint may be
deprecated in a future release. See WFLY-7108 for more details. Defaults
to false.
|=======================================================================

[[determine-the-persistence-provider-module]]
== Determine the persistence provider module

As mentioned above, if the *jboss.as.jpa.providerModule* property is not
specified, the provider module name is determined by the *provider* name
specified in the persistence.xml. The mapping is:

[cols=",",]
|=======================================================================
|Provider Name |Module name

|blank |org.hibernate

|org.hibernate.ejb.HibernatePersistence |org.hibernate

|org.hibernate.ogm.jpa.HibernateOgmPersistence |org.hibernate.ogm

|oracle.toplink.essentials.PersistenceProvider |oracle.toplink

|oracle.toplink.essentials.ejb.cmp3.EntityManagerFactoryProvider
|oracle.toplink

|org.eclipse.persistence.jpa.PersistenceProvider
|org.eclipse.persistence

|org.datanucleus.api.jpa.PersistenceProviderImpl |org.datanucleus

|org.datanucleus.store.appengine.jpa.DatastorePersistenceProvider
|org.datanucleus:appengine

|org.apache.openjpa.persistence.PersistenceProviderImpl
|org.apache.openjpa
|=======================================================================

[[binding-entitymanagerfactoryentitymanager-to-jndi]]
== Binding EntityManagerFactory/EntityManager to JNDI

By default WildFly does *not* bind the entity manager factory to JNDI.
However, you can explicitly configure this in the persistence.xml of
your application by setting the `jboss.entity.manager.factory.jndi.name`
`hint. The value of that property should be the JNDI name to which the entity manager factory should be bound.`

`You can also bind a container managed (transaction scoped) entity manager to JNDI as well, }}via hint`
`jboss.entity.manager.jndi.name`\{
`}{{. As a reminder, a transaction scoped entity manager (persistence context), acts as a proxy that always gets an unique underlying entity manager (at the persistence provider level).`

`Here's an example:`

persistence.xml

[source,java]
----
<?xml version="1.0" encoding="UTF-8"?>
<persistence version="2.0"
   xmlns="http://java.sun.com/xml/ns/persistence" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation="
        http://java.sun.com/xml/ns/persistence
        http://java.sun.com/xml/ns/persistence/persistence_2_0.xsd">
   <persistence-unit name="myPU">
      <!-- If you are running in a production environment, add a managed
         data source, the example data source is just for proofs of concept! -->
      <jta-data-source>java:jboss/datasources/ExampleDS</jta-data-source>
      <properties>
         <!-- Bind entity manager factory to JNDI at java:jboss/myEntityManagerFactory -->
         <property name="jboss.entity.manager.factory.jndi.name" value="java:jboss/myEntityManagerFactory" />
         <property name="jboss.entity.manager.jndi.name" value="java:/myEntityManager"/>
       </properties>
   </persistence-unit>
</persistence>
----

[source,java]
----
@Stateful
public class ExampleSFSB {
  public void createSomeEntityWithTransactionScopedEM(String name) {
    Context context = new InitialContext();
    javax.persistence.EntityManager entityManager = (javax.persistence.EntityManager) context.lookup("java:/myEntityManager");
    SomeEntity someEntity = new SomeEntity();
    someEntity.setName(name);    entityManager.persist(name);
  }
}
----

[[community]]
== Community

Many thanks to the community, for reporting issues, solutions and code
changes. A number of people have been answering Wildfly forum questions
related to JPA usage. I would like to thank them for this, as well as
those reporting issues. For those of you that haven't downloaded the AS
source code and started hacking patches together. I would like to
encourage you to start by reading
https://community.jboss.org/wiki/HackingOnWildFly[Hacking on WildFly].
You will find that it easy very easy to find your way around the
WildFly/JPA/* source tree and make changes. Also, new for WildFly, is
the JipiJapa project that contains additional integration code that
makes EE JPA application deployments work better. The following list of
contributors should grow over time, I hope to see more of you listed
here.

[[people-who-have-contributed-to-the-wildfly-jpa-layer]]
=== People who have contributed to the WildFly JPA layer:

* https://community.jboss.org/people/wolfc[Carlo de Wolf] (lead of the
EJB3 project)
* *http://in.relation.to/Bloggers/Steve[Steve Ebersole]* (lead of the
Hibernate ORM project)
* *https://community.jboss.org/people/swd847[Stuart Douglas]* (lead of
the Seam Persistence project, WildFly project team member/committer)
* https://community.jboss.org/people/jaikiran[Jaikiran Pai] (Active
member of JBoss forums and JBoss EJB3 project team member)
* http://relation.to/Bloggers/StrongLiu[Strong Liu] (leads the
productization effort of Hibernate in the EAP product)
* *https://community.jboss.org/people/smarlow[Scott Marlow]* (lead of
the WildFly container JPA sub-project)
* *https://community.jboss.org/people/alaisi[Antti Laisi]* *(OpenJPA
integration changes)*
* https://docs.jboss.org/author/display/~galder.zamarreno[Galder
Zamarreño] (Infinispan 2lc documentation)
* https://docs.jboss.org/author/display/~sannegrinovero[Sanne Grinovero]
(lead of the Hibernate Search project)
* https://issues.jboss.org/secure/ViewProfile.jspa?name=pferraro[Paul
Ferraro] (Infinispan 2lc integration)

[[jndi-reference-guide]]
= JNDI reference guide

[[overview-1]]
== Overview

WildFly offers several mechanisms to retrieve components by name. Every
WildFly instance has it's own local JNDI namespace ( `java:`) which is
unique per JVM. The layout of this namespace is primarily governed by
the Java EE specification. Applications which share the same WildFly
instance can use this namespace to intercommunicate. In addition to
local JNDI, a variety of mechanisms exist to access remote components.

* Client JNDI - This is a mechanism by which remote components can be
accessed using the JNDI APIs, but *_without network round-trips_* . This
approach is the most efficient, and *_removes a potential single point
of failure_* . For this reason, it is highly recommended to use Client
JNDI over traditional remote JNDI access. However, to make this
possible, it does require that all names follow a strict layout, so user
customizations are not possible. Currently only access to remote EJBs is
supported via the `ejb:` namespace. Future revisions will likely add a
JMS client JNDI namespace.
* Traditional Remote JNDI - This is a more familiar approach to EE
application developers, where the client performs a remote component
name lookup against a server, and a proxy/stub to the component is
serialized as part of the name lookup and returned to the client. The
client then invokes a method on the proxy which results in another
remote network call to the underlying service. In a nutshell,
traditional remote JNDI involves two calls to invoke an EE component,
whereas Client JNDI requires one. It does however allow for customized
names, and for a centralised directory for multiple application servers.
This centralized directory is, however, _a single point of failure_.
* EE Application Client / Server-To-Server Delegation - This approach is
where local names are bound as an _alias_ to a remote name using one of
the above mechanisms. This is useful in that it allows applications to
only ever reference standard portable Java EE names in both code and
deployment descriptors. It also allows for the application to be unaware
of network topology details/ This can even work with Java SE clients by
using the little known EE Application Client feature. This feature
allows you to run an extremely minimal AS server around your
application, so that you can take advantage of certain core services
such as naming and injection.

[[local-jndi]]
== Local JNDI

The Java EE platform specification defines the following JNDI contexts:

* `java:comp` - The namespace is scoped to the current component (i.e.
EJB)
* `java:module` - Scoped to the current module
* `java:app` - Scoped to the current application
* `java:global` - Scoped to the application server

In addition to the standard namespaces, WildFly also provides the
following two global namespaces:

* java:jboss
* java:/

[IMPORTANT]

Only entries within the `java:jboss/exported` context are accessible
over remote JNDI.

[IMPORTANT]

For web deployments `java:comp` is aliased to `java:module`, so EJB's
deployed in a war do not have their own comp namespace.

[[binding-entries-to-jndi]]
=== Binding entries to JNDI

There are several methods that can be used to bind entries into JNDI in
WildFly.

[[using-a-deployment-descriptor]]
==== Using a deployment descriptor

For Java EE applications the recommended way is to use a
link:#src-557207[deployment descriptor] to create the binding. For
example the following `web.xml` binds the string `"Hello World"` to
`java:global/mystring` and the string `"Hello Module"` to
`java:comp/env/hello` (any non absolute JNDI name is relative to
`java:comp/env` context).

[source,java]
----
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"
         version="3.1">
    <env-entry>
        <env-entry-name>java:global/mystring</env-entry-name>
        <env-entry-type>java.lang.String</env-entry-type>
        <env-entry-value>Hello World</env-entry-value>
    </env-entry>
    <env-entry>
        <env-entry-name>hello</env-entry-name>
        <env-entry-type>java.lang.String</env-entry-type>
        <env-entry-value>Hello Module</env-entry-value>
    </env-entry>
</web-app>
----

For more details, see the http://jcp.org/en/jsr/detail?id=342[Java EE
Platform Specification].

[[programatically]]
==== Programatically

[[java-ee-applications]]
===== Java EE Applications

Standard Java EE applications may use the standard JNDI API, included
with Java SE, to bind entries in the global namespaces (the standard
`java:comp`, `java:module` and `java:app` namespaces are read-only, as
mandated by the Java EE Platform Specification).

[source,java]
----
  InitialContext initialContext = new InitialContext();
  initialContext.bind("java:global/a", 100);
----

[IMPORTANT]

There is no need to unbind entries created programatically, since
WildFly tracks which bindings belong to a deployment, and the bindings
are automatically removed when the deployment is undeployed.

[[wildfly-modules-and-extensions]]
===== WildFly Modules and Extensions

With respect to code in WildFly Modules/Extensions, which is executed
out of a Java EE application context, using the standard JNDI API may
result in a UnsupportedOperationException if the target namespace uses a
WritableServiceBasedNamingStore. To work around that, the bind()
invocation needs to be wrapped using WildFly proprietary APIs:

[source,java]
----
  InitialContext initialContext = new InitialContext();
  WritableServiceBasedNamingStore.pushOwner(serviceTarget);
  try {
    initialContext.bind("java:global/a", 100);
  } finally {
    WritableServiceBasedNamingStore.popOwner();
  }
----

[IMPORTANT]

The ServiceTarget removes the bind when uninstalled, thus using one out
of the module/extension domain usage should be avoided, unless entries
are removed using unbind().

[[naming-subsystem-configuration]]
==== Naming Subsystem Configuration

It is also possible to bind to one of the three global namespaces using
configuration in the naming subsystem. This can be done by either
editing the `standalone.xml/domain.xml` file directly, or through the
management API.

Four different types of bindings are supported:

* Simple - A primitive or java.net.URL entry (default is
`java.lang.String`).
* Object Factory - This allows to to specify the
`javax.naming.spi.ObjectFactory` that is used to create the looked up
value.
* External Context - An external context to federate, such as an LDAP
Directory Service
* Lookup - The allows to create JNDI aliases, when this entry is looked
up it will lookup the target and return the result.

An example standalone.xml might look like:

[source,java]
----
<subsystem xmlns="urn:jboss:domain:naming:2.0" >
  <bindings>
    <simple name="java:global/a" value="100" type="int" />
    <simple name="java:global/jbossDocs" value="https://docs.jboss.org" type="java.net.URL" />
    <object-factory name="java:global/b" module="com.acme" class="org.acme.MyObjectFactory" />
    <external-context name="java:global/federation/ldap/example" class="javax.naming.directory.InitialDirContext" cache="true">
      <environment>
        <property name="java.naming.factory.initial" value="com.sun.jndi.ldap.LdapCtxFactory" />
        <property name="java.naming.provider.url" value="ldap://ldap.example.com:389" />
        <property name="java.naming.security.authentication" value="simple" />
        <property name="java.naming.security.principal" value="uid=admin,ou=system" />
        <property name="java.naming.security.credentials" value="secret" />
      </environment>
    </external-context>
    <lookup name="java:global/c" lookup="java:global/b" />
 </bindings>
</subsystem>
----

The CLI may also be used to bind an entry. As an example:

[source,java]
----
/subsystem=naming/binding=java\:global\/mybinding:add(binding-type=simple, type=long, value=1000)
----

[IMPORTANT]

WildFly's Administrator Guide includes a section describing in detail
the Naming subsystem configuration.

[[retrieving-entries-from-jndi]]
=== Retrieving entries from JNDI

[[resource-injection]]
==== Resource Injection

For Java EE applications the recommended way to lookup a JNDI entry is
to use `@Resource` injection:

[source,java]
----
  @Resource(lookup = "java:global/mystring")
  private String myString;
 
  @Resource(name = "hello")
  private String hello;
 
  @Resource
  ManagedExecutorService executor;
----

Note that `@Resource` is more than a JNDI lookup, it also binds an entry
in the component's JNDI environment. The new bind JNDI name is defined
by `@Resource`'s `name` attribute, which value, if unspecified, is the
Java type concatenated with `/` and the field's name, for instance
`java.lang.String/myString`. More, similar to when using deployment
descriptors to bind JNDI entries. unless the name is an absolute JNDI
name, it is considered relative to `java:comp/env`. For instance, with
respect to the field named `myString` above, the `@Resource`'s `lookup`
attribute instructs WildFly to lookup the value in
`java:global/mystring`, bind it in
`java:comp/env/java.lang.String/myString`, and then inject such value
into the field.

With respect to the field named `hello`, there is no `lookup` attribute
value defined, so the responsibility to provide the entry's value is
delegated to the deployment descriptor. Considering that the deployment
descriptor was the `web.xml` previously shown, which defines an
environment entry with same `hello` name, then WildFly inject the valued
defined in the deployment descriptor into the field.

The `executor` field has no attributes specified, so the bind's name
would default to
`java:comp/env/javax.enterprise.concurrent.ManagedExecutorService/executor`,
but there is no such entry in the deployment descriptor, and when that
happens it's up to WildFly to provide a default value or null, depending
on the field's Java type. In this particular case WildFly would inject
the default instance of a managed executor service, the value in
`java:comp/DefaultManagedExecutorService`, as mandated by the EE
Concurrency Utilities 1.0 Specification (JSR 236).

[[standard-java-se-jndi-api]]
==== Standard Java SE JNDI API

Java EE applications may use, without any additional configuration
needed, the standard JNDI API to lookup an entry from JNDI:

[source,java]
----
  String myString = (String) new InitialContext().lookup("java:global/mystring");
----

or simply

[source,java]
----
  String myString = InitialContext.doLookup("java:global/mystring");
----

[[remote-jndi]]
== Remote JNDI

WildFly supports two different types of remote JNDI. The old jnp based
JNDI implementation used in JBoss AS versions prior to 7.x is no longer
supported.

[[remote]]
=== remote:

The `remote:` protocol uses the WildFly remoting protocol to lookup
items from the servers local JNDI. To use it, you must have the
appropriate jars on the class path, if you are maven user can be done
simply by adding the following to your `pom.xml`:

[source,java]
----
<dependency>
  <groupId>org.wildfly</groupId>
  <artifactId>wildfly-ejb-client-bom</artifactId>
  <version>8.0.0.Final</version>
  <type>pom</type>
  <scope>compile</scope>
</dependency>
----

If you are not using maven a shaded jar that contains all required
classes +
can be found in the `bin/client` directory of WildFly's distribution.

[source,java]
----
final Properties env = new Properties();
env.put(Context.INITIAL_CONTEXT_FACTORY, org.jboss.naming.remote.client.InitialContextFactory.class.getName());
env.put(Context.PROVIDER_URL, "remote://localhost:4447");
remoteContext = new InitialContext(env);
----

[[ejb]]
=== ejb:

The ejb: namespace is provided by the jboss-ejb-client library. This
protocol allows you to look up EJB's, using their application name,
module name, ejb name and interface type.

This is a client side JNDI implementation. Instead of looking up an EJB
on the server the lookup name contains enough information for the client
side library to generate a proxy with the EJB information. When you
invoke a method on this proxy it will use the current EJB client context
to perform the invocation. If the current context does not have a
connection to a server with the specified EJB deployed then an error
will occur. Using this protocol it is possible to look up EJB's that do
not actually exist, and no error will be thrown until the proxy is
actually used. The exception to this is stateful session beans, which
need to connect to a server when they are created in order to create the
session bean instance on the server.

Some examples are:

`ejb:myapp/myejbjar/MyEjbName!com.test.MyRemoteInterface` +
`ejb:myapp/myejbjar/MyStatefulName!comp.test.MyStatefulRemoteInterface?stateful`

The first example is a lookup of a singleton, stateless or EJB 2.x home
interface. This lookup will not hit the server, instead a proxy will be
generated for the remote interface specified in the name. The second
example is for a stateful session bean, in this case the JNDI lookup
will hit the server, in order to tell the server to create the SFSB
session.

For more details on how the server connections are configured, please
see link:EJB_invocations_from_a_remote_client_using_JNDI.html[EJB
invocations from a remote client using JNDI].

[[spring-applications-development-and-migration-guide]]
= Spring applications development and migration guide

This document details the main points that need to be considered by
Spring developers that wish to develop new applications or to migrate
existing applications to be run into WildFly 8.

[[dependencies-and-modularity]]
== Dependencies and Modularity

WildFly 8 has a modular class loading strategy, different from previous
versions of JBoss AS, which enforces a better class loading isolation
between deployments and the application server itself. A detailed
description can be found in the documentation dedicated to
https://docs.jboss.org/author/display/AS7/Class+Loading+in+AS7[class
loading in WildFly 8].

This reduces significantly the risk of running into a class loading
conflict and allows applications to package their own dependencies if
they choose to do so. This makes it easier for Spring applications that
package their own dependencies - such as logging frameworks or
persistence providers to run on WildFly 8.

At the same time, this does not mean that duplications and conflicts
cannot exist on the classpath. Some module dependencies are implicit,
depending on the type of deployment as shown
https://docs.jboss.org/author/display/AS7/Implicit+module+dependencies+for+deployments[here].

[[persistence-usage-guide]]
== Persistence usage guide

Depending on the strategy being used, Spring applications can be:

* native Hibernate applications;
* JPA-based applications;
* native JDBC applications;

[[native-springhibernate-applications]]
== Native Spring/Hibernate applications

Applications that use the Hibernate API directly with Spring (i.e.
through either one of LocalSessionFactoryBean or
AnnotationSessionFactoryBean) may use a version of Hibernate 3 packaged
inside the application. Hibernate 4 (which is provided through the
'org.hibernate' module of WildFly 8) is not supported by Spring 3.0 and
Spring 3.1 (and may be supported by Spring 3.2 as described in
https://jira.springsource.org/browse/SPR-8096[SPR-8096]), so adding this
module as a dependency is not a solution.

[[jpa-based-applications]]
== JPA-based applications

Spring applications using JPA may choose between:

* using a server-deployed persistence unit;
* using a Spring-managed persistence unit.

[[using-server-deployed-persistence-units]]
=== Using server-deployed persistence units

Applications that use a server-deployed persistence unit must observe
the typical Java EE rules in what concerns dependency management, i.e.
the javax.persistence classes and persistence provider (Hibernate) are
contained in modules which are added automatically by the application
when the persistence unit is deployed.

In order to use the server-deployed persistence units from within
Spring, either the persistence context or the persistence unit need to
be registered in JNDI via web.xml as follows:

[source,java]
----
<persistence-context-ref>
    <persistence-context-ref-name>persistence/petclinic-em</persistence-unit-ref-name>
    <persistence-unit-name>petclinic</persistence-unit-name>
</persistence-context-ref>
----

or, respectively:

[source,java]
----
<persistence-unit-ref>
    <persistence-unit-ref-name>persistence/petclinic-emf</persistence-unit-ref-name>
    <persistence-unit-name>petclinic</persistence-unit-name>
</persistence-unit-ref>
----

When doing so, the persistence context or persistence unit are available
to be looked up in JNDI, as follows:

[source,java]
----
<jee:jndi-lookup id="entityManager" jndi-name="java:comp/env/persistence/petclinic-em" 
            expected-type="javax.persistence.EntityManager"/>
----

or

[source,java]
----
<jee:jndi-lookup id="entityManagerFactory" jndi-name="java:comp/env/persistence/petclinic-emf" 
            expected-type="javax.persistence.EntityManagerFactory"/>
----

JNDI binding

[IMPORTANT]

JNDI binding via persistence.xml properties is not supported in WildFly
8.

[[using-spring-managed-persistence-units]]
=== Using Spring-managed persistence units

Spring applications running in WildFly 8 may also create persistence
units on their own, using the LocalContainerEntityManagerFactoryBean.
This is what these applications need to consider:

[[placement-of-the-persistence-unit-definitions]]
==== Placement of the persistence unit definitions

When the application server encounters a deployment that has a file
named META-INF/persistence.xml (or, for that matter,
WEB-INF/classes/META-INF/persistence.xml), it will attempt to create a
persistence unit based on what is provided in the file. In most cases,
such definition files are not compliant with the Java EE requirements,
mostly because required elements such as the datasource of the
persistence unit are supposed to be provided by the Spring context
definitions, which will fail the deployment of the persistence unit, and
consequently of the entire deployment.

Spring applications can easily avoid this type of conflict, by using a
feature of the LocalContainerEntityManagerFactoryBean which is designed
for this purpose. Persistence unit definition files can exist in other
locations than META-INF/persistence.xml and the location can be
indicated through the persistenceXmlLocation property of the factory
bean class.

Assuming that the persistence unit is in the
META-INF/jpa-persistence.xml, the corresponding definition can be:

[source,java]
----
<bean id="entityManagerFactory" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"> 
       <property name="persistenceXmlLocation" value="classpath*:META-INF/jpa-persistence.xml"/> 
       <!-- other definitions -->
</bean>
----

[[managing-dependencies]]
=== Managing dependencies

Since the LocalContainerEntityManagerFactoryBean and the corresponding
HibernateJpaVendorAdapter are based on Hibernate 3, it is required to
use that version with the application. Therefore, the Hibernate 3 jars
must be included in the deployment. At the same time, due the presence
of @PersistenceUnit or @PersistenceContext annotations on the
application classes, the application server will automatically add the
'org.hibernate' module as a dependency.

This can be avoided by instructing the server to exclude the module from
the deployment's list of dependencies. In order to do so, include a
META-INF/jboss-deployment-structure.xml or, for web applications,
WEB-INF/jboss-deployment-structure.xml with the following content:

[source,java]
----
<jboss-deployment-structure xmlns="urn:jboss:deployment-structure:1.0">
  <deployment>
    <exclusions>
       <module name="org.hibernate"/>
    </exclusions>
  </deployment>
</jboss-deployment-structure>
----

[[all-wildfly-documentation]]
= All WildFly documentation

There are several guides in the WildFly documentation series. This list
gives an overview of each of the guides:

* link:Getting_Started_Guide.html[Getting Started Guide] - Explains how
to download and start WildFly. +
* link:Getting_Started_Developing_Applications_Guide.html[Getting
Started Developing Applications Guide] - Talks you through developing
your first applications on WildFly, and introduces you to JBoss Tools
and how to deploy your applications. +
* link:JavaEE_6_Tutorial.html[JavaEE 6 Tutorial] - A Java EE 6
Tutorial. +
* link:Admin_Guide.html[Admin Guide] - Tells you how to configure and
manage your WildFly instances. +
* link:#[Developer Guide] - Contains concepts that you need to be aware
of when developing applications for WildFly. Classloading is explained
in depth. +
* link:High_Availability_Guide.html[High Availability Guide] - Reference
guide for how to set up clustered WildFly instances. +
* link:Extending_WildFly.html[Extending WildFly] - A guide to adding new
functionality to WildFly.
