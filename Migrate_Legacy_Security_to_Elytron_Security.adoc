= Migrate Legacy Security to Elytron Security

[[authentication-configuration]]
== Authentication Configuration

[[properties-based-authentication-authorization]]
=== Properties Based Authentication / Authorization

[[picketbox-based-configuration]]
==== PicketBox Based Configuration

This migration example assumes a deployed web application is configured
to require authentication using FORM based authentication and is
referencing a PicketBox based security domain using the
UsersRolesLoginModule to load user information from a pair or properties
files.

[[original-configuration]]
===== Original Configuration

A security domain can be defined in the legacy security subsystem using
the following management operations: -

[source, java]
----
./subsystem=security/security-domain=application-security:add
./subsystem=security/security-domain=application-security/authentication=classic:add(login-modules=[{code=UsersRoles, flag=Required, module-options={usersProperties=file://${jboss.server.config.dir}/example-users.properties, rolesProperties=file://${jboss.server.config.dir}/example-roles.properties}}])
----

This would result in a security domain definition: -

[source, java]
----
  <security-domain name="application-security">
    <authentication>
      <login-module code="UsersRoles" flag="required">
        <module-option name="usersProperties" value="file://${jboss.server.config.dir}/example-users.properties"/>
        <module-option name="rolesProperties" value="file://${jboss.server.config.dir}/example-roles.properties"/>
      </login-module>
    </authentication>
  </security-domain>
----

[[intermediate-configuration]]
===== Intermediate Configuration

It is possible to take a previously defined PicketBox security domain
and expose it as an Elytron security realm so it can be wired into a
complete Elytron based configuration, if only properties based
authentication was to be migrated it would be recommended to jump to the
fully migration configuration and avoid the unnecessary dependency on
the legacy security subsystem but for situations where that is not
immediately possible these commands illustrate an intermediate solution.

These steps assume the original configuration is already in place.

The first step is to add a mapping to an Elytron security realm within
the legacy security subsystem.

[source, java]
----
./subsystem=security/elytron-realm=application-security:add(legacy-jaas-config=application-security)
----

This results in the following configuration.

[source, java]
----
  <subsystem xmlns="urn:jboss:domain:security:2.0">
    ...
    <elytron-integration>
      <security-realms>
        <elytron-realm name="application-security" legacy-jaas-config="application-security"/>
      </security-realms>
    </elytron-integration>
    ...
  </subsystem>
----

Within the Elytron subsystem a security domain can be defined which
references the exported security realm and also a http authentication
factory which supports FORM based authentication.

[source, java]
----
./subsystem=elytron/security-domain=application-security:add(realms=[{realm=application-security}], default-realm=application-security, permission-mapper=default-permission-mapper)
./subsystem=elytron/http-authentication-factory=application-security-http:add(http-server-mechanism-factory=global, security-domain=application-security, mechanism-configurations=[{mechanism-name=FORM}])
----

And the resulting configuration: -

[source, java]
----
  <subsystem xmlns="urn:wildfly:elytron:1.0" final-providers="combined-providers" disallowed-providers="OracleUcrypto">
    ...
    <security-domains>
      ...
      <security-domain name="application-security" default-realm="application-security" permission-mapper="default-permission-mapper">
        <realm name="application-security"/>
      </security-domain>
    </security-domains>
    ...
    <http>
      ...
      <http-authentication-factory name="application-security-http" http-server-mechanism-factory="global" security-domain="application-security">
        <mechanism-configuration>
          <mechanism mechanism-name="FORM"/>
        </mechanism-configuration>
      </http-authentication-factory>
      ...
    </http>
    ...
  </subsystem>
----

Finally configuration needs to be added to the Undertow subsystem to map
the security domain referenced by the deployment to the newly defined
http authentication factory.

[source, java]
----
./subsystem=undertow/application-security-domain=application-security:add(http-authentication-factory=application-security-http)
----

Which results in: -

[source, java]
----
  <subsystem xmlns="urn:jboss:domain:undertow:4.0">
    ...
    <application-security-domains>
      <application-security-domain name="application-security" http-authentication-factory="application-security-http"/>
    </application-security-domains>
    ...
  </subsystem>
----

_Note: If the deployment was already deployed at this point the
application server should be reloaded or the deployment redeployed for
the application security domain mapping to take effect._

The following command can then be used to verify the mapping was applied
to the deployment.

[source, java]
----
[standalone@localhost:9990 /] ./subsystem=undertow/application-security-domain=application-security:read-resource(include-runtime=true)
{
    "outcome" => "success",
    "result" => {
        "enable-jacc" => false,
        "http-authentication-factory" => "application-security-http",
        "override-deployment-config" => false,
        "referencing-deployments" => ["HelloWorld.war"],
        "setting" => undefined
    }
}
----

The deployment being tested here is 'HelloWorld.war' and the output from
the previous command shows this deployment is referencing the mapping.

At this stage the previously defined security domain is used for it's
LoginModule configuration but this is wrapped by Elytron components
which take over authentication.

[[fully-migrated-configuration]]
===== Fully Migrated Configuration

Alternatively the configuration can be completely defined within the
Elytron subsystem, in this case it is assumed none of the previous
commands have been executed and this is started from a clean
configuration - however if the security domain definition does exist in
the legacy security subsystem that will remain completely independent.

First a new security realm can be defined within the Elytron subsystem
referencing the files referenced previously: -

[source, java]
----
./subsystem=elytron/properties-realm=application-properties:add(users-properties={path=example-users.properties, relative-to=jboss.server.config.dir, plain-text=true, digest-realm-name="Application Security"}, groups-properties={path=example-roles.properties, relative-to=jboss.server.config.dir}, groups-attribute=Roles)
----

As before a security domain and http authentication factory can be
defined.

[source, java]
----
./subsystem=elytron/security-domain=application-security:add(realms=[{realm=application-properties}], default-realm=application-properties, permission-mapper=default-permission-mapper)
./subsystem=elytron/http-authentication-factory=application-security-http:add(http-server-mechanism-factory=global, security-domain=application-security, mechanism-configurations=[{mechanism-name=FORM}])
----

This results in the following overall configuration.

[source, java]
----
  <subsystem xmlns="urn:wildfly:elytron:1.0" final-providers="combined-providers" disallowed-providers="OracleUcrypto">
    ...
    <security-domains>
      ...
      <security-domain name="application-security" default-realm="application-properties" permission-mapper="default-permission-mapper">
        <realm name="application-properties"/>
      </security-domain>
    </security-domains>
    <security-realms>
      ...
      <properties-realm name="application-properties" groups-attribute="Roles">
        <users-properties path="example-users.properties" relative-to="jboss.server.config.dir" digest-realm-name="Application Security" plain-text="true"/>
        <groups-properties path="example-roles.properties" relative-to="jboss.server.config.dir"/>
      </properties-realm>
    </security-realms>
    ...
    <http>
      ...
      <http-authentication-factory name="application-security-http" http-server-mechanism-factory="global" security-domain="application-security">
        <mechanism-configuration>
          <mechanism mechanism-name="FORM"/>
        </mechanism-configuration>
      </http-authentication-factory>
      ...
    </http>
    ...
  </subsystem>
----

As before the application-security-domain mapping should be added to the
Undertow subsystem and the server reloaded or the deployment redeployed
as required.

[source, java]
----
./subsystem=undertow/application-security-domain=application-security:add(http-authentication-factory=application-security-http)
----

Which results in: -

[source, java]
----
  <subsystem xmlns="urn:jboss:domain:undertow:4.0">
    ...
    <application-security-domains>
      <application-security-domain name="application-security" http-authentication-factory="application-security-http"/>
    </application-security-domains>
    ...
  </subsystem>
----

At this stage the authentication is the equivalent of the original
configuration however now Elytron components are used exclusively.

[[legacy-security-realm]]
==== Legacy Security Realm

[[original-configuration-1]]
===== Original Configuration

A legacy security realm can be defined using the following commands to
load users passwords and group information from properties files.

[source, java]
----
./core-service=management/security-realm=ApplicationSecurity:add
./core-service=management/security-realm=ApplicationSecurity/authentication=properties:add(relative-to=jboss.server.config.dir, path=example-users.properties, plain-text=true)
./core-service=management/security-realm=ApplicationSecurity/authorization=properties:add(relative-to=jboss.server.config.dir, path=example-roles.properties)
----

This results in the following realm definition.

[source, java]
----
  <security-realm name="ApplicationSecurity">
    <authentication>
      <properties path="example-users.properties" relative-to="jboss.server.config.dir" plain-text="true"/>
    </authentication>
    <authorization>
      <properties path="example-roles.properties" relative-to="jboss.server.config.dir"/>
    </authorization>
  </security-realm>
----

A legacy security realm would typically be used to secure either the
management interfaces or remoting connectors.

[[migrated-configuration]]
===== Migrated Configuration

One of the motivations for adding the Elytron based security to the
application server is to allow a consistent security solution to be used
across the server, to replace the security realm the same steps as
described in the previous 'Fully Migrated' section can be followed again
up until the http-authentication-factory is defined.

A legacy security realm can also be used for SASL based authentication
so a sasl-authentication-factory should also be defined.

[source, java]
----
./subsystem=elytron/sasl-authentication-factory=application-security-sasl:add(sasl-server-factory=elytron, security-domain=application-security, mechanism-configurations=[{mechanism-name=PLAIN}])
----

[source, java]
----
  <subsystem xmlns="urn:wildfly:elytron:1.0" final-providers="combined-providers" disallowed-providers="OracleUcrypto">
    ...
    <sasl>
      ...
      <sasl-authentication-factory name="application-security-sasl" sasl-server-factory="elytron" security-domain="application-security">
        <mechanism-configuration>
          <mechanism mechanism-name="PLAIN"/>
        </mechanism-configuration>
      </sasl-authentication-factory>
      ...
    </sasl>
  </subsystem>
----

This can be associated with a Remoting connector to use for
authentication and the existing security realm reference cleared.

[source, java]
----
./subsystem=remoting/http-connector=http-remoting-connector:write-attribute(name=sasl-authentication-factory, value=application-security-sasl)
./subsystem=remoting/http-connector=http-remoting-connector:undefine-attribute(name=security-realm)
----

[source, java]
----
  <subsystem xmlns="urn:jboss:domain:remoting:4.0">
    ...
    <http-connector name="http-remoting-connector" connector-ref="default" sasl-authentication-factory="application-security-sasl"/>
  </subsystem>
----

If this new configuration was to be used to secure the management
interfaces more suitable names should be chosen but the following
commands illustrate how to set the two authentication factories and
clear the existing security realm reference.

[source, java]
----
./core-service=management/management-interface=http-interface:write-attribute(name=http-authentication-factory, value=application-security-http)
./core-service=management/management-interface=http-interface:write-attribute(name=http-upgrade.sasl-authentication-factory, value=application-security-sasl)
./core-service=management/management-interface=http-interface:undefine-attribute(name=security-realm)
----

[source, java]
----
  <management-interfaces>
    <http-interface http-authentication-factory="application-security-http">
      <http-upgrade enabled="true" sasl-authentication-factory="application-security-sasl"/>
      <socket-binding http="management-http"/>
    </http-interface>
  </management-interfaces>
----

[[ldap-authentication-migration]]
=== LDAP Authentication Migration

The section describing how to migrate from properties based
authentication using either PicketBox or legacy security realms to
Elytron also contained a lot of additional information regarding
defining security domains, authentication factories, and how these are
mapped to be used for authentication. This section will illustrate some
equivalent LDAP configuration using legacy security realms and PicketBox
security domains and show the equivalent configuration using Elytron but
will not repeat the steps to wire it all together covered in the
previous section.

These configuration examples are developed against a test LDAP sever
with user entries like: -

[source, java]
----
dn: uid=TestUserOne,ou=users,dc=group-to-principal,dc=wildfly,dc=org
objectClass: top
objectClass: inetOrgPerson
objectClass: uidObject
objectClass: person
objectClass: organizationalPerson
cn: Test User One
sn: Test User One
uid: TestUserOne
userPassword: {SSHA}UG8ov2rnrnBKakcARVvraZHqTa7mFWJZlWt2HA==
----

The group entries then look like: -

[source, java]
----
dn: uid=GroupOne,ou=groups,dc=group-to-principal,dc=wildfly,dc=org
objectClass: top
objectClass: groupOfUniqueNames
objectClass: uidObject
cn: Group One
uid: GroupOne
uniqueMember: uid=TestUserOne,ou=users,dc=group-to-principal,dc=wildfly,dc=org
----

For authentication purposes the username will be matched against the
'uid' attribute, also the resulting group name will be taken from the
'uid' attribute of the group entry.

[[legacy-security-realm-1]]
==== Legacy Security Realm

A connection to the LDAP server and related security realm can be
created with the following commands: -

[source, java]
----
batch
./core-service=management/ldap-connection=MyLdapConnection:add(url="ldap://localhost:10389", search-dn="uid=admin,ou=system", search-credential="secret")
 
./core-service=management/security-realm=LDAPRealm:add
./core-service=management/security-realm=LDAPRealm/authentication=ldap:add(connection="MyLdapConnection", username-attribute=uid, base-dn="ou=users,dc=group-to-principal,dc=wildfly,dc=org")
 
 
./core-service=management/security-realm=LDAPRealm/authorization=ldap:add(connection=MyLdapConnection)
./core-service=management/security-realm=LDAPRealm/authorization=ldap/username-to-dn=username-filter:add(attribute=uid, base-dn="ou=users,dc=group-to-principal,dc=wildfly,dc=org")
./core-service=management/security-realm=LDAPRealm/authorization=ldap/group-search=group-to-principal:add(base-dn="ou=groups,dc=group-to-principal,dc=wildfly,dc=org", iterative=true, prefer-original-connection=true, principal-attribute=uniqueMember, search-by=DISTINGUISHED_NAME, group-name=SIMPLE, group-name-attribute=uid)
run-batch
----

This results in the following configuration.

[source, java]
----
  <management>
    <security-realms>
      ...
      <security-realm name="LDAPRealm">
        <authentication>
          <ldap connection="MyLdapConnection" base-dn="ou=users,dc=group-to-principal,dc=wildfly,dc=org">
            <username-filter attribute="uid"/>
          </ldap>
        </authentication>
        <authorization>
          <ldap connection="MyLdapConnection">
            <username-to-dn>
              <username-filter base-dn="ou=users,dc=group-to-principal,dc=wildfly,dc=org" attribute="uid"/>
            </username-to-dn>
            <group-search group-name="SIMPLE" iterative="true" group-name-attribute="uid">
              <group-to-principal search-by="DISTINGUISHED_NAME" base-dn="ou=groups,dc=group-to-principal,dc=wildfly,dc=org" prefer-original-connection="true">
                <membership-filter principal-attribute="uniqueMember"/>
              </group-to-principal>
            </group-search>
          </ldap>
        </authorization>
      </security-realm>
    </security-realms>
    <outbound-connections>
      <ldap name="MyLdapConnection" url="ldap://localhost:10389" search-dn="uid=admin,ou=system" search-credential="secret"/>
    </outbound-connections>
    ...
  </management>
----

[[picketbox-ldapextloginmodule]]
==== PicketBox LdapExtLoginModule

The following commands can create a PicketBox security domain configured
to use the LdapExtLoginModule to verify a username and password.

[source, java]
----
./subsystem=security/security-domain=application-security:add
./subsystem=security/security-domain=application-security/authentication=classic:add(login-modules=[{code=LdapExtended, flag=Required, module-options={ \
java.naming.factory.initial=com.sun.jndi.ldap.LdapCtxFactory, \
java.naming.provider.url=ldap://localhost:10389, \
java.naming.security.authentication=simple, \
bindDN="uid=admin,ou=system", \
bindCredential=secret, \
baseCtxDN="ou=users,dc=group-to-principal,dc=wildfly,dc=org", \
baseFilter="(uid={0})", \
rolesCtxDN="ou=groups,dc=group-to-principal,dc=wildfly,dc=org",\
roleFilter="(uniqueMember={1})", \
roleAttributeID="uid" \
}}])
----

This results in the following configuration.

[source, java]
----
  <subsystem xmlns="urn:jboss:domain:security:2.0">
    ...
    <security-domains>
      ...
      <security-domain name="application-security">
        <authentication>
          <login-module code="LdapExtended" flag="required">
            <module-option name="java.naming.factory.initial" value="com.sun.jndi.ldap.LdapCtxFactory"/>
            <module-option name="java.naming.provider.url" value="ldap://localhost:10389"/>
            <module-option name="java.naming.security.authentication" value="simple"/>
            <module-option name="bindDN" value="uid=admin,ou=system"/>
            <module-option name="bindCredential" value="secret"/>
            <module-option name="baseCtxDN" value="ou=users,dc=group-to-principal,dc=wildfly,dc=org"/>
            <module-option name="baseFilter" value="(uid={0})"/>
            <module-option name="rolesCtxDN" value="ou=groups,dc=group-to-principal,dc=wildfly,dc=org"/>
            <module-option name="roleFilter" value="(uniqueMember={1})"/>
            <module-option name="roleAttributeID" value="uid"/>
          </login-module>
        </authentication>
      </security-domain>
    </security-domains>
  </subsystem>
----

[[migrated]]
==== Migrated

Within the Elytron subsystem a directory context can be defined for the
connection to LDAP: -

[source, java]
----
./subsystem=elytron/dir-context=ldap-connection:add(url=ldap://localhost:10389, principal="uid=admin,ou=system", credential-reference={clear-text=secret})
----

Then a security realm can be created to search LDAP and verify the
supplied password: -

[source, java]
----
./subsystem=elytron/ldap-realm=ldap-realm:add(dir-context=ldap-connection, \
direct-verification=true, \
identity-mapping={search-base-dn="ou=users,dc=group-to-principal,dc=wildfly,dc=org", \
rdn-identifier="uid", \
attribute-mapping=[{filter-base-dn="ou=groups,dc=group-to-principal,dc=wildfly,dc=org",filter="(uniqueMember={1})",from="uid",to="Roles"}]})
----

In the prior two examples information is loaded from LDAP to use
directly as groups or roles, in the Elytron case information can be
loaded from LDAP to associate with the identity as attributes - these
can subsequently be mapped to roles but attributes can be loaded for
other purposes as well.

[IMPORTANT]

By default, if no `role-decoder` is defined for given `security-domain`,
identity attribute " `Roles`" is mapped to the identity roles.

This leads to the following configuration.

[source, java]
----
  <subsystem xmlns="urn:wildfly:elytron:1.0" final-providers="combined-providers" disallowed-providers="OracleUcrypto">
    ...
    <security-realms>
      ...
      <ldap-realm name="ldap-realm" dir-context="ldap-connection" direct-verification="true">
        <identity-mapping rdn-identifier="uid" search-base-dn="ou=users,dc=group-to-principal,dc=wildfly,dc=org">
          <attribute-mapping>
            <attribute from="uid" to="Roles" filter="(uniqueMember={1})" filter-base-dn="ou=groups,dc=group-to-principal,dc=wildfly,dc=org"/>
          </attribute-mapping>
        </identity-mapping>
      </ldap-realm>
    </security-realms>
    ...
    <dir-contexts>
      <dir-context name="ldap-connection" url="ldap://localhost:10389" principal="uid=admin,ou=system">
        <credential-reference clear-text="secret"/>
      </dir-context>
    </dir-contexts>
  </subsystem>
----

[[database-authentication]]
=== Database Authentication

The section describing how to migrate from database accessible via JDBC
datasource based authentication using PicketBox to Elytron. This section
will illustrate some equivalent configuration using PicketBox security
domains and show the equivalent configuration using Elytron but will not
repeat the steps to wire it all together covered in the previous
sections.

These configuration examples are developed against a test database with
users table like:

[source, java]
----
CREATE TABLE User (
    id BIGINT NOT NULL,
    username VARCHAR(255),
    password VARCHAR(255),
    role ENUM('admin', 'manager', 'user'),
    PRIMARY KEY (id),
    UNIQUE (username)
)
----

For authentication purposes the username will be matched against the '
`username`' column, password will be expected in hex-encoded MD5 hash in
' `password`' column. User role for authorization purposes will be taken
from ' `role`' column.

[[picketbox-database-loginmodule]]
==== PicketBox Database LoginModule

The following commands can create a PicketBox security domain configured
to use database accessible via JDBC datasource to verify a username and
password and to assign roles.

[source, java]
----
./subsystem=security/security-domain=application-security/:add
./subsystem=security/security-domain=application-security/authentication=classic:add(login-modules=[{code=Database, flag=Required, module-options={ \
    dsJndiName="java:jboss/datasources/ExampleDS", \
    principalsQuery="SELECT password FROM User WHERE username = ?", \
    rolesQuery="SELECT role, 'Roles' FROM User WHERE username = ?", \
    hashAlgorithm=MD5, \
    hashEncoding=base64 \
}}])
----

This results in the following configuration.

[source, java]
----
        <subsystem xmlns="urn:jboss:domain:security:2.0">
            <security-domains>
                ...
                <security-domain name="application-security">
                    <authentication>
                        <login-module code="Database" flag="required">
                            <module-option name="dsJndiName" value="java:jboss/datasources/ExampleDS"/>
                            <module-option name="principalsQuery" value="SELECT password FROM User WHERE username = ?"/>
                            <module-option name="rolesQuery" value="SELECT role, 'Roles' FROM User WHERE username = ?"/>
                            <module-option name="hashAlgorithm" value="MD5"/>
                            <module-option name="hashEncoding" value="base64"/>
                        </login-module>
                    </authentication>
                </security-domain>
            </security-domains>
        </subsystem>
----

[[migrated-1]]
==== Migrated

Within the Elytron subsystem to use database accesible via JDBC you need
to define `jdbc-realm`:

[source, java]
----
./subsystem=elytron/jdbc-realm=jdbc-realm:add(principal-query=[{ \
    data-source=ExampleDS, \
    sql="SELECT role, password FROM User WHERE username = ?", \
    attribute-mapping=[{index=1, to=Roles}] \
    simple-digest-mapper={algorithm=simple-digest-md5, password-index=2}, \
}])
----

This results in the following overall configuration:

[source, java]
----
        <subsystem xmlns="urn:wildfly:elytron:1.0" final-providers="combined-providers" disallowed-providers="OracleUcrypto">
            ...
            <security-realms>
                ...
                <jdbc-realm name="jdbc-realm">
                    <principal-query sql="SELECT role, password FROM User WHERE username = ?" data-source="ExampleDS">
                        <attribute-mapping>
                            <attribute to="Roles" index="1"/>
                        </attribute-mapping>
                        <simple-digest-mapper password-index="2"/>
                    </principal-query>
                </jdbc-realm>
                ...
            </security-realms>
            ...
        </subsystem>
----

In comparison with PicketBox solution, Elytron `jdbc-realm` use one SQL
query to obtain all user attributes and credentials. Their extraction
from SQL result specifies mappers.

[[kerberos-authentication-migration]]
=== Kerberos Authentication Migration

When working with Kerberos configuration it is possible for the
application server to rely on configuration from the environment or the
key configuration can be specified using system properties, for the
purpose of these examples I define system properties - these properties
are applicable to both the legacy configuration and the migrated Elytron
configuration.

[source, java]
----
./system-property=sun.security.krb5.debug:add(value=true)
./system-property=java.security.krb5.realm:add(value=ELYTRON.ORG)
./system-property=java.security.krb5.kdc:add(value=kdc.elytron.org)
----

The first line makes debugging easier but the last two lines specify the
Kerberos realm in use and the address of the KDC.

[source, java]
----
  <system-properties>
    <property name="sun.security.krb5.debug" value="true"/>
    <property name="java.security.krb5.realm" value="ELYTRON.ORG"/>
    <property name="java.security.krb5.kdc" value="kdc.elytron.org"/>
  </system-properties>
----

[[http-authentication]]
==== HTTP Authentication

[[legacy-security-realm-2]]
===== Legacy Security Realm

A legacy security realm can be define so that SPNEGO authentication can
be enabled for the HTTP management interface.

[source, java]
----
./core-service=management/security-realm=Kerberos:add
./core-service=management/security-realm=Kerberos/server-identity=kerberos:add
./core-service=management/security-realm=Kerberos/server-identity=kerberos/keytab=HTTP\/test-server.elytron.org@ELYTRON.ORG:add(path=/home/darranl/src/kerberos/test-server.keytab, debug=true)
./core-service=management/security-realm=Kerberos/authentication=kerberos:add(remove-realm=true)
----

This results in the following configuration: -

[source, java]
----
  <security-realms>
    ...
    <security-realm name="Kerberos">
      <server-identities>
        <kerberos>
          <keytab principal="HTTP/test-server.elytron.org@ELYTRON.ORG" path="/home/darranl/src/kerberos/test-server.keytab" debug="true"/>
        </kerberos>
      </server-identities>
      <authentication>
        <kerberos remove-realm="true"/>
      </authentication>
    </security-realm>
  </security-realms>
----

[[application-spnego]]
===== Application SPNEGO

Alternatively deployed applications would make use of a pair of security
domains.

[source, java]
----
./subsystem=security/security-domain=host:add
./subsystem=security/security-domain=host/authentication=classic:add
./subsystem=security/security-domain=host/authentication=classic/login-module=1:add(code=Kerberos, flag=Required, module-options={storeKey=true, useKeyTab=true, principal=HTTP/test-server.elytron.org@ELYTRON.ORG, keyTab=/home/darranl/src/kerberos/test-server.keytab, debug=true}
----

[source, java]
----
./subsystem=security/security-domain=SPNEGO:add
./subsystem=security/security-domain=SPNEGO/authentication=classic:add
./subsystem=security/security-domain=SPNEGO/authentication=classic/login-module=1:add(code=SPNEGO, flag=requisite,  module-options={password-stacking=useFirstPass, serverSecurityDomain=host})
./subsystem=security/security-domain=SPNEGO/authentication=classic/login-module=1:write-attribute(name=module, value=org.jboss.security.negotiation)
./subsystem=security/security-domain=SPNEGO/authentication=classic/login-module=2:add(code=UsersRoles, flag=required, module-options={password-stacking=useFirstPass, usersProperties=file:///home/darranl/src/kerberos/spnego-users.properties, rolesProperties=file:///home/darranl/src/kerberos/spnego-roles.properties, defaultUsersProperties=file:///home/darranl/src/kerberos/spnego-users.properties, defaultRolesProperties=file:///home/darranl/src/kerberos/spnego-roles.properties})
----

This results in: -

[source, java]
----
  <subsystem xmlns="urn:jboss:domain:security:2.0">
    <security-domains>
      ...
      <security-domain name="host">
        <authentication>
          <login-module name="1" code="Kerberos" flag="required">
            <module-option name="storeKey" value="true"/>
            <module-option name="useKeyTab" value="true"/>
            <module-option name="principal" value="HTTP/test-server.elytron.org@ELYTRON.ORG"/>
            <module-option name="keyTab" value="/home/darranl/src/kerberos/test-server.keytab"/>
            <module-option name="debug" value="true"/>
          </login-module>
        </authentication>
      </security-domain>
      <security-domain name="SPNEGO">
        <authentication>
          <login-module name="1" code="SPNEGO" flag="requisite" module="org.jboss.security.negotiation">
            <module-option name="password-stacking" value="useFirstPass"/>
            <module-option name="serverSecurityDomain" value="host"/>
          </login-module>
          <login-module name="2" code="UsersRoles" flag="required">
            <module-option name="password-stacking" value="useFirstPass"/>
            <module-option name="usersProperties" value="file:///home/darranl/src/kerberos/spnego-users.properties"/>
            <module-option name="rolesProperties" value="file:///home/darranl/src/kerberos/spnego-roles.properties"/>
            <module-option name="defaultUsersProperties" value="file:///home/darranl/src/kerberos/spnego-users.properties"/>
            <module-option name="defaultRolesProperties" value="file:///home/darranl/src/kerberos/spnego-roles.properties"/>
          </login-module>
        </authentication>
      </security-domain>
    </security-domains>
  </subsystem>
----

An application can now be deployed referencing the SPNEGO security
domain and secured with SPNEGO mechanism.

[[migrated-spnego]]
===== Migrated SPNEGO

The equivalent configuration can be achieved with WildFly Elytron by
first defining a security realm which will be used to load identity
information.

[source, java]
----
./subsystem=elytron/properties-realm=spnego-properties:add(users-properties={path=/home/darranl/src/kerberos/spnego-users.properties, plain-text=true, digest-realm-name=ELYTRON.ORG}, groups-properties={path=/home/darranl/src/kerberos/spnego-roles.properties})
----

Next a Kerberos security factory is defined which allows the server to
load it's own Kerberos identity.

[source, java]
----
./subsystem=elytron/kerberos-security-factory=test-server:add(path=/home/darranl/src/kerberos/test-server.keytab, principal=HTTP/test-server.elytron.org@ELYTRON.ORG, debug=true)
----

As with the previous examples we define a security realm to pull
together the policy as well as a HTTP authentication factory for the
authentication policy.

[source, java]
----
./subsystem=elytron/security-domain=SPNEGODomain:add(default-realm=spnego-properties, realms=[{realm=spnego-properties, role-decoder=groups-to-roles}], permission-mapper=default-permission-mapper)
./subsystem=elytron/http-authentication-factory=spnego-http-authentication:add(security-domain=SPNEGODomain, http-server-mechanism-factory=global,mechanism-configurations=[{mechanism-name=SPNEGO, credential-security-factory=test-server}])
----

Overall this results in the following configuration: -

[source, java]
----
  <subsystem xmlns="urn:wildfly:elytron:1.0" final-providers="combined-providers" disallowed-providers="OracleUcrypto">
    ...
    <security-domains>
    ...
      <security-domain name="SPNEGODomain" default-realm="spnego-properties" permission-mapper="default-permission-mapper">
        <realm name="spnego-properties" role-decoder="groups-to-roles"/>
      </security-domain>
    </security-domains>
    <security-realms>
      ...
      <properties-realm name="spnego-properties">
        <users-properties path="/home/darranl/src/kerberos/spnego-users.properties" digest-realm-name="ELYTRON.ORG" plain-text="true"/>
        <groups-properties path="/home/darranl/src/kerberos/spnego-roles.properties"/>
      </properties-realm>
    </security-realms>
    <credential-security-factories>
      <kerberos-security-factory name="test-server" principal="HTTP/test-server.elytron.org@ELYTRON.ORG" path="/home/darranl/src/kerberos/test-server.keytab" debug="true"/>
    </credential-security-factories>
    ...
    <http>
      ...
      <http-authentication-factory name="spnego-http-authentication" http-server-mechanism-factory="global" security-domain="SPNEGODomain">
        <mechanism-configuration>
          <mechanism mechanism-name="SPNEGO" credential-security-factory="test-server"/>
        </mechanism-configuration>
      </http-authentication-factory>
      ...
    </http>
    ...
  </subsystem>
----

Now, to enable SPNEGO authentication for the HTTP management interface,
update this interface to reference the `http-authentication-factory`
defined above, as described in the
https://docs.jboss.org/author/display/WFLY/Migrate+Legacy+Security+to+Elytron+Security#MigrateLegacySecuritytoElytronSecurity-MigratedConfiguration[properties
authentication section].

Alternatively, to secure an application using SPNEGO authentication, an
application security domain can be defined in the Undertow subsystem to
map security domains to the `http-authentication-factory` defined above,
as described in the
https://docs.jboss.org/author/display/WFLY/Migrate+Legacy+Security+to+Elytron+Security#MigrateLegacySecuritytoElytronSecurity-FullyMigratedConfiguration[properties
authentication section].

[[remoting-sasl-authentication]]
==== Remoting / SASL Authentication

[[legacy-security-realm-3]]
===== Legacy Security Realm

It is also possible to define a legacy security realm for Kerberos /
GSSAPI SASL authenticatio for Remoting authentication such as the native
management interface.

[source, java]
----
./core-service=management/security-realm=Kerberos:add
./core-service=management/security-realm=Kerberos/server-identity=kerberos:add
./core-service=management/security-realm=Kerberos/server-identity=kerberos/keytab=remote\/test-server.elytron.org@ELYTRON.ORG:add(path=/home/darranl/src/kerberos/remote-test-server.keytab, debug=true)
./core-service=management/security-realm=Kerberos/authentication=kerberos:add(remove-realm=true)
----

[source, java]
----
  <management>
    <security-realms>
      ...
      <security-realm name="Kerberos">
        <server-identities>
          <kerberos>
            <keytab principal="remote/test-server.elytron.org@ELYTRON.ORG" path="/home/darranl/src/kerberos/remote-test-server.keytab" debug="true"/>
          </kerberos>
        </server-identities>
        <authentication>
          <kerberos remove-realm="true"/>
        </authentication>
      </security-realm>
    </security-realms>
    ...
  </management>
----

[[migrated-gssapi]]
===== Migrated GSSAPI

The steps to define the equivalent Elytron configuration are very
similar to the HTTP example.

First define the security realm to load the identity from: -

[source, java]
----
./path=kerberos:add(relative-to=user.home, path=src/kerberos)
./subsystem=elytron/properties-realm=kerberos-properties:add(users-properties={path=kerberos-users.properties, relative-to=kerberos, digest-realm-name=ELYTRON.ORG}, groups-properties={path=kerberos-groups.properties, relative-to=kerberos})
----

Then define the Kerberos security factory for the server's identity.

[source, java]
----
./subsystem=elytron/kerberos-security-factory=test-server:add(relative-to=kerberos, path=remote-test-server.keytab, principal=remote/test-server.elytron.org@ELYTRON.ORG)
----

Finally define the security domain and this time a SASL authentication
factory.

[source, java]
----
./subsystem=elytron/security-domain=KerberosDomain:add(default-realm=kerberos-properties, realms=[{realm=kerberos-properties, role-decoder=groups-to-roles}], permission-mapper=default-permission-mapper)
./subsystem=elytron/sasl-authentication-factory=gssapi-authentication-factory:add(security-domain=KerberosDomain, sasl-server-factory=elytron, mechanism-configurations=[{mechanism-name=GSSAPI, credential-security-factory=test-server}])
----

This results in the following subsystem configuration: -

[source, java]
----
  <subsystem xmlns="urn:wildfly:elytron:1.0" final-providers="combined-providers" disallowed-providers="OracleUcrypto">
    ...
    <security-domains>
      ...
      <security-domain name="KerberosDomain" default-realm="kerberos-properties" permission-mapper="default-permission-mapper">
        <realm name="kerberos-properties" role-decoder="groups-to-roles"/>
      </security-domain>
    </security-domains>
    <security-realms>
     ...
       <properties-realm name="kerberos-properties">
         <users-properties path="kerberos-users.properties" relative-to="kerberos" digest-realm-name="ELYTRON.ORG"/>
         <groups-properties path="kerberos-groups.properties" relative-to="kerberos"/>
       </properties-realm>
     </security-realms>
     <credential-security-factories>
       <kerberos-security-factory name="test-server" principal="remote/test-server.elytron.org@ELYTRON.ORG" path="remote-test-server.keytab" relative-to="kerberos"/>
     </credential-security-factories>
     ...
     <sasl>
       ...
       <sasl-authentication-factory name="gssapi-authentication-factory" sasl-server-factory="elytron" security-domain="KerberosDomain">
         <mechanism-configuration>
           <mechanism mechanism-name="GSSAPI" credential-security-factory="test-server"/>
         </mechanism-configuration>
       </sasl-authentication-factory>
       ...
     </sasl>
   </subsystem>
----

The management interface or Remoting connectors can now be updated to
reference the SASL authentication factory.

The two Elytron examples defined here could also be combined into one to
use a shared security domain and security realm and just use protocol
specific authentication factories each referencing their own Kerberos
security factory.

[[clients]]
== Clients

[[application-client-migration]]
=== Application Client Migration

[[naming-client]]
==== Naming Client

This migration example assumes a client application performs a remote
JNDI lookup using an ﻿﻿ `InitialContext` backed by the
`org.jboss.naming.remote.client.InitialContextFactory` class.

[[original-configuration-2]]
===== Original Configuration

An `InitialContext` backed by the
`org.jboss.naming.remote.client.InitialContextFactory` class can be
created by specifying properties that contain the URL of the naming
provider to connect to along with appropriate user credentials:

[source, java]
----
Properties properties = new Properties();
properties.put(Context.INITIAL_CONTEXT_FACTORY, "org.jboss.naming.remote.client.InitialContextFactory");
properties.put(Context.PROVIDER_URL, "http-remoting://localhost:8080");
properties.put(Context.SECURITY_PRINCIPAL, "bob");
properties.put(Context.SECURITY_CREDENTIALS, "secret");
InitialContext context = new InitialContext(properties);
Bar bar = (Bar) context.lookup("foo/bar");
...
----

[[migrated-configuration-1]]
===== Migrated Configuration

An `InitialContext` backed by the
`org.wildfly.naming.client.WildFlyInitialContextFactory` class can be
created by specifying a property that contains the URL of the naming
provider to connect to. The user credentials can be specified using a
WildFly client configuration file or programmatically.

[[configuration-file-approach]]
====== Configuration File Approach

A `wildfly-config.xml` file that contains the user credentials to use
when establishing a connection to the naming provider can be added to
the client application's `META-INF` directory:

*wildfly-config.xml*

[source, java]
----
<configuration>
    <authentication-client xmlns="urn:elytron:1.0">
        <authentication-rules>
            <rule use-configuration="namingConfig">
                <match-host name="127.0.0.1"/>
            </rule>
        </authentication-rules>
        <authentication-configurations>
            <configuration name="namingConfig">
                <set-user-name name="bob"/>
                <credentials>
                    <clear-password password="secret"/>
                </credentials>
            </configuration>
        </authentication-configurations>
    </authentication-client>
</configuration>
----

An `InitialContext` can then be created as follows:

[source, java]
----
Properties properties = new Properties();
properties.put(Context.INITIAL_CONTEXT_FACTORY, "org.wildfly.naming.client.WildFlyInitialContextFactory");
properties.put(Context.PROVIDER_URL, "remote+http://127.0.0.1:8080");
InitialContext context = new InitialContext(properties);
Bar bar = (Bar) context.lookup("foo/bar");
...
----

[[programmatic-approach]]
====== Programmatic Approach

The user credentials to use when establishing a connection to the naming
provider can be specified directly in the client application's code:

[source, java]
----
// create your authentication configuration
AuthenticationConfiguration namingConfig = AuthenticationConfiguration.empty().useName("bob").usePassword("secret");
 
// create your authentication context
AuthenticationContext context = AuthenticationContext.empty().with(MatchRule.ALL.matchHost("127.0.0.1"), namingConfig);
 
// create a callable that creates and uses an InitialContext
Callable<Void> callable = () -> {
    Properties properties = new Properties();
    properties.put(Context.INITIAL_CONTEXT_FACTORY, "org.wildfly.naming.client.WildFlyInitialContextFactory");
    properties.put(Context.PROVIDER_URL, "remote+http://127.0.0.1:8080");
    InitialContext context = new InitialContext(properties);
    Bar bar = (Bar) context.lookup("foo/bar");
    ...
    return null;
};
 
// use your authentication context to run your callable
context.runCallable(callable);
----

[[ejb-client]]
==== EJB Client

This migration example assumes a client application is configured to
invoke an EJB deployed on a remote server using a
`jboss-ejb-client.properties` file.

[[original-configuration-3]]
===== Original Configuration

A `jboss-ejb-client.properties` file that contains the information
needed to connect to the remote server can be specified in a client
application's `META-INF` directory:

*jboss-ejb-client.properties*

[source, java]
----
remote.connectionprovider.create.options.org.xnio.Options.SSL_ENABLED=false
remote.connections=default
remote.connection.default.host=127.0.0.1
remote.connection.default.port = 8080
remote.connection.default.username=bob
remote.connection.default.password=secret
----

An EJB can then be looked up and a method can be invoked on it as
follows:

[source, java]
----
// create an InitialContext
Properties properties = new Properties();
properties.put(Context.INITIAL_CONTEXT_FACTORY, "org.jboss.naming.remote.client.InitialContextFactory");
properties.put(Context.URL_PKG_PREFIXES, "org.jboss.ejb.client.naming");
InitialContext context = new InitialContext(properties);
 
// look up an EJB and invoke one of its methods
RemoteCalculator statelessRemoteCalculator = (RemoteCalculator) context.lookup(
    "ejb:/ejb-remote-server-side//CalculatorBean!" + RemoteCalculator.class.getName());
int sum = statelessRemoteCalculator.add(101, 202);
----

[[migrated-configuration-2]]
===== Migrated Configuration

The information needed to connect to the remote server can be specified
using a WildFly client configuration file or programmatically.

[[configuration-file-approach-1]]
====== Configuration File Approach

A `wildfly-config.xml` file that contains the information needed to
connect to the remote server can be added to the client application's
`META-INF` directory:

*wildfly-config.xml*

[source, java]
----
<configuration>
    <authentication-client xmlns="urn:elytron:1.0">
        <authentication-rules>
            <rule use-configuration="ejbConfig">
                <match-host name="127.0.0.1"/>
            </rule>
        </authentication-rules>
        <authentication-configurations>
            <configuration name="ejbConfig">
                <set-user-name name="bob"/>
                <credentials>
                    <clear-password password="secret"/>
                </credentials>
            </configuration>
        </authentication-configurations>
    </authentication-client>
    <jboss-ejb-client xmlns="urn:jboss:wildfly-client-ejb:3.0">
        <connections>
            <connection uri="remote+http://127.0.0.1:8080" />
        </connections>
    </jboss-ejb-client>
</configuration>
----

An EJB can then be looked up and a method can be invoked on it as
follows:

[source, java]
----
// create an InitialContext
Properties properties = new Properties();
properties.put(Context.INITIAL_CONTEXT_FACTORY, "org.wildfly.naming.client.WildFlyInitialContextFactory");
InitialContext context = new InitialContext(properties);
 
// look up an EJB and invoke one of its methods (same as before)
RemoteCalculator statelessRemoteCalculator = (RemoteCalculator) context.lookup(
    "ejb:/ejb-remote-server-side//CalculatorBean!" + RemoteCalculator.class.getName());
int sum = statelessRemoteCalculator.add(101, 202);
----

[[programmatic-approach-1]]
====== Programmatic Approach

The information needed to connect to the remote server can be specified
directly in the client application's code:

[source, java]
----
// create your authentication configuration
AuthenticationConfiguration ejbConfig = AuthenticationConfiguration.empty().useName("bob").usePassword("secret");
 
// create your authentication context
AuthenticationContext context = AuthenticationContext.empty().with(MatchRule.ALL.matchHost("127.0.0.1"), ejbConfig);
 
// create a callable that invokes an EJB
Callable<Void> callable = () -> {
 
    // create an InitialContext
    Properties properties = new Properties();
    properties.put(Context.INITIAL_CONTEXT_FACTORY, "org.wildfly.naming.client.WildFlyInitialContextFactory");
    properties.put(Context.PROVIDER_URL, "remote+http://127.0.0.1:8080");
    InitialContext context = new InitialContext(properties);
 
    // look up an EJB and invoke one of its methods (same as before)
    RemoteCalculator statelessRemoteCalculator = (RemoteCalculator) context.lookup(
        "ejb:/ejb-remote-server-side//CalculatorBean!" + RemoteCalculator.class.getName());
    int sum = statelessRemoteCalculator.add(101, 202);
    ...
    return null;
};
 
// use your authentication context to run your callable
context.runCallable(callable);
----

[[general-utilities]]
== General Utilities

[[security-vault-migration]]
=== Security Vault Migration

Security Vault is primarily used in legacy configurations, a vault is
used to store sensitive strings outside of the configuration files.
WildFly server may only contain a single security vault.

Credential Store introduced in WildFly 11 is meant to expand Security
Vault in terms of storing different credential types and introduce easy
to implemnent SPI which allows to deploy custom implemenations of
CredentialStore SPI. Credentials are stored safely encrypted in storage
file outside WildFly configuration files. Each WildFly server may
contain multiple credential stores.

To easily migrate vault content into credential store we have added
"vault" command into WildFly Elytron Tool. The tool could be found at
$JBOSS_HOME/bin directory. It has several scripts named "elytron-tool.*"
dependent on your platform of choice. One can use also simple form "java
-jar $JBOSS_HOME/bin/wildfly-elytron-tool.jar <command> <arguments>" if
it better suites ones needs.

[[single-security-vault-conversion]]
==== Single Security Vault Conversion

To convert *single* security vault credential store use following
example:

- to get sample vault use testing resources of Elytron Tool project from
GitHub [1]

Command to run actual conversion:

--

`./bin/elytron-tool.sh vault --enc-dir vault_data/ --keystore vault-jceks.keystore --keystore-password MASK-2hKo56F1a3jYGnJwhPmiF5 --iteration 34 --salt 12345678 --alias test --location cs-v1.store --summary`

--

Output:

--

`Vault (enc-dir="vault_data/";keystore="vault-jceks.keystore") converted to credential store "cs-v1.store"` +
`Vault Conversion summary:` +
`--------------------------------------` +
`Vault Conversion Successful` +
`CLI command to add new credential store:` +
`/subsystem=elytron/credential-store=test:add(relative-to=jboss.server.data.dir,create=true,modifiable=true,location="cs-v1.store",implementation-properties={"keyStoreType"=>"JCEKS"},credential-reference={clear-text="MASK-2hKo56F1a3jYGnJwhPmiF5;12345678;34"})`

--

Use elytron-tool.sh vault --help to get description of all parameters.

[[notes]]
===== Notes:

- Elytron Tool cannot handle very first version of Security Vault data
file. +
- --keystore-password can come in two forms (1) masked as shown in the
example or (2) clear text. Parameter --salt and --iteration are there to
supply information to decrypt the masked password or to generate masked
password in output. In case --salt and --iteration are omitted default
values are used. +
- When --summary parameter is specified, one can see nice output with
CLI command to be used in WildFly console to add converted credential
store to the configuration.

[[bulk-security-vault-conversion]]
==== Bulk Security Vault Conversion

There is possibility to convert multiple vaults to credential store
using --bulk-convert parameter with description file. +
Example of description file from our tests [2]:

--

`# Bulk conversion descriptor` +
`keystore:target/test-classes/vault-v1/vault-jceks.keystore` +
`keystore-password:MASK-2hKo56F1a3jYGnJwhPmiF5` +
`enc-dir:target/test-classes/vault-v1/vault_data/` +
`salt:12345678` +
`iteration:34` +
`location:target/v1-cs-1.store` +
`alias:test`

`keystore:target/test-classes/vault-v1/vault-jceks.keystore` +
`keystore-password:secretsecret` +
`enc-dir:target/test-classes/vault-v1/vault_data/` +
`location:target/v1-cs-2.store` +
`alias:test`

`# different vault vault-v1-more` +
`keystore:target/test-classes/vault-v1-more/vault-jceks.keystore` +
`keystore-password:MASK-2hKo56F1a3jYGnJwhPmiF5` +
`enc-dir:target/test-classes/vault-v1-more/vault_data/` +
`salt:12345678` +
`iteration:34` +
`location:target/v1-cs-more.store` +
`alias:test`

--

After each "keystore:" option new conversion starts. All options are
mandatory except "salt:", "iteration:" and "properties:"

Execute following command:

--

`./bin/elytron-tool.sh vault --bulk-convert bulk-vault-conversion-desc --summary`

--

Output:

--

`Vault (enc-dir="vault-v1/vault_data/";keystore="vault-v1/vault-jceks.keystore") converted to credential store "v1-cs-1.store"` +
`Vault Conversion summary:` +
`--------------------------------------` +
`Vault Conversion Successful` +
`CLI command to add new credential store:` +
`/subsystem=elytron/credential-store=test:add(relative-to=jboss.server.data.dir,create=true,modifiable=true,location="v1-cs-1.store",implementation-properties={"keyStoreType"=>"JCEKS"},credential-reference={clear-text="MASK-2hKo56F1a3jYGnJwhPmiF5;12345678;34"})` +
`--------------------------------------`

`Vault (enc-dir="vault-v1/vault_data/";keystore="vault-v1/vault-jceks.keystore") converted to credential store "v1-cs-2.store"` +
`Vault Conversion summary:` +
`--------------------------------------` +
`Vault Conversion Successful` +
`CLI command to add new credential store:` +
`/subsystem=elytron/credential-store=test:add(relative-to=jboss.server.data.dir,create=true,modifiable=true,location="v1-cs-2.store",implementation-properties={"keyStoreType"=>"JCEKS"},credential-reference={clear-text="secretsecret"})` +
`--------------------------------------`

`Vault (enc-dir="vault-v1-more/vault_data/";keystore="vault-v1-more/vault-jceks.keystore") converted to credential store "v1-cs-more.store"` +
`Vault Conversion summary:` +
`--------------------------------------` +
`Vault Conversion Successful` +
`CLI command to add new credential store:` +
`/subsystem=elytron/credential-store=test:add(relative-to=jboss.server.data.dir,create=true,modifiable=true,location="v1-cs-more.store",implementation-properties={"keyStoreType"=>"JCEKS"},credential-reference={clear-text="MASK-2hKo56F1a3jYGnJwhPmiF5;12345678;34"})` +
`--------------------------------------`

--

The result is conversion of all vaults with proper CLI commands.

[[references]]
==== References:

[1]
https://github.com/wildfly-security/wildfly-elytron-tool/tree/master/src/test/resources/vault-v1 +
[2]
https://github.com/wildfly-security/wildfly-elytron-tool/blob/master/src/test/java/org/wildfly/security/tool/VaultCommandTest.java

[[security-properties]]
=== Security Properties

Lets suppose security properties "a" and "c" defined in legacy security:

[source, java]
----
        <subsystem xmlns="urn:jboss:domain:security:2.0">
            ...
            <security-properties>
                <property name="a" value="b" />
                <property name="c" value="d" />
            </security-properties>
        </subsystem>
----

To define security properties in Elytron subsystem you need to set
attribute `security-properties` of the subsystem:

[source, java]
----
./subsystem=elytron:write-attribute(name=security-properties, value={ \
    a = "b", \
    c = "d" \
})
----

You can also add or change one another property without modification of
others using map operations. Following command will set property "e":

[source, java]
----
./subsystem=elytron:map-put(name=security-properties, key=e, value=f)
----

By the same way you can also remove one of properties - in example newly
created property "e":

[source, java]
----
./subsystem=elytron:map-remove(name=security-properties, key=e)
----

Output XML configuration will be:

[source, java]
----
        <subsystem xmlns="urn:wildfly:elytron:1.0" final-providers="combined-providers" disallowed-providers="OracleUcrypto">
            <security-properties>
                <security-property name="a" value="b"/>
                <security-property name="c" value="d"/>
            </security-properties>
            ...
        </subsystem>
----

[[ssl-migration]]
== SSL Migration

[[simple-ssl-migration]]
=== Simple SSL Migration

This section describe securing HTTP connections to the server using SSL
using Elytron. +
It suppose you have already configured SSL using legacy
`security-realm`, for example by
link:Admin_Guide.html#src-557075_AdminGuide-EnableSSL[Admin Guide#Enable
SSL], and your configuration looks like:

[source, java]
----
<security-realm name="ApplicationRealm">
  <server-identities>
    <ssl>
      <keystore path="server.keystore" relative-to="jboss.server.config.dir" keystore-password="keystore_password" alias="server" key-password="key_password" />
    </ssl>
  </server-identities>
</security-realm>
----

To switch to Elytron you need to:

1.  Create Elytron `key-store` - specifying where is the keystore file
stored and password by which it is encrypted. Default type of keystore
generated using keytool is JKS:
+
[source, java]
----
/subsystem=elytron/key-store=LocalhostKeyStore:add(path=server.keystore,relative-to=jboss.server.config.dir,credential-reference={clear-text="keystore_password"},type=JKS)
----

* Create Elytron `key-manager` - specifying keystore, alias (using
`alias-filter`) and password of key:
+
[source, java]
----
/subsystem=elytron/key-manager=LocalhostKeyManager:add(key-store=LocalhostKeyStore,alias-filter=server,credential-reference={clear-text="key_password"})
----
* Create Elytron `server-ssl-context` - specifying only reference to
`key-manager` defined above:
+
[source, java]
----
/subsystem=elytron/server-ssl-context=LocalhostSslContext:add(key-manager=LocalhostKeyManager)
----
* Switch `https-listener` from legacy `security-realm` to newly created
Elytron `ssl-context`:
+
[source, java]
----
/subsystem=undertow/server=default-server/https-listener=https:undefine-attribute(name=security-realm)
/subsystem=undertow/server=default-server/https-listener=https:write-attribute(name=ssl-context,value=LocalhostSslContext)
----
* And reload the server:
+
[source, java]
----
reload
----
* Output XML configuration of Elytron subsystem should look like:
+
[source, java]
----
        <subsystem xmlns="urn:wildfly:elytron:1.0" ...>
            ...
            <tls>
                <key-stores>
                    <key-store name="LocalhostKeyStore">
                        <credential-reference clear-text="keystore_password"/>
                        <implementation type="JKS"/>
                        <file path="server.keystore" relative-to="jboss.server.config.dir"/>
                    </key-store>
                </key-stores>
                <key-managers>
                    <key-manager name="LocalhostKeyManager" key-store="LocalhostKeyStore">
                        <credential-reference clear-text="key_password"/>
                    </key-manager>
                </key-managers>
                <server-ssl-contexts>
                    <server-ssl-context name="LocalhostSslContext" key-manager="LocalhostKeyManager"/>
                </server-ssl-contexts>
            </tls>
        </subsystem>
----
+
Output `https-listener` in Undertow subsystem should be:
+
[source, java]
----
<https-listener name="https" socket-binding="https" ssl-context="LocalhostSslContext" enable-http2="true"/>
----
+
[[client-cert-ssl-authentication-migration]]
=== Client-Cert SSL Authentication Migration

This suppose you have already configured Client-Cert SSL authentication
using `truststore` in legacy `security-realm`, for example by
link:Admin_Guide.html#src-557075_AdminGuide-AddClient-CerttoSSL[Admin
Guide#Add Client-Cert to SSL], and your configuration looks like:

[source, java]
----
<security-realm name="ApplicationRealm">
  <server-identities>
    <ssl>
      <keystore path="server.keystore" relative-to="jboss.server.config.dir" keystore-password="keystore_password" alias="server" key-password="key_password" />
    </ssl>
  </server-identities>
  <authentication>
    <truststore path="server.truststore" relative-to="jboss.server.config.dir" keystore-password="truststore_password" />
    <local default-user="$local"/>
    <properties path="application-users.properties" relative-to="jboss.server.config.dir"/>
  </authentication>
</security-realm>
----
+
[IMPORTANT]

Following configuration is sufficient to prevent users without valid
certificate and private key to access the server, but it does not
provide user identity to the application. That require to define
`CLIENT_CERT` HTTP mechanism / `EXTERNAL` SASL mechanism, which will be
described later.)
+
At first use steps above to migrate basic part of the configuration.
Then continue by following:
1.  Create `key-store` of truststore - like for keystore above:
+
[source, java]
----
/subsystem=elytron/key-store=TrustStore:add(path=server.truststore,relative-to=jboss.server.config.dir,credential-reference={clear-text="truststore_password"},type=JKS)
----
2.  Create `trust-manager` - specifying `key-store` of trustore, created
above:
+
[source, java]
----
/subsystem=elytron/trust-manager=TrustManager:add(key-store=TrustStore)
----
3.  Modify `server-ssl-context` to use newly created trustmanager:
+
[source, java]
----
/subsystem=elytron/server-ssl-context=LocalhostSslContext:write-attribute(name=trust-manager,value=TrustManager)
----
4.  Enable client authentication for `server-ssl-context`:
+
[source, java]
----
/subsystem=elytron/server-ssl-context=LocalhostSslContext:write-attribute(name=need-client-auth,value=true)
----
5.  And reload the server:
+
[source, java]
----
reload
----
+
Output XML configuration of Elytron subsystem should look like:
+
[source, java]
----
        <subsystem xmlns="urn:wildfly:elytron:1.0" ...>
            ...
            <tls>
                <key-stores>
                    <key-store name="LocalhostKeyStore">
                        <credential-reference clear-text="keystore_password"/>
                        <implementation type="JKS"/>
                        <file path="server.keystore" relative-to="jboss.server.config.dir"/>
                    </key-store>
                    <key-store name="TrustStore">
                        <credential-reference clear-text="truststore_password"/>
                        <implementation type="JKS"/>
                        <file path="server.truststore" relative-to="jboss.server.config.dir"/>
                    </key-store>
                </key-stores>
                <key-managers>
                    <key-manager name="LocalhostKeyManager" key-store="LocalhostKeyStore" alias-filter="server">
                        <credential-reference clear-text="key_password"/>
                    </key-manager>
                </key-managers>
                <trust-managers>
                    <trust-manager name="TrustManager" key-store="TrustStore"/>
                </trust-managers>
                <server-ssl-contexts>
                    <server-ssl-context name="LocalhostSslContext" need-client-auth="true" key-manager="LocalhostKeyManager" trust-manager="TrustManager"/>
                </server-ssl-contexts>
            </tls>
        </subsystem>
----
+
[[documentation-still-needed]]
== Documentation Still Needed

** How to migrate application which uses different identity store for
authentication and authorization (migration to Elytron aggregate-realm).
** How migrate to using cache (migration to caching-realm)
** Limitations for migration from PicketBox/legacy security to Elytron,
for example, Infinispan cache cannot be used, login module stacking
cannot be used, any others?
